const core = require('@actions/core');
const fs   = require('fs');
const path = require('path');

(async () => {
  try {
    const item = core.getInput('item', { required: true });
    const file = core.getInput('path');
    const FILE = path.join(process.cwd(), file);
    let txt = fs.readFileSync(FILE, 'utf8');
    const now = new Date().toISOString().slice(0,16).replace('T',' ');
    const esc = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const rx  = new RegExp(`^- \\[ \\] .*${esc}.*$`, 'm');
    if (!rx.test(txt)) throw new Error(`Item not found: ${item}`);
    txt = txt.replace(rx, m =>
      m.replace('- [ ]', '- [x]')
        .concat(` <!-- done-by @${process.env.GITHUB_ACTOR || 'local'} at ${now} -->`)
    );
    fs.writeFileSync(FILE, txt);
    console.log(`âœ” ticked: ${item}`);
  } catch (e) {
    core.setFailed(e.message);
  }
})();
name: Tick Checklist Item
description: Mark a Markdown checklist item as done with audit trail.
runs:
  using: 'node16'
  main: 'index.js'
inputs:
  item:
    description: 'Exact text or unique substring of the checklist line'
    required: true
  path:
    description: 'Relative path to checklist file'
    default: 'docs/plan-b2.checklist.md'
name: CI Status
on: [push, pull_request]
jobs:
  progress:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: {node-version: 20}
      - run: npm i -g pnpm
      - run: ./scripts/run-green-flag.sh
      - uses: ./.github/actions/tick-checklist
        with:
          checklist-path: docs/plan-b2.checklist.md
          items: |
            P1 secrets-verify committed and green in CI
            Green-flag drill completed (`./scripts/run-green-flag.sh`)
      - uses: peter-evans/create-pull-request@v6
        with:
          branch: progress-bot/${{ github.run_id }}
          delete-branch: true
          title: "chore(progress): auto-update checklist"
          commit-message: "chore(progress): auto-tick items"
.DS_Store\nnode_modules
kg-repo.bash
repo-kg.json
patches:
  P1: secrets-verify committed and green in CI
  P2: Fly cold-start guard merged
  P3: entrypoint.sh idempotent migrations
  P4: demo wallet pre-fund
  P5: rollback observability
  P6: pm2 log rotation + tmux tweaks
  P7: pnpm-store path pinned
  P8: CI gate hard-fail / timeout
drills:
  - Green-flag drill completed
  - Live-fire rollback rehearsal completed
done:
  - secrets-verify passes on Fly & Vercel
# Plan Bâ—.2 â€” progress tracker

## Patches
- [ ] P1 secrets-verify committed and green in CI
- [ ] P2 Fly cold-start guard merged
- [ ] P3 entrypoint.sh idempotent migrations
- [ ] P4 demo wallet pre-fund
- [ ] P5 rollback observability
- [ ] P6 pm2 log rotation + tmux tweaks
- [ ] P7 pnpm-store path pinned
- [ ] P8 CI gate hard-fail / timeout

## Drills
- [ ] Green-flag drill completed
- [ ] Live-fire rollback rehearsal completed

## Definition of Done
- [ ] secrets-verify passes on Fly & Vercel

#!/usr/bin/env bash
set -euo pipefail

NAME="$1"
TARGET="bash-vault/scripts/$NAME"
META="bash-vault/metadata/${NAME%.sh}.meta.json"

[[ -f "$TARGET" ]] && { echo "âŒ $NAME already exists"; exit 1; }

touch "$TARGET"
chmod +x "$TARGET"

cat > "$META" <<JSON
{
  "script": "$NAME",
  "description": "TODO: Describe what this script does",
  "created": "$(date -I)",
  "author": "$(git config user.name || echo unknown)",
  "testedOn": [],
  "appliesTo": [],
  "tags": []
}
JSON

node bash-vault/sync-index.js
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const META_DIR = 'bash-vault/metadata';
const SCRIPT_DIR = 'bash-vault/scripts';
const OUTFILE = 'bash-vault/index.md';

const entries = fs.readdirSync(META_DIR).filter(f => f.endsWith('.json'));

let rows = [];

entries.forEach(file => {
  const meta = JSON.parse(fs.readFileSync(path.join(META_DIR, file), 'utf8'));
  const name = meta.script;
  const desc = meta.description || "â€”";
  const tags = (meta.tags || []).join(', ');
  const link = `[${name}](scripts/${name})`;
  rows.push(`| ${link} | ${desc} | ${tags} |`);
});

const out = `# Bash Vault

| Script | Description | Tags |
|--------|-------------|------|
${rows.join('\n')}
`;

fs.writeFileSync(OUTFILE, out, 'utf8');
console.log(`âœ… index.md updated with ${rows.length} script(s)`);

#!/usr/bin/env bash
# Re-initialize the vault system, patch README, and sync index

set -euo pipefail

echo "ğŸ”§ Patching README.md if needed..."
if ! grep -q "## ğŸ§° Bash Vault" README.md; then
  cat >> README.md <<'MARK'

---

## ğŸ§° Bash Vault

Reusable infrastructure scripts with metadata, stored in `bash-vault/`.

- Scripts live in [`bash-vault/scripts/`](bash-vault/scripts/)
- Metadata lives in [`bash-vault/metadata/`](bash-vault/metadata/)
- Index is auto-generated in [`bash-vault/index.md`](bash-vault/index.md)

To add and index a new script:

```bash
make new NAME=my-script.sh
make sync
```
MARK
else
  echo "â„¹ï¸ README.md already mentions Bash Vault."
fi

echo "ğŸ“„ Syncing index..."
node bash-vault/sync-index.js

echo "âœ… Bash Vault is initialized."
ref: refs/heads/main
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:metagrati/ProfitFlip.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
[branch "chore/bash-vault-init"]
	remote = origin
	merge = refs/heads/chore/bash-vault-init
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
246b7b2981c462241e83f1e026276a91dc765c38
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450
246b7b2981c462241e83f1e026276a91dc765c38
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {
			"since": $last_update_token,
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
updated .gitginore
0000000000000000000000000000000000000000 4c8341f099a68351611bf0be63a2e39686a63d9c ariel <ferdmanariel707@gmail.com> 1745415973 +0200	commit (initial): feat: scaffold Plan Bâ—.2 launch kit
4c8341f099a68351611bf0be63a2e39686a63d9c 0000000000000000000000000000000000000000 ariel <ferdmanariel707@gmail.com> 1745416446 +0200	Branch: renamed refs/heads/master to refs/heads/main
0000000000000000000000000000000000000000 4c8341f099a68351611bf0be63a2e39686a63d9c ariel <ferdmanariel707@gmail.com> 1745416446 +0200	Branch: renamed refs/heads/master to refs/heads/main
4c8341f099a68351611bf0be63a2e39686a63d9c d36a367d3fdb23ad6c3ce94b829beb5c505880c8 ariel <ferdmanariel707@gmail.com> 1745417134 +0200	commit: feat(plan-b): scaffold checklist system, generator, linter, local action
d36a367d3fdb23ad6c3ce94b829beb5c505880c8 1a407f8c974c9abb9e844e2b45905461bd3d6244 ariel <ferdmanariel707@gmail.com> 1745418524 +0200	commit: feat(plan-b): scaffold checklist system, generator, linter, local action
1a407f8c974c9abb9e844e2b45905461bd3d6244 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745418954 +0200	commit: feat(ci): rewrite run-green-flag.sh for robustness and observability
0cca85f0050d883586791eca2e92bcf0557bd8cb 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745419906 +0200	checkout: moving from main to chore/bash-vault-init
0cca85f0050d883586791eca2e92bcf0557bd8cb 940e45302c3db15e79153c5737ead64eaa47410d ariel <ferdmanariel707@gmail.com> 1745419923 +0200	commit: chore(vault): scaffold bash-vault structure with index, metadata, and new script helper
940e45302c3db15e79153c5737ead64eaa47410d 246b7b2981c462241e83f1e026276a91dc765c38 ariel <ferdmanariel707@gmail.com> 1745420298 +0200	commit: feat(vault): add sync + script-gen tools for Bash Vault system
246b7b2981c462241e83f1e026276a91dc765c38 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745421679 +0200	checkout: moving from chore/bash-vault-init to main
0cca85f0050d883586791eca2e92bcf0557bd8cb 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745422221 +0200	reset: moving to HEAD
0cca85f0050d883586791eca2e92bcf0557bd8cb 41cc175d6cef49b81de51ed977345ac2e1e9d3be ariel <ferdmanariel707@gmail.com> 1745422225 +0200	pull: Fast-forward
41cc175d6cef49b81de51ed977345ac2e1e9d3be 266f54b941e974600153de779f216b7116f2ed21 ariel <ferdmanariel707@gmail.com> 1745422852 +0200	pull: Fast-forward
266f54b941e974600153de779f216b7116f2ed21 63bf93ba911cd6d887c2a1ce4b7b01524c881a36 ariel <ferdmanariel707@gmail.com> 1745423035 +0200	commit: remove test.json and update .gitginore
63bf93ba911cd6d887c2a1ce4b7b01524c881a36 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745423192 +0200	commit: updated .gitginore
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745424624 +0200	checkout: moving from main to feat/initialize-vault
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745424800 +0200	checkout: moving from feat/initialize-vault to main
0000000000000000000000000000000000000000 940e45302c3db15e79153c5737ead64eaa47410d ariel <ferdmanariel707@gmail.com> 1745419929 +0200	update by push
940e45302c3db15e79153c5737ead64eaa47410d 246b7b2981c462241e83f1e026276a91dc765c38 ariel <ferdmanariel707@gmail.com> 1745420299 +0200	update by push
0000000000000000000000000000000000000000 4c8341f099a68351611bf0be63a2e39686a63d9c ariel <ferdmanariel707@gmail.com> 1745416447 +0200	update by push
4c8341f099a68351611bf0be63a2e39686a63d9c d36a367d3fdb23ad6c3ce94b829beb5c505880c8 ariel <ferdmanariel707@gmail.com> 1745417361 +0200	update by push
d36a367d3fdb23ad6c3ce94b829beb5c505880c8 1a407f8c974c9abb9e844e2b45905461bd3d6244 ariel <ferdmanariel707@gmail.com> 1745418641 +0200	update by push
1a407f8c974c9abb9e844e2b45905461bd3d6244 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745418977 +0200	update by push
0cca85f0050d883586791eca2e92bcf0557bd8cb 41cc175d6cef49b81de51ed977345ac2e1e9d3be ariel <ferdmanariel707@gmail.com> 1745422225 +0200	pull: fast-forward
41cc175d6cef49b81de51ed977345ac2e1e9d3be 266f54b941e974600153de779f216b7116f2ed21 ariel <ferdmanariel707@gmail.com> 1745422852 +0200	pull: fast-forward
266f54b941e974600153de779f216b7116f2ed21 63bf93ba911cd6d887c2a1ce4b7b01524c881a36 ariel <ferdmanariel707@gmail.com> 1745423043 +0200	update by push
63bf93ba911cd6d887c2a1ce4b7b01524c881a36 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745423214 +0200	update by push
0000000000000000000000000000000000000000 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745419906 +0200	branch: Created from HEAD
0cca85f0050d883586791eca2e92bcf0557bd8cb 940e45302c3db15e79153c5737ead64eaa47410d ariel <ferdmanariel707@gmail.com> 1745419923 +0200	commit: chore(vault): scaffold bash-vault structure with index, metadata, and new script helper
940e45302c3db15e79153c5737ead64eaa47410d 246b7b2981c462241e83f1e026276a91dc765c38 ariel <ferdmanariel707@gmail.com> 1745420298 +0200	commit: feat(vault): add sync + script-gen tools for Bash Vault system
0000000000000000000000000000000000000000 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745424624 +0200	branch: Created from HEAD
0000000000000000000000000000000000000000 4c8341f099a68351611bf0be63a2e39686a63d9c ariel <ferdmanariel707@gmail.com> 1745415973 +0200	commit (initial): feat: scaffold Plan Bâ—.2 launch kit
4c8341f099a68351611bf0be63a2e39686a63d9c 4c8341f099a68351611bf0be63a2e39686a63d9c ariel <ferdmanariel707@gmail.com> 1745416446 +0200	Branch: renamed refs/heads/master to refs/heads/main
4c8341f099a68351611bf0be63a2e39686a63d9c d36a367d3fdb23ad6c3ce94b829beb5c505880c8 ariel <ferdmanariel707@gmail.com> 1745417134 +0200	commit: feat(plan-b): scaffold checklist system, generator, linter, local action
d36a367d3fdb23ad6c3ce94b829beb5c505880c8 1a407f8c974c9abb9e844e2b45905461bd3d6244 ariel <ferdmanariel707@gmail.com> 1745418524 +0200	commit: feat(plan-b): scaffold checklist system, generator, linter, local action
1a407f8c974c9abb9e844e2b45905461bd3d6244 0cca85f0050d883586791eca2e92bcf0557bd8cb ariel <ferdmanariel707@gmail.com> 1745418954 +0200	commit: feat(ci): rewrite run-green-flag.sh for robustness and observability
0cca85f0050d883586791eca2e92bcf0557bd8cb 41cc175d6cef49b81de51ed977345ac2e1e9d3be ariel <ferdmanariel707@gmail.com> 1745422225 +0200	pull: Fast-forward
41cc175d6cef49b81de51ed977345ac2e1e9d3be 266f54b941e974600153de779f216b7116f2ed21 ariel <ferdmanariel707@gmail.com> 1745422852 +0200	pull: Fast-forward
266f54b941e974600153de779f216b7116f2ed21 63bf93ba911cd6d887c2a1ce4b7b01524c881a36 ariel <ferdmanariel707@gmail.com> 1745423035 +0200	commit: remove test.json and update .gitginore
63bf93ba911cd6d887c2a1ce4b7b01524c881a36 cf9e1d4f72b392c76ee1b146cbfd7132fc33c450 ariel <ferdmanariel707@gmail.com> 1745423192 +0200	commit: updated .gitginore
DIRC      ?hù'-Aµhù'-Aµ   ş!’  ¤  è  è  Zò²&ÀT–÷üŠ}d„‰‘_ ‹&ì ).github/actions/tick-checklist/action.yml hù'jJƒhù'jJƒ   ş!“  ¤  è  è  ^Ü¨ÄÂ÷è “ÉK'¹°Á3&n '.github/actions/tick-checklist/index.js   hï%.‚hï%.‚   ş!‘  ¤  è  è  Lâ¼¢ï:€)¸6–²=ğâ«6 .github/workflows/ci-status.yml   h	AŠõlh	A–Ò>   ü0  ¤  è  è   2P×[GÓGó@kJPê>ÎIX 
.gitignore        h	‘)rÏ%h	‘)rÏ%   ü0  ¤  è  è   ª¦y-ÎEQõµJ£Y“koÒ| ' Makefile  h	
.ê¥éh	
.ê¥é   ü0  ¤  è  è  oËsÙÇ(<’`¸uİCwÒø 	README.md h	‘)rÏ%h	‘)rÏ%  â  ¤  è  è    æâ›²ÑÖCK‹)®wZØÂäŒS‘ bash-vault/index.md       h	¬í"h	¬°W    í  è  è  ükçx,dŠÙªuõù¢Á@ã|æ bash-vault/new-script.sh  h	¬*ïh	¬*ï    í  è  è  	ãèu'0ÖÛŒ,ø1Õ,p_óT­M &bash-vault/scripts/initialize-vault.sh    h	‘)rÏ%h	‘)rÏ%    ¤  è  è  >i¼ğG’şân¤æ, igë&®Ş¤ bash-vault/sync-index.js  hù CBJhù 9{   ş!”  í  è  è  F©På\ì%éEè\€—R’]y¶å bin/gen-checklist.js      hù'-Aµhù&ğ8æ   ş!  í  è  è  ~Ô6¨ÅVEØ0ä|‰bóÉ‰‰ bin/lint-checklist.js     hó£öøˆhó£¹ï¹   ü0  í  è  è  ‚}0!}‹J†·r•VsËªTÕ† bootstrap-plan-b2.sh      hòÑCv¼hîô	—Jh   ü/ù  í  è  è  Ó<£à&nÅ´àT®£¸_l»7 bootstrap-plan-b2.sh.old  hù&9yhù&9y   ü/ü  ¤  è  è  ûy¾‰uf=Éc+TÇY°¾Ø docs/plan-b2.checklist.md hó®*Wtxhó®*Wtx        è  è   ½Gh¹BŒ¹ì:Ï×ªÉ“ node_modules/.bin/js-yaml hó®,²"hó®,²"    ¤  è  è  /›IÚO¬°Bœ¿Ñx‹–_]NF node_modules/.package-lock.json   hó®'>õhó®'>õ    ¤  è  è  NÜ9íiRøzÜÙaĞwIáÿç¢·3[ "node_modules/argparse/CHANGELOG.md        hó®$¡hó®$¡  ñ  ¤  è  è  1çf£¬€×)£¥½ı" -4¾Y¦Úò" node_modules/argparse/LICENSE     hó®'{
Ähó®'{
Ä    ¤  è  è  
ĞU\›{ ª¡‹¢@´…å³˜ï² node_modules/argparse/README.md   hó®&ÃğWhó®&ÃğW  ó  ¤  è  è ú²+ŒŒczùuzD’lü:·Ù‡Œ“‡ !node_modules/argparse/argparse.js hó®' ù'hó®' ù'  ü  ¤  è  è  Ìãë2üìD¢¡âÌ}ë¼Êt  node_modules/argparse/lib/sub.js  hó®' ù'hó®' ù'  ş  ¤  è  è  Cï#ÕÛ•ÌÈY¶­ã÷àyCYş %node_modules/argparse/lib/textwrap.js     hó®'>õhó®'>õ    ¤  è  è  ªd}*ÿÒ¬Ç<Fàš*"÷³j "node_modules/argparse/package.json        hó®)&Hmhó®)&Hm    ¤  è  è  Kÿ#uàUİ"ÀÑ×nà;Í
3ì !node_modules/js-yaml/CHANGELOG.md hó®!….hó®!….  î  ¤  è  è  <	Ó¢“Ñ#ßszXûØ“€Š¼‚ node_modules/js-yaml/LICENSE      hó®)cQ<hó®)cQ<    ¤  è  è  !<¼KÒİ³:Â!¶‡Hyyj²ÏD" node_modules/js-yaml/README.md    hó®*”}Ghó®'¸“    í  è  è  
°¡‚ñ¯°Î¥À¶1'y<+ó. #node_modules/js-yaml/bin/js-yaml.js       hó®'õchó®'õc    ¤  è  è ¾·LÀİöÒaj7á–Ï¢¨E@"ØlØ $node_modules/js-yaml/dist/js-yaml.js      hó®(2%1hó®(2%1  	  ¤  è  è  š½ØîõB³2áËé{ºÀ´Fr< (node_modules/js-yaml/dist/js-yaml.min.js  hó®) Zhó®) Z    ¤  è  è ¤¾qÊÑ©&ælä=A˜€­ 'à %node_modules/js-yaml/dist/js-yaml.mjs     hó®'>õhó®'>õ     ¤  è  è  ¼·ë§­§Ş®U’DÄœ®£„ node_modules/js-yaml/index.js     hó®&†çˆhó®&†çˆ  õ  ¤  è  è  ™%ï}J0 œÅH:±jòKS "node_modules/js-yaml/lib/common.js        hó®' ù'hó®' ù'  ù  ¤  è  è  |•óW¦®éƒ¯–?êN’=æAİ" ˆñ "node_modules/js-yaml/lib/dumper.js        hó®' ù'hó®' ù'  û  ¤  è  è  bÚ®ø¼Û‚HÚÖ^{(€¥ÁÏ’ %node_modules/js-yaml/lib/exception.js     hó®(2%1hó®(2%1    ¤  è  è  ¸&9ñ?VUØÖfİu‚ÎX™šŒ† "node_modules/js-yaml/lib/loader.js        hó®(o. hó®(o.     ¤  è  è  8e´@Ş¨Å¶CJÂ•µÃuj¥ "node_modules/js-yaml/lib/schema.js        hó®&ÃğWhó®&ÃğW  ÷  ¤  è  è   `‹&Ş+º–íĞ
Ä‘$r'ı 'node_modules/js-yaml/lib/schema/core.js   hó®&ÃğWhó®&ÃğW  ø  ¤  è  è  :ğR\ä<7Ô¼p×wGHŸ,¯ *node_modules/js-yaml/lib/schema/default.js        hó®' ù'hó®' ù'  ı  ¤  è  è  ·£>·¡Ìêx»ZÙ¤aåyøzå +node_modules/js-yaml/lib/schema/failsafe.js       hó®(2%1hó®(2%1  
  ¤  è  è  ·=÷Q:w»Ê£g«(9QZ 'node_modules/js-yaml/lib/schema/json.js   hó®(¬6Ïhó®(¬6Ï    ¤  è  è   â<nëé‰_HmpuÉ³¥Ÿ #node_modules/js-yaml/lib/snippet.js       hó®(é?Ÿhó®(é?Ÿ    ¤  è  è  9^W‡êÒ˜Šæp)ñÆ½5º0  node_modules/js-yaml/lib/type.js  hó®%U»~hó®%U»~  ò  ¤  è  è  `áR5ßQ[EJ¦™iN5[ª/ 'node_modules/js-yaml/lib/type/binary.js   hó®%’ÄMhó®%’ÄM  ô  ¤  è  è  ËËwE“
ní5ëë¨¯k¨±	” %node_modules/js-yaml/lib/type/bool.js     hó®'>õhó®'>õ  ÿ  ¤  è  è  	£t×~Âæn“ò$‚-QÈàDÀa² &node_modules/js-yaml/lib/type/float.js    hó®'>õhó®'>õ    ¤  è  è  k?ã¤C{y
!{…ÜÚ»KB„şó $node_modules/js-yaml/lib/type/int.js      hó®(o. hó®(o.     ¤  è  è   ¾ó'¾ëÕ;ÛïÆ hú[gT9T $node_modules/js-yaml/lib/type/map.js      hó®(o. hó®(o.     ¤  è  è   æ®¨dDÏ*Q·#uj±¼ó &node_modules/js-yaml/lib/type/merge.js    hó®(o. hó®(o.     ¤  è  è  (1\¤â6ßA22!]9C'Z %node_modules/js-yaml/lib/type/null.js     hó®(o. hó®(o.     ¤  è  è  ÿ²µ2;ÑÍ:‘s6¢$ğ¸„Ö %node_modules/js-yaml/lib/type/omap.js     hó®(o. hó®(o.     ¤  è  è  <tµ$ü] ‡&¸sh‘sH &node_modules/js-yaml/lib/type/pairs.js    hó®(¬6Ïhó®(¬6Ï    ¤  è  è   ¿¾wò„Kİm›¨Î¨‰Šœ $node_modules/js-yaml/lib/type/seq.js      hó®(¬6Ïhó®(¬6Ï    ¤  è  è  #ø…£)ÂÊ
Nº'ƒäQaï95I $node_modules/js-yaml/lib/type/set.js      hó®(¬6Ïhó®(¬6Ï    ¤  è  è   ½'¬ÁÊ¯u+`=ú`8¦(† $node_modules/js-yaml/lib/type/str.js      hó®(¬6Ïhó®(¬6Ï    ¤  è  è  
©Å†V—íĞ¡¥ÂwY¶è»Îô *node_modules/js-yaml/lib/type/timestamp.js        hó®)&Hmhó®)&Hm    ¤  è  è  èWM¨¡€2©·Å„âãh^ÀCÈ !node_modules/js-yaml/package.json hó®,²"hó®,²"   ü0  ¤  è  è  ÷éÏ~a'Â(¥dÃƒzqÑY‰‚ package-lock.json hó®+K—´hó®+K—´   ü
j  ¤  è  è   7»ÎJÅTO©NŠÂEâ¼xXÇ8 package.json      hù 9{hù 9{   ü/û  ¤  è  è  ¢!ƒF3Ğ&ñ°ø8¯Væš>. plan-b2.yaml      hùÜOÀhù	2[J   ü0  í  è  è  Éñßoêôâp¡¦®Å›ByÀ# post-bootstrap-ops.sh     h	0×®èh	0×®è   ü+Q  í  è  è  üä£Ñ]·i±dFzĞwÉ ’" scripts/run-green-flag.sh hï%²Aªhï%80   ü/ı  í  è  è  È‡§¶ØğšÂ­<, R©İ²3 scripts/stopwatch.sh      TREE  9 -1 6
bin 2 0

Jàƒ˜n$
õÎœ˜}+éùûqÇNdocs 1 0
tvùjâ`S¸b¹±lƒø˜…Ö.github 3 2
„vBìzËU“ì“¹‰ÅüâxuÒactions 2 1
ñI’]ê®Eô¸Wñ°!«`£ªtick-checklist 2 0
L%po$ğä ˜M—m+¾Fuªworkflows 1 0
½0O/N5¶óà»îM½œŞñÃscripts 2 0
›Á(£Á®.~²ÑŸL	#EÆb	Gbash-vault -1 1
scripts -1 0
node_modules 42 3
ÊQíûuÒÀö¾ÿ^İÏË×ÑOâ~.bin 1 0
²¶S»9.Ò~~n9P„¦Ñ@Ğ¦js-yaml 33 3
·Ü¶‡‹ŞñÑyC«g¶CU;xFbin 1 0
ğãzÛŠ3P`ŞúĞª3ˆ!lib 24 2
­^pUH1¨cªïÊ„Ãë‡type 13 0
çB$uú<÷õÈfIGà|èšG~schema 4 0
HU·‚I|f(a8¦ÎÃæ«É=¯ødist 3 0
’ÒtS<Xn_ƒ'÷–HHÈ®Wóargparse 7 1
Ò<º:7PI9öìol·°$Œ+lib 2 0
Œ×Q‘I™b”xÛ O½4åûÌ¤R>,Ø`¥v¡z$KuJUnnamed repository; edit this file 'description' to name the repository.
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450
cf9e1d4f72b392c76ee1b146cbfd7132fc33c450		branch 'main' of github.com:metagrati/ProfitFlip
246b7b2981c462241e83f1e026276a91dc765c38	not-for-merge	branch 'chore/bash-vault-init' of github.com:metagrati/ProfitFlip
xmŒA‚@ =ï+úŒr£W¿À–İF*lÁm›˜ÿ.!áÆuf2Ã¼po»‹ÄB=§	#¥ifµÀ²º)€t°f6"|+½+e«N¿-a£¢'¦ºìW–'‚,™ÚÛÖ—È‚À’és}iøÇa.»xVmoÛ6ŞgşŠ+ºÍvQkÓî%…Q´ëth×`é¾ÌjJ¢-6’¨‘”=7èßs”d;AVÌ€-™¼×çŞ1«lFøşÇ¯”[·Êy-æÃGˆÅƒÅËÎT]:5-ChıyšzwNËàÔÆø$7ÒºuÚØBç*íH¿Y?Ïœjòr^+´›õ ÿEÅûııâ-m´óÆ6·¦^K_]^›6mnnù<pˆÛíVBà£±µ*¿Vk½	ñó›×„X»Z7ÁSLİÑÊ:â<äGJ[JZø.Kr[×ª)(lîe»¥m¢ƒ3ùSZ¤ëv{'²uõğXF¾k[ë‚¤ü’]Qocâi1·Gé®Boî÷1£é€-ˆüî Ù9t™Diï)Í‡g†Ê§›(îòGé“ow³™âää•Y­´ÓM®{4¬3kÓ¨Jœ‘Ğo—T*ÄèZï¶ÖGˆ™
¢„èByO¶¨§'Ó€ª8§e£·ôb(Â³ÏMo¨Ğ>w&ÊÓDÿ£ê¶Ò“SREñ¡ÔU{NÁuš>Ï–òV{(Ã®Õ–¦	ËSZ®*«øEJcùÓkòÁ™f°`AªµG0’Œ”˜N’>oˆeŒáoï~ÂÉÀò·dâÔ*ounVF;ê<‡àôßqz:é‚©&3‰Ì!¦ºxkF²A™Š1¡
~5•)Œ¾ø¥Ï\$ıGˆeĞ>€špg*}…åò£Ú¨.ñğAÚy—f¦Iu³‰<Ä³ÍÃä™9àHê6æô™æ´uäádöl/?Òë– L‡c…lÃâƒüp˜æt_yQƒÛF,QÆJ‹Ïlª7r·&a’$C<±@*gV¡D‡Å}¸0t¿Uogem´1Ô)SKû_ŠL
ÀRÌAAû%E¨|º­òéà+g+-ã¦CÄñÁ|ôÓÂA­…xe|[©]ï6Ö_|M2xAI):>‡Ò3…Iy…Ÿÿ¬è×wïø%£—/şà	ï]	q·
Bô§UU‡3}Îç§<¥$á´iüøÒn)”ÆÇ°‡‰c 4L”ÔVÚ°ÒX•¨•Zg×NÕè~ã^ÓÕNÏ±n›õ¹:È€i†ÇTx“+€¬ˆ7X€7ÇôÆ@y3‚ŞƒyÁç8»¸|ÏÕü¬·=2˜{*nØ<èv†jÂŞÄ·Ox{
ôÆÅ‹‹×Ä|<¾‰—†iD
`)âIĞ÷ÕÚ4¦Ô…kî·§Cç4è®^ƒ* [Ø<,Å”—‚[ÙØ’É6zì¬Ãìj,h@*³]€å±“£µ<’´x7´r¶y˜ñÿškèP­„. U}Ù˜ìaÎğ€„¡3º;iúf~ÜÇ¾øahk×:ƒûÊĞï>@é:«Ê*Ô8ø8o*½7…®Ì*Ğe—íGï±U+4z|qõàé¼÷É„Ä°ÇéÂ5€w,—×†x¯ Èhå€×˜*}E÷>‚E¿«¸®Ä×ír 4Ş"Ñ£Oİà¦¤cn¢muCŞvk…ÆŸ¤0¨æÎv<[f³x7ÃÎKÛV&¬ğ’.Õ¦‰œ.:˜ P× HÂÔ8tØÎqËÁyUUÀŞ–˜'HfÇá³û;0ğºsİª÷F+×P&ÌñökĞê´½Æu±­“Şç]¨?ôÙÎ×¿åõZ¦«çNã&âT×rÜ	”Y7óâ:HÁ’­‰/ï©Ïx]RÛrÓ0å9_±É ©Ø
ğĞé å’@f˜éLâ+Šì+•dâŒã¿à‘¯ãKX5·6#ïÙ³çèì4×S¸¼xıLêÂ:Ú(¸£îËÌ(J®…tV:¾@ØÛÖ–X€Ç°ÄkKáækşì«-*ìº@\u¡n8³~xõÃ3§ØéGñT¹A±,%ş+	 Ş‹š½ÁÆRAƒœ¨b×›d¹~Ò»Ÿ}ÄõßzˆóşSg]-•µ\®f”àyvÄ¹rà*‡èÄr£Ä¬µ!Z $ RºäÒ;;²z…ğB­à³pŠ2îô`x3t&+R<Ù<“Š¾^]0$\æOdDOi”•Hã`1?ñş®]7”mÆÑ$Š&5DQûùÓfSùh¼†[•öª%ïBˆ¢1>àçíÙ|ÇØ½Ø·f	Ğ3Sq§¬£hš1psƒn<OÏmh<ğñÚA¢ËSh×^aïn`{Uø{Ğlª 0ĞîÃÍÆ0ÁPıŸjBØÀq¤p4†wga3]¨pº†ëv½ÏI¿ù—Áèë÷?>|İÜÂf$×Rä¤áP†Ğ@vã-íNf¸2(ø$Dïõ˜ ÎÏuJãÿ€Ëä/uê³”'ç@;ì.®«U®/p=fTñ®“H·[Ô´FqÀ4„NxWkoÛÈígıŠÁ
èÊI‘ÔÃ’q½M²h÷'Û¢ğĞˆIóÕ™¡l÷×÷Ü’¢d!-‘EqÎÜ{Ï¹gî¬ÓbÍfËùüCv»ãùV¤Åv0¸IS–†¯SÁbûX3S0³“š•ªø*bÃ%^Z–q•‰Üˆ„ÉÜ½²‘©ğƒÏ;Á6…Ê¸aX·æ¯9»ÿ›%ã‡ı¾ŒvÆ”úz<~À/Ümˆ8ü¸ÈÆ"‡~àã‹ËÏ“ãx²JØØî?‰ŒçFÆìBiYä2ß€µÈöBù…Úu)âñ>"Lg²ô‘†CvOÂ/ÌcQ^°ğ¢%Ù{ù$’GŸÈCW©›[¡±ĞÚçj»_±ÇÈYE)Ú_%
¢J%ğ¿f£U\l6B¬.ÙÊh//úS˜Ø¿¸dÃptCº!„S‚£ÆQ¡êJ<*i„Ï~.YY(Ã6ªÈXùlv¨ïÄ_úû#Ë
%À–ˆ¥&Ò´xDMücŸ„`÷àíËÈãã‚Xb‰DˆJä±`TçLn7¨#Xİ>ò§°ı¯š…ÁDğïJ*[–;‘{¤Ú°bÃÒ"æ)©B“6|_TŠJneŸŠ\è&a¢6¬3^yáì¨è¿!vè ID¹6‚CCöÆ†Ì•âÏšJE]Ä¥+a8÷‚eÃâ¡„wÈ2P#ãĞÃ(†hOD©YŒ_òªì¢-¾‰ö'ªsNuYˆu••—lµPÅØÜŸ½aFhƒ@cTJñ­@ıˆ¶VzÂÕa›‰^ğşY /ØŠ'ÉÚÚ~[QGò8¥aÚ(PË D–óåeÃåÕ%{gŠìÉk™wó™6Š¼`~²Q'ŸkpJÌb¡S¤	QUeÂ©Õo?u!gGÁnÁNZ$\ï¨Î"O ´gBÖr›ËŒÑ»é3ê’T($1Í!t-ÿ#aì3<èÁ¶ù»rÊÑÊuÓRå¦‡İÃ—•;J¨ÁeAÛO±¾m?›Ô`3/¼ÈÑĞu€’+(gõvEêFÁõ5[yxâY™Â¼Ìîíw·×¿gÏh¸D¨ßE¾û4Ÿ~·%‹)(¹åæŸ°›¯w“ˆÚ}ƒ‰E'¬Ü‰”Ã…Ğ\¶„PY\§”]¨ÚÄÂõSœ@Õ¼ÖJg °rø-2äúÖÄ j	g·:şzÔ³MËÚ-Bç“Â;%£¶×È@îD™òY¬*ğ¯tƒ‚qZ3u‰­èµ¿ ğR“#H"^bk-u¬›” çê,CËZgóØÇ?}şåî_~–0ïÏìöãÍÏşú÷_>à{­Ø6€>C„':=û­Ö}+^ªù$]S|ŞôÂÄ ¡‰ï™g3êM%Ö…Z,»5JvkNÖÎ#¬Íø“áqÑ]ÚèK§8¼NrºIª»Ÿ—ğõÜÖå¬»Gî™u[²‘$ áËNGÇÑÀ˜7©ŒÍGT"1£át#íİ®äUúµ‹ÕhÒb®­lP Üw…cÅÚ$‘7"ÜÎ¡ÖmŞ?Ù»rê©RÆ¢%šF~…däª:Ñu÷ŸªÔH,gëj‹7ÌúLìQÈ›¸ŠgqŸU¦Â!'â´¢u3f+wDÛ9$ûq*×Š«ç1|ÄúŠH†RC\ÀuURU.1ÿ´VØT¹›‡å‡%Ü8Ív"~°GåJ°~‹‡f_¡V0áú;íëgÁ!$vOÂnU›ûKc_nW;ÿØyB»/Fµ6°‘¤†ÑÌ¾LÉ[@LÄB2lÏSŒ]k±ã{‰QÅYÆŸV˜}´¤Ğy
¾ÎÁü˜aJÛÃ¯·ÂüàÀF«éÛ‹r±…b5è±G.#’à4ç–¹’
ÕÌ¶Pµ»·åZÜãa]ŒpùÍbœSGSËàìòC`Í„AÍìÕ“åq`ßÇ»Bb¨ış8åÃáü½åD¦L”V¦¬LE8»èô}ã´°Ù%ş1ÃƒD›†¶Ãb-àQ‡Ôv˜énĞ¸­Ûà…ÛZÆ »¡nù×8/0''ìb7nì«¦ÛëUjQ%…×ê£îÒ#èÛ4‘ıšòçCéx’|iÙê{¤wE•&t2ªàQnè†•íÔ`-òu
è– q~„9?3±‘ÚKœ¼”vB¼fïÛg8()˜öA‡¾æ ô¬¤›
4s?l
· Üp#Ñ8Jhzc; ¶BJĞ´näµİcïJPŒˆl/ëjÙ÷·DÃëpHµıEd¥ynÕ¨IÌCw`´‹%n}öèè„Ş8.ôÂ >&ZÌ9
NH³sô¡V|7tœdA7Y™Ã˜dÒ¯µËÃQAc€›²›£â½T°Èv2ê»ç5k.Â[EÕÚ^€éóöˆÛ!M‰±»Áú¾½¶:„àK/«ÂÀwÁàŞ}ï±„[ë0–ı!5ÄÒ!,ú#\Õ‡pÕa^#\9„y„Y0w³şÓaæ¦ı&5ÂÔ!Lú#D5ÂÄ!DıÂ!raR¥•”Cè)l;‡7tBØî{¿(ì"Ô-®AzRj×§­éÉª]K´:´¤'±v-1ëĞjÜÚµD®C«AzÒk×¿­yÃd;Ìaô´ZJ¶CŸ°ûµ¿DÈvìR‡ĞÓvh%é”>a;ökÿ•Âvám$
Û!„W´Ñ'l‡^¡ÎFœ°Bx4ëJÂváºleéşOQÖ¹¾ÓÎÁà¿ƒ¤ x+)JMU07`01 …Ää’Ìü¼b†‰‰»-e/W®í¾XYSÑªkÒ_	QQ_”–“_^Ì°×À_ßOÜtÛç»ßùîíÃqïãa M=«xVasÚFíg~Å~‰6êØÆ3Ø	©[§Nã¤mŠ=C:àâã¤œN6´õïî$Ò)3â´Ú{ûö½Õe4„Ö«ƒÖw^špHŒñN*•Æ.O¤Pf?	J*Ú
ó(¾Û¨T*LÃÇyÌ¡šM…æUÏ÷—¼>_i4` v:/ñÛ;Ø?Ã•˜…¡Pã:\|¨ÃUîl¦óŞÍ›NûÏw½÷˜Ïë_¼~ÓûÃå?]½ûùúı/n>~úõ·ß?ÿÁ†AÈGã‰ør/§*Š¿êÄ¤³ù_ÍƒÖaûeçû£W{î­ºÕTDe”ªÀˆH!Æ$’ü3›Ês¡˜WCfXş® ˆØĞívA¥RÖ0Ü¤ZÁˆÉ„c *7ˆB^Îê€LH®k³S6ÃJçãÚØLh)Æ¥EQ6r©®DŠÃpN?>æEª˜–ÒP~8¥¤öroÏa»;F`j_¨Ï®G´L˜îz¾F¼~p§›{#Å«¾]¡	>œaKj˜K¡RWšï3!)ù˜I ¬,0\'åçO¡ù;²×…Î	>ñD@ÆåÌ„kŒ¾jNq	H>2uH¢TY‚x´NcÃC|*£¾šQüj¶1Í“
f-Š% XÓÀ<ÛRj—m”ÁºhÏº-{­âÔäíÒ<–,àÕÆàVßªî]eéyµ:!×|=pG!ìä²A"¦±£9$SYZ§›<Aq§,…ˆ%‚ô“Å¡@SIÈwµ`3CJéì¶uÕCükxR#‚ÿ›p¨÷V^/ í˜¬ÁÎÑ“K‹H§İı8M&Ub>³38è` 4gı>
‹tµ!´%Ìf+İ·â°’I°^·İé)ànÿ”äíè,ë{!­×é4j/1‘·™òQ/°Ôì’ñ&°@£„É÷ÊY+ûYrV‹^Z-ù	8Î‘u˜dÄY"ny¢K­RĞÆ­0lËVÈÖÒN¶A™„Oø8êiÍæUõ°ìEô®sµìÅhø…´ÛØE£›¹Ä—†@ÎtI°WgG)É iaØÜÎU.Ó7lµğŒ›°çìgæ4iÑ0äÜ6ôn../—†›ÿ¿lt¸İF€SÇô hõ™è=ì£·Iw¹òÖ#³n~;2óæÆÀBƒEÄÛ!¶=p°¡Å!¸æ1l”³×aÉY9Ë
[¯m•…Lkl­r°!n•rØjı+Æ°ˆW<±83`Aay‹¢¿™{¶†á€Û^W§í¨/Ï
‹ó ìİ5œÛv;ÌlÿUiæ°È(ÙHp,”G€H²c*É¡Í‚¯íğc™ˆ‡¾‰nğ©Æ~À¤¬Úp:w7p"\š6wx†C)N£0•Üç³8ÒøfÂ3Î$:{V=ÃÆÇs<Óù‘×[ÍfëxhOw8WH‹÷xR:_Ô’iÆ
b§sàq~±8=ĞİâPq¼¸,Gà EÀfÈKvi³	H‰×†aå	æ¿G×L>xuU[kÛ0Şs…ÈCYa–ã´[K)%…Á¬l£°uÈ¶bŸF–4Ivšş÷I¾$¡}²t.ßùÎEÇ¹P9ÉÎ?\¼ùwDÈL²†Ï.ÉìÁ&[ÖˆÙ;/ì¸± ¤—ŸÑŒÎ£´ä¶0 ]¯ùqsû…dtA43–ÂdIğLÀ7ÑeÍ·eJ‹H¿¡Ç xÁo¾^¿Öèø;Ğb­«•ñ¬î+¡C~2(ª#W%7]kie YVAÕ\G…’Î@Ş:ev¨Ü¾¶|KîvPàÑÁ²áMÎ]ÙU¦º&okçôešn6ê¨ä.=xßcbK¾µO$¹êÂui
,T’š¶°ˆP«ÛÜ3Ku°Qn™qèşÉp¹âB«&0Ÿ(ØÉiäS)—Ö¬,Í…ª¬VÎcŸÌÆ’	(¸´¡Ã·Ÿ¿Çj®•¬ÅÖ—Rª’,İëÿ
ß)È’?Ò;d, O‡sr<—`]:ÅFğS†½ğ1¢wé¯õÏ¡½*[¨Ò4@FMzÆµ2Î3ëQéxÄĞx­Ïéÿ@Äğ¿-˜>Ì˜Y h M5+Ö¬âH/¾‚ÉH9>ˆBd`À­?:”ÉqäR7Ä´’íñ1iTQ³Á¨Pøğ0¬OáĞPn‹hLĞË_|#Iø k×¿_L¡äz»Ml«½oš· Ê?Şt§¹U:û»‹*ô,IJdÉj µñxfÊ(!ZM’b%8œrÕN4ìÛ\€­¿Jç±¯ĞÀc¬u+õºò9íÏÈg¬äº°!^5*¹æ8Ï²€0âı 1S…mäñïtN³i.KŞ}|Ñi³Jµh+	¾¼FIœU‘#H\œØKÿæ°oV‰.4û>Ã%;Y3i!€Ìé)ñ1rä\ãVX÷3z6¨
ÄÃmhâr¼O³ÓIG18íqZ1ë’¢æÅ x11:¼Ã¤‰ë3¼ ‹‰Nd°Í0ödëÓó=Å_É@8*’¾p¡Z‰-îË7ßß·vøsÂÿ‹§àóY˜¶Æ½ÙWN/° ~tş ÊxÅV[SÛFî³Åá¡‘„mYr2˜¸&™NûHZCÖÒÚŞV–œÕŠ˜iøï9g/º€`˜< í¹çºÊŠ¼Æ?yUÉ¡TR$Ê;n˜„¤ØíŠ ù—JHî{a81^p¦Y>İî9À=…Ä0XWy¢ªåïüğ¾H¹Ÿğß P£ªd¾^G“cˆàxï€äW¯ÀOè$"éIA ß¾¡˜ı!±71ÒÎ{ÅŞÌô[¿ØŒÄX¯ØŒÄÖZìlp×ñş"Q?àı[Ô÷¶Wßü€¾®’—EvÃÿb»ì\ñ—~Ê3H‹5è/X,WY8ğ×,+9f	€’½cL#É…Ï7j;²x‹<åDŠÜÃ–•ÄF¨µGH¶ZY<Bu=†’­µ±ÔZ¯4ÿd¥Øäh$‰=õÆ¦Ü×Ğ3Ñ€~Ñn.‡C§ ÓÕjTéPH»	f±6ÒvRÉ
Á kœl,hjZ1ì’éÈü=±ãYïÚ_Õöj9Í…|„èp¨ƒ'¹u!Á?3Ïğ2a?†C5±5~5qÓ{×ğ5NŠ\‰ÜÅÓâ8"d#zµé¯ùm7Ú‚Ğ*ñW;Ï:„µá°R[Kë5ÎâÂ¼<€æĞBh”¾6GÍ„Ò-l™¤=W¦dœ@ÿ/JEJ'/’„/’ms×Nq>?$|¯ 
¨ÌpÃ²
×Ø¶¨²òBáFcRÁW¡¶ğùú3e{ÈP³tÓŠÏhÇşV¼¯¹Û†DÅ2s£ÿQi=ÒO×/z1×ôÛ\[êñ‡á_šÀ·ì†Cjf4ËÓ6?Œ£FckâöBc}2fÛ+CÅÛ¡JTÿ¢cRcVÌHO|ÜñQ½54K¨GÀÅÚ÷ÈšQãØA§Ã0J¾ÏXÂıÉõd3N[":?ši™%ÓÎÍc«¥Ë8Ç±™e]ãe&Ğt¬mÚÙÜ´nB+eo]mQ3¹êˆ&õµÔ2¾24Z&zÚ”p{&KËŞ¨3Ó`SëĞC%4vŸ©$=ª…ÆÒ3µœ4ùxJbq„œíj¥»cŠÕ?<Q&ıV‰¡ßÂ½,TA§f¨ŠK¼[óM˜°,ó­H` [šOøXíV\^Ñê³ı…eyág{D´Ì…Šò#ß0%nøß\µZíé®H«Œ‡ü°/¤¾ƒrşèö=Å6ó[¼ÄÂBnFÓ(šÎE®¼‘¾zÿÅÒƒW¢ŸLzt6ÙÓmîşiµ‘ë¶š7ÿŞcÙKŠ„)>Ç+ÛÂf4#¥ä¹škÓ +‘3y;§A‚3Î]æÂërŠ_ğŞzğ+Ş	+†€/5Àş4 ôÜK±Eˆwæ",Å2kğyî›<±&{Im¦<;gõ‰(›˜¨úœÇx°sì¥\SQ²UÆéã=ŒW¼.›-?°ÚÄê@ÄîBëî÷\¾ÇsÒ§ 	Ôgp¶ãE4Î)_³*S—ê6Ãğ¬wººJz;ÏZ){Ë`I·,xX\õ$m	xã‚‡‰¬éuôTFKì]œ¼øVÓ;!}†t|C:9<¸ÃVÿÃâ‚xeSËnÔ0e=_q+*ÅVg<Lêhº Zi¤"U°`1¶Nìtl§ªæ/Xòu|	×NBZØäqçŞs|œk›ÃbñæÕ‹—óÆ»y®Ì\š{0VÈIaPzX“ßå$ÉJŸÑeŸ©yØ=ÍÅÿ1{¾¾8Ãl²¯Vrs#”3¼’SÈËğ)láã»ÖÜÌòcVìdñM+X%F Ç§ôÌI.Î•–Ÿ˜‚DxlmBù6£Ì×Z’]™±-·í§ç×3¸Ú´[ºÂèá|` ‚¬"½Ív9Ñ2@ÎÅ…2#¦Ñz9ÁÑ¬´îŒ;B4f¦ DKau
€N 
ËcU<`]š‹¨HESåPd°¼ÚoYpª"©Kã"¬nü<B,JƒNâ48‚ìSİ¤ö2á¦>püv$›Á&£Ã°‘G×ÙO"J\ªOcu¢`µdÒ9ëÈíG®‘o%¤³@.ÀCb‡}Ûş–.¡v¶Ş3Ù¢îì{Sˆ¦Šv„J¥ƒt„Ü#)pç’tøf¥2bm„l	î)<°N™Õ
îÓ'…üVıÂ”iiîÂîÿ¥³~Áƒì–êæŸ ¹RkÅk"âÑÿKàø	4l±[‹‘DlV±Y¥æş˜ç×äòJÑ9¥H&Ñ|gQIn(VÔ]qŠç¼ØöØ‘Æ_yë*6dŒu[Ã„ğ)äIµš;/×&Î<Ò•¨:…Ş¯>œád–xĞXw;M»i}d0Ltòhƒì2jĞi¶	`K°NH}¯/Móà¹'^§ z.ù"bk{G²÷Ã¦
ğû×Ïxcÿ pGnÓxmUMÜDåì_QÒJ&k6p@+å°!›Á’!Y‰«{ìò¸wÚİVLv¤9¬¹pCäHá†ø[ûòxİö8b3î®×¯ªŞ+¯•YÓÙWg_~rB+kéŸ*ÙÓıİ[z¡9_	|™&¦„sôõsú”.‚7ğÒhzå­ğ¼ÙgÙ,T:8™7Ò:O½57\yZ©<	k‚®É·–™‚®L‡ıN:©78)u%{Åî<ËÎ
Z, º±Œ{iÖíN¬“ÔNÖ&Ë½I\µñXÇš´uŞë÷äQ®X,²‡ëUeeïAÍ2ÕÁF S¡–~|­cc,pƒãûEŒ½ÆM///\]ÒŞ„aYÔ‘4˜E10s&ØŠÉ4ämğmÈò<Ï²“zÿî·_b…S5®…ÛÒwf“e÷¾¡G¡ØóıİOïß½ı+H¥Ié§Å?~Å¢ÛÊ¾ç:Ë(½ğÁÑÔ!;àô°B'+Ñ4FÕ\ÓJ	M©j¹Ú*‰î¸½óÜÑ‡Ãèğáeµu³s§…Ô§2næF9‹.mĞ98³Î%6…kKb‚VìPİ¦aK…Vfã¨R´w¿®Íw"(¿,©B‘=X¿–¾%—úG¨c/jáV†¼R|ªÚJ-]K	6¬úD;?+5¿ÎˆHêóyÌÊôAá¢1*İ6h÷«ãÅ±Dã%Ñ ùÎTÎ8K]ómÑÕåÈy¯«|X»™§¹å«S¢ˆÊš;SìeR…èû’\g¶P8£EÃÅhÿXÛOÏ¤ÿ&¬b‚=4 vÈÂu
cVÛˆ}˜+ğï¿f–ıF0­1Ÿ;ØNØ§X¾õl5j‘,…oÈğä¡bWe×-|PW§ôc“£/0–l$XOŠIŠ»‹…Ñj?ºm³X‘ş‡¾å=Z‹É•b1xègœC¨ÑGâ?Z§ËšÏ×‹½è´JÁúû¯WSËÚTnyŒ˜§”1™ÚÊcÌDûNÛCèÀÆ-ÿÇğà‡~>8!ê?:AVÀLG‘çKŒ 4îFå;YlxPÖd‚¨òJl¹AUbXà éŸSÙa‡ ıòt|väôgÊ zx6¨~¿£Bœ ƒ4ËÊ2i<ÛHO•2š©õ¾wçË%VÚ°.0½–‘Ñn“KÌ¸ñ-R`?ëußÅ‘í…RY±\ãäÓçÇ2»6K4'64~N0†'›Ó6º1&9Æ/‚/)´I)7œBöôıÅÕå£FŞæ¬wğÿRÌ‚cxè1Yƒ 7û|'x…Ë;Â0 PæœÂˆ95ôœÀi5‰­|*ÊéÙYXŸô\·Çõt9ãh],ÈeG-˜Æ,Êb2Z4CZ–g/uû5Êr˜eÔÖ·'X›ém{Ìw½k›WÎ2í\N©"iDåõï‰r¥.uòé˜VŞ10¥>æqD—x]Q»NäP¥ÎWi¤mP`wX5;!QPÑ -œÄI,îK¾¦ƒ@âÿønVÛÚÇÇçÑ¸ØàôçùÁw.ß_Ş–x~EÒ8(çSjY«jQ@díÈ¹ªñ€¿¸û…Ì­²åzÃ*ımô^Ì¸…å$àÏÍşb‰+7Á\Wg#5kÒuàn:Ó]Šì(}ŠV†ğ2(™Ä0kø²Ø’slE5×ı:ÌT§Ğè\S 6™uC8±İşÕ’_ÂÅ¡àì“‡0¿~‚m™ç/çH!ù¢9*#‘HÂ·ä‹âc,~êÄá&ãÚ>£[©8·ç»’©{Gºi>—Šş™ğV6Åˆ”g³~å‘I3ı:Yq/A¦L{¬bà/sÿu“(gÎ(°©‚¸gmÙUÕâªbx‘I1E³®SpÙÀí²­\‚îEd› ­*­	eÃ·íÜ KQüŸï“:…à†¹ÿDú^á`‡ÙšÉŠÙìÇINıt˜ó¤”F´B«İ¨»,F‚ıdg}œ„>J¥8{%†c?ˆq§ÌÁŒ{!:Ùèœ
ÈâĞÃW‹Å/ö]ƒtşE§ğv“Än>¾ôû¾ï¸Êˆ„ÿ%î,JzÒîy‚×â¡´¸Y9kÜX/×—zË`%©V)b­ £¤*–‹TÎ;ºuİ~cöRc…³,F'ƒN9æp·;–ŞW¸::ó˜Ê¢ûnNüõÊ»ål'¸™3¶z3¦‚nÅa%XKjÙÅõ1W{”jÓ<ªnïÊV|Z+ÿ|¸\¡EƒÖE¨!}àòª..Se'&´Íû7ç¥U@/såVrl)äm¥”¯’ô¿äªY>`ä5hLÎê_!—tá¸?ıl
Ş4¹ë´ç»Ñ.NÂ²<ğ—H2ã_¨¡ÇUxÍW;sÛ8¾š¿bÓ˜”CS—Ë7QT¤p‘¹x®ˆ›ŒFDB.À  #£ÿ]¼HZÒMÊS#k±Ïo¿]À›VmàíÛ¿şü-ïcµ¨m¾È²ù57­ö¦†mZ{v¸i¹¼gÙ#ÓğåÃİ§ÛCÍ;+”„%hş­šy5çQœÏN÷ş©ã>]‹G¤–eÛ^ÖÎW­öhù'alaêß³$Ûó<g [sÓ·ƒ®Öh	àµV¤´®¶Jß²zW$EİkÍ¥¥,¼ïEòïeÃ.yrXayvç\BrÆ]§ù£P½!%Ä_ÎUt ¶PÄ#R¬,{€år	£dœìê
ˆŸ‰ÅW!›'¼l³Ç2Ä‰‘“Rn)Ô¨öÓ°G÷}¤ÆPnğU´Z#d£:È(¨jn{-ƒş";éëëŠù5´Ø^SU\ÏÏ4–:í?¦f-ÓïàùX2ä—5ŸJ÷¬ë„|˜
·¬m7¬ş:•:@P”<‡|œÕzˆƒÒi*O±¦â!Új|{,¢°£üPÂˆg‰¥µj[^;’4‘JD$ú]¥&z\|K¼tåˆëªëÍÎ;ˆ½œhæ1ÅüTõ¼ÅQ	M|û0Hdê8ù›“•O€ÊG à`Bá@óß#
ø7ÓıÔÄô8ÁûTøız	o",Éfå<c?ÂÙK¡‰¾—YùÙm˜¢á[!í!˜Ø0?X.›±Šg¶7­:­¬r(yE¬(uõÔ4-1±ïZQ‹¸ÆüNâ‡‰s§şÉ!Æ2¤¾ÚÂıˆ%ó9„lBDÊg†æ Ñ¥gÆàÊÏvè9Eù 5{ª„qß£˜³ˆùIP˜7¥ûú£çõ4*‚‘¨•¬™{vëe”Â\]]Î¨ŠØÍàÇ¸”7öÍƒ9»\ÁsÊîœ­g6ôé‚n>ó´O££="ÿ¬NôıĞ¼ğ–*Iéş'®Cåc€ı\ÛVß7ùô/ò	ÒL‚Ù©¾m`Ã9Æ•ˆ1Ö%äğÚÕãl³pÃ¨‹Ås*ñC~ U,&@z „%‘ :½Æ¥Ãv"|^¹5w2‘­ —Kíx-¶‚7îœ%zÍ8(|)x“à£ÇUª6ÿâfvÍ2@¬T*y3:«|¡?´”nÕ*ÖüŠè<¼Â·@î/üR¾ßqÍAÄØŞĞ¹D °R<‹û„nVª)ö£‚ñ—¶j±4:7}½5£_©,JºNiË›‹õ¼¸„."<J×™üj¦wîı‚WŒšIP²}"êQIØ-fyF"ê~—Eby³öåÿ/wR%“Gî?~U­9³¼xyéøÒÃŸ8°ÄG]]I€{rµÅÅÅnî‚mD7‹·M‚©mO‡7{“˜†ÄÑ3Ş‡À…ûy	‘£ñípù5‘ÏÓ4âÓ0ı`LÍbzex¾ î&†EMß¸E³½jú–ÓfÅ	1Å7b‘ı¾fHvx}“É®£F E³æ+joåA1HİQ3ã‡Ÿ1Ø`ãC1™ÉPğ×§;É²•»<Ò‘Îæ¦}ÛV@‰c%G¼(Â4Ë…r2ÂŸb$eÏâ¡œ1ƒ5Ä#îàašB$dbŠs^N$˜aâLFˆã…8e1ÄrÆ%˜ŠgRö#PÆ
7ÀÄcÖÆøYIYIw-&q1Æ¤ú1Oxœ>º~ÄC³})çä#íÛ¿ D¼À³¬Ä`ÇpCı¤?ó	U{NÀ·ÿ´ÿ«C1Uøó×TÃÚÁÉ:óŞ:*—À7şá À2™©ª(ª¦(ê}öš×]5_ƒ±‡æYÊFQ”ZŠ<Å~¬Í>o|¿ÎrÃ?ÍæäJú¢ÀÉ-oÛçEVY™M»íóP!ë³§¹ Uµ‰v¿>Ë6„ç&ìÍ™Ö¦grŠÅÍ‹³t,(P…,#škÚÍ‡ûÌMs]Ã‘µ‚hO«:<«!N/êHsÄª×s`³Ó½ö
0šQé†Ó[şz;Ağ¥Óî!ëâ[î”>}G[´K-¬…g
^ñc×š«;ï'Gõš‰W1°Â5¶xî‹Ñ–eèHtÓ¢!¨Ld)[¥éËVTJ¼Ã’k$B}o¤hmèşjÈWéæÉµ]â•é‚‹š•÷½—›×ğí–Òê`kÕ@o,·³ßŠC8NÀ¬êÛ‹„Bó @Ÿ¬1ÌÉ^ËõòØÙö¶i‚¬§}ø IÚ¬·e:÷$JHJ½{Y'DöáÜîìsj¬u»P tÃ—R,‚%İ[Ù¡}““.¼.åE@â×Ñ_½Ê5ÿ]éæÓe¼×ÀÔ—Ê)¼¶>®ìmq(Ğª‚=Â:mÂµ/û§‹ÃãNè»¸lİ;—›ö'NVúY2çã}©Nê®‰èÀ¤¯;
pÌÈ¶Ÿ»ø‹—â5ã¯—"nËü×­zÙæğÔe‰{Ú3.GÖ–²Ò¬ó”õé¼¾_ç^‰ˆš´záb§(˜»&)¬0†›K¯a`M5=Oô»Cpøòù8èöÀßŒ;ëş˜şä!.Ó?&ræõxPl¿­JDïÃô¨¨?aõß?‚
†,&ø†¢mö7ËôYaxì½[S\I–.8¯§~Å–*«"tM2•*„ “N„Tuv5Pd )JAE)©¥<ÖOgl^ÍË˜Í¼ŒÍ/«_2ß·.~Ù{G Ê,«îcM¦ bo¿,_w_¾ÜığtpX,.Ş½sïËÿí7·oİ(ş2šÿĞ=;-îv;Å›ñø|´|ûöëŞøÍÅaçhpv»?8.º·½ÜN{GeTÏ6vŠ[·Ó>¹è{ƒ~Ñ~¶»§sÅI÷h<~˜)>ş¦(ÆÎËÁIQ¾?Ç£âÑ£GEkpø—òhÜ*~ÿ{}68¾8-‹|{Ñ?.Ozıò¸U<ö¶ÚV¦Xmj1mÒ¡FõE§{vŒôK{·eM´öÙšÁ]<r`t;oz£€’—Ë…~)>}*FåéIh×Zìüe$¨}T|üyfæ«ßüÜ£Í¹"AYÖGŒH‡=`æ«ß .RÑmP³ÿº=ºÌ)f‹bX/†@¼áØŞ*B"gŸW•—ı‹ÓSÀS?ÿ¦ÒÑsiß_¥£å‰éõm“:V†Ãî‡ö¨üëEÙ?*½“ŞIÑ–7Ş¨RbÆGêu{Q”§À«%òFC•İ}Af@Ö.H¥xSCAù~\öÛãîğu9+Fƒ‹añ§î°è;ßÏ§eÿõøÍ\ñ¶üà¥¾/?Œ¬/•W-¬)§);¨=ò‚Vt1$vƒ‚Ş>k‹l¡£İ¥Ğ_8ş}öQ±èh%¢ĞMV}WZ—áó5„T†»‹rû¡ |SDK,vác;­Ô€Ãay^vÇmòrÿõ\q4¸è¢pX.NÇè¨ÕÂÛG§¥]F.ğrá+}‡ÑIş5œµ…‡Úœªe ß”¯»ãŞOå¿–ÃA»qvXR.}*r³ \¾%å:[kß®ìlüóÚÁÆÖúÆÖÆÎŸ¤Ìbq»°†bÂ8.Å‹Db!¾eI-£ŒáE¤Œ>ò"&>¡ŠØ#/¡èPBy|Ø(($˜ğ‚*YKúHèE€a Î ú¡á0‚ÿÆ³‡v°8§¯t|ãc”ü²ÂÊ+ÄËyh$¥—t’@m…ÂeXJòÁ"zÿYà½}»øÓÊ³Í¢!aG§İÑ¨#ön4î½üTONïÄìAGŒhÖF·Ş½÷ğË‡wsU	V=ë×ØlÓQyÎ²äõ³sX?ç!¢èİ›rXCdö³r4ê¾æ·P§3,»# :ºÕ¾è¿íŞõ1j>›Q;Pˆ»kœu‡oƒ~³&M‚¨xò‚~÷,èØÂ ¸´zıâf«˜M a»RO[7ôN65YÒa°b›µª½œÂ`ã1Ôê.7•8œ^œõC™|p†7‘
ø£~ïü¼MG°×ßë7ŒÀjdĞ›0;ş#ş›Ul°`Å’OÖœª_,¶• Ÿ`¼^`§í‹ó’2Ğ‡î¹ Ï#/„):GİÓS±÷0´ò˜¶_±f¢¥€qE–, ƒ7ìŒÃ?éÓÀQ)G²½HïànôN/éd€Ù‹ñ°{óÙ7yˆåHÉD>ˆsxå6+ì°¼3¶õÍppVİşq±'ñŸ¶¥vQL¨kŞ&Á™8" €šsÅ­4¿¾>Wl¬‹³ÒÅv÷¤;ì÷g;Å:p{È1Ğ`À5*‡#ëZ×ñ=*ÚıòÓ™éèSŠY`l§»à­ôÆÅ	†¤uĞbF¥/;çÃÁx@gtP%Ö9Æ¥¡+¼—1M¬ı8-UÊ]¦uİ¶Å°¢fğıY»¢ÜRÖ£p
ç×¹Å«’¹¨0ñ‡ê+ˆc#¤B(xJ…	P¤[Œ`øáÎS)Ì“Gçp÷ñÌû~S'4€GõMl^œœ”Cø;øÂıâÇµşñ\q>õTÃ²	<Õfœ	è›²{º|4îöN+Pı»îé‰VÇ»gİñ›”>ÔxÖ2¬øÒL1_,&ŠÕÀã cñ›tˆŠ OÑét\—IÅGaPh/kŠ‰ƒq'¸FåŠ¦!µ@pc{…XÅèC³æwMK¹œBó-ëPg%`gÄ¢@™Sq¦îüJ¤}{o|aëoÿã¶h0%ş ¤åWŠé+T¿ÃòTœ·P\1%œ[ëóî±À|RàÛ)eûÃ“!ˆô]a¨íßÉêW*­>hèå¬û¶ÜVsf¾+âŒ¼+û
ÄçÚÃŸC9Ù¬IFBbß`CÅl°ù,”ğå«ßÀ.µGèôÁ—Z™È¦Œ^Œ‚ş˜/óªê4•ÀôbbKäÎÑ“úÅ¦óµ–ÒŠ;Ó[Z9ÃÄN€IZ²Š%C	%_<®Û{ÃÇ{ıO{ÃO{·_k?|ÉjÂœ‰í:TuÇwyc$V¯wô&¶p‚)Íñ&ŠnĞÄ¼+‰wozĞzm¥ñbXvÊ÷å‘0ƒÓpÆ™!Èá¨s~1z£•:233“˜h‹z0¢t³»°ï¼iãWßùşš€Òöéf¥CøºÀÌæ£	 ' éè"¶¬ÈP­¼’ÍÉ¯i]i6}ğ(A}lÌ±§tK¦†=5 íekëî³^_ñË—@Šó+¿„7‚ñióL°¡í#öABÕĞ‰·dÃoûC›YW€l¶¸ã^”v¬°ˆ¹y*xMOÅofg#ş«XœgEè®†¹~ÊhÖmg ]¢.\£¦l´›’-ïç…ÈùSŠä<<p*Ii­} ¨ù^ôögbŸ²mùC˜ A5;• ÔÊAÅ'Ü@ÔqN’Ğ[™ÁI…Šs­®!Šr8‹C|léü"Æ‚f¡ı)Ö'QGVªb3¬ŠÕÙDASäÊ˜†
Ì¾>WÄÃ,\Æ<¬eNC¤#_ï8n¡”H°ÖŸ‰m¢ØôÖtYQ¾DTfAïoTÉÏ&ÛÉAG—IN^$£15yáZ’Ãö®)9¿Œ]~¹è(Ó4ÅâO°ÿÅmx‚-‘z…Óøt‚f+8UÂ'|»ó§k«Ï·¶w^¾Zİyşòàù‹|…DîŠ<·ŞB1´TÏ´ÎlìùHÒàô§Ò¿†™˜?èafÖETúù‰?9–Ç½#Lòü\D´w©ö`¡ˆe‡.:Ş8ÏFü²rÚëÊQ€ÂÁÀoˆsÀƒ­çO×¾ßØzšd„8BwèzèÚ¿ŸuÏÏ1¯Šm…IgspF¤{ëŠñÜÍLfk?j|Ìı†ó¾Nù«¯f3ëZ÷èM²”!ƒóöé Ü®<Üo(İ%ÒÒ+ÓöïnËì¶­$M¬)/±ÙŸƒğOMÆòò<`dóv„rÆ]Ì<LWyÿöìãŸà‰¬¤c÷Š#Êãl´â“ØT°ç'm­Â%±ù,^?F`å]ÁèE˜}·[¯,6¨ hìP‰ŞDTÁÅ1Ã9²Ş%“åënâÃ˜µÙLV¹:*p‚O‘âR>`^µóüéóåbåø³×œÑÃu,Ş”Go;RD‚,)6ÁX¶}ÿŠ³·ey^†½×½~÷Ôß¶#p~u.DE»}¬!Ã´ÛÈ
ÌéJ¤I?!ş Øİ5O^ŞRÎÓ·Å®*€ıøÊ¦VÊFRÕ4	Øm¹ŠğÚ¨˜¨–£Ê²b~åW•°	i2hi4i2¼hi£Y“Çİq7i–_óf£Nb»I³ñ…¶[dP^UˆÂ‹‘Î*YĞğcj®Z5ê¿0˜IU©S€CU¾@Ïu€Sµ™5}A˜ëUEÏ°ü• I€“SªJh4¡\ª™Y·I}ŞJÇA¸ Qò+ê<|àÙY+J¥~ªÌ›«(3”'_]ì\ëôÊc‰½]&ïœ°‰^¤°P¦jF‘ÿÛ·J„oúãùãŞ¨{ˆÉ,<ôùÓ²…~ùIÂv†¢ÍŞK}Ğgİ¹BÚG‘ˆÌÄ„UX-¹Ë‚Mfáèb8„e%D®œÕ@Bn FÁ%Qµaâ&¹õhĞËàâŸzƒ‹ÛD Ñ¾Ic±µ}ş’E;T<TÍ	Hòì÷¿·•Õ²:B˜j%y8­–2nµš<%„Iw	¼_ˆr2Ò	¹ZÉ3»^—&5“Vêßt›â˜ïÔ'
Ğ¨ş¬{Ş¾}3šÑxÄøæ­ÛËŒìÊ	Š(õd–aWãü«â¶_}çMõ1äV"ÿÕç‚,<Lp…¶ÅwZ.v_°Ä>«oB¯Õ±ßİı¤Ç6Ğ4§kñ˜åI€Û¬i‚·ÓSÁÉY’®áèŠÑ¸N ¸â+°´<ß“'ÉJû.â÷à	UÊ¶ÜVSáÊJ‹×MzĞ òŠ²ÂnÒföšp(9ó™;¦Ó9“Ù4¹grŸŸyÖÂô,†PË’‚¤c]Ñ1køPª\ÆÉÛ¢³àF‡É‰âºVı“´P”
o".Yq -P¾Ş€±)%¥wvh9Ö0sIÂHJÇÑ®DPÁm:Q'¬xş—Âå ËkcZoXy(6çÆËxƒ}å¹8IQÇ’.
½«]eqNş,ÍÉÒÇşL¥oŒ5€ÇS«d\€Ä®%Çh\Ç¥ä;M,å]Ï$ØÊ>¡=šÆi7ÊM(€iŠ;§[¥· |øG®æøˆå]È*í…ñ§â”RÖª Ú5g£’ñSá’XŒŞ.N‹C,;PsÀÿj!¶cã/ï7D‰‘pJ:=iaFPÏÁ³@£ÏTL­TÕg dô/’‰1uC´í‹5y‰\L·a¾µü*Z9Î¥Âìi„°I—9eÌËÌ±œÕaÄıA>y—Í¹æP°;§ƒîñ÷Ğïdòê#É‹´PÀ¥€ïHÂ	¦S
V“&9ÃjyÀºØoÌ©Ó)6\!é,ˆ‹¶x?ºÀzq¢Ù`½÷âœ	åñ%£ªµF\' K…«BûŒ¡N	G˜Zö‹AÿôÙ‘ƒ?ÜvÊ ¤}3\°'AqçD|ÿGæ§lL™–/5ÖM–+s«]¾ E$a#( Î¸v÷g\Ey9TgßVÛ±j‡ym\éÜ¼ËãÀ…a&&ÓíÊÅ;wİ`½{õµh>ÓYJ¨î½O¨N™…ƒ›ÌéîVúp%¿lÈ¤1FÜ½ó84‰huñàg$’éÄGf±¿Ğ¥0yƒˆG¢Øµ[àñe&wÃ×sKKËX¢@Ô]õ6ıBäu˜†Pÿ:Ä–£/Ònˆ5„hs¥{(ĞP€hB"ğ”½ò¯5xÌ¹·på/€ÎQ"øê—@„UˆğH¦¿EˆV:AÃ¨{Â€CwJÛ¶È9fÍ4?Èçó ÌGü#à“÷œdöƒ>1tı'pÁ œ–R^œ³HFcB®€D©tI:b>øHç|m./bÄx6i†„ø­õß‘	ğé“Ny/BÉ»â•Å¢ì«HŸ’Ú·úèÕæf‹Iñœ5àWe`’0NWÀ"Û¯WCê)·İ
+Ö­†>¨	•‰6w	±H•‘2Q3Ê0[5#QËjƒÓ˜Ëëƒ¤´¢7}¢eqb+7èc5â4j =‹–¡¾"uÂé¬åa×Idpàeç@Øõé¶H¹¤ÂB9§Óz aÒ
åÙùøÃ2¡ŒTOãªÔ>üÑiœ†I@XN‚
ÃâÒÇAy2œ–İşeÅ¢‚Âæ×–ªPæ*ü¾Óğèå«5ˆÀ$¹ºW‘+®Òê:3<«ÏV6·Ùn`ófÑjÂŒ1Q”eˆ`DˆR$bícšğ–Ã«ÑyÏ²jŞJÈ¤K÷šPëuD)íš`[ƒû±7ï¤¿D°YäÚ‚m½M—í¬P&ŞÙ›	œ
¬;È¹üqÑRA$”?Ál”ä)-a1u­Eë¿.”´Ô(âÓZfgKÂŸhIXä3D¹7ú®|¿ŠäâöQÅ´Ûïï, ¹€à#3kP &«}ÄÏxõ%^}É¸dMÀPñî"Ş®4V¼{¯Ö'U¼ÏŠİÆŠ÷YñD*6qıó£ñgãZ}0±Õ§åÑgµ±S‡51bıqùºşZêÓm‚!.”Ç›îè)V¹GP3×ci¦ŞI9™ÁE	Ş0½½””;ê®°½Iê ¸3ê½î‡ú,F—f^ô¦›…ƒóÑ`‰ÍÎ
 ™óÂ
^m!©†¬Â©CDÚt—M‘%ÚùÓÔ—½B{‡\/EMş>´¿‹÷:vHH$2§u­-Ãøì¬áŠ]K€6_¡}I³ÑrSlğMÂ@€‡ƒLï8¾¤Œ1dƒ&€–o‹¨aFÇ()Ê¯”RŒ¹cÀBV7…ğ¶Ä°è–ĞÅö¾a@.«ğGûÃØ¨ûÈÔ£7İ!e}e¬¬Å æ?
wƒFÜ=ü„:W·ÿPÔ‘‹Li¸0/.øÖ)¤t*[âÕOİÓìËÑxª„×¸ÿ¡x‡]ØÅ?ª² Rqæ¥¨åÄÜ_I¤Ù†xqAOÎËEY”ooä&g"f]ñÌD[]lHÔ}ïˆ­mEÆ›îOeq¬v1mÄ1$£ c»˜‚^‚.Ã w/7{ËM†N¦NÑ‰}À°3À-Ö?2‹%…B@‹´£öKWÿ½-
·P÷IÈ6	Sr„~R¹ß‰aôÁN6l)Í
ƒ—ùëÊ9º‘cQf|_é˜$6luiZi· ¦F3ÔÜ]Äb#+ÓYeïR{‡£Ğ.lÉÒÌvè8àõf¨Ş¯ØÌâı)íPÕ]±‡ÖŒ!eZ­9lk“Ò9ÏõFÎhÁ»ÊXSíç²È,7úÆ¯lv¤É%-Ÿévå}^#3)WX¬¤øy(tŸo ŠÉm0ùa«DˆÉû=l™¢D‰kO¯Ó§WY¡lz•½i˜^"%mhÑ‡$ü t'Q|cñ"¢­…C¦)ãI˜‰¶±1s›ùÆ7ÆšR°ÑŸ _ˆÔI}ZEµÓ‡Öiã«¦^qjGïÌûÒkY2ByGs.&#ÆGoÊ÷İĞÍ”."2ß×	á¯uZ…·‹@0ä^¡d:j¨y‚iZ:MŞŠqµŒ-vérCõ°»xßg!w8ãX×ä!&¡DÀ	½ÇB%%2|¡Ä}”À3”Pğñ;	¹KÙúæó•ƒ+;;k/·LÜ^–¯±ÈĞ–:p–:÷Ê»P†{²OBÇ9›îˆmı¹ıxyw~vÿ1ÿ.Ì¹Ï_û·fğ}o¯ãßäu¹¶/E¥ÜìÌc_ÃE%vÑYò>%é¹ŒûÁî•å™.ÊöY¾”‚­O¡‹Yö?­ƒ^ÿÄê¨ˆxøiƒÿ¶ÖgRhú]ÏI(‡ïŸ¶º[Ÿ¶V¶ff¾ ½D[!“	í:VY‘n Ú§{´üÂÃAİ§sK–ºQ'HgŒC¬¹$<„ıñ¢‡ıÉod£õ@VL‘¹„¤^§NQó^È5¨øbˆCt±iÎÅ9 +a‚^c¡àôy¸P\¾Xğïò—Åô±ÁÀ­)wÈÌŠ$îXn©®àÕñ¼ uÌÜ«3`~fÌöw¿ÉÀ´J¼q1ö\ss×&LÓÃU‚Vğ}b¤Ekv¾<*¯0#z&×<m0*A[³ã‚&Oêk«ŸçÉµ§Ï·7òã?–ıUídÃJ’]c°ÑáÁ¡ ız§`gÅ‹:ÌÎ„ÒBJİ	4Ù^İXÛÚÙXßX=øacç»ç¯v>ßzoÿ9òòvUT`M¹·«/ÚÌ×@]¦á;rÙ
Ú¸Hxİ­à(ÁC‡ßˆ·Imò,5GÇçâ‰.a>Ü±ó‚!˜‰ıë¡ Ä=Lò½`ˆUf»± Å"ãéAéIwTGïÃFîàgŒ‡Lu¥ñ@ÍÕ
6:1œ4Š<ı
ã™)¹Ê€æ;WJNÒt¯40›3ÆüBgÁğ4ÃŠ:øÜá	sğÚ¶İL¦Æ©È'9¼è!¿itÔƒ@àé‘ï…à¬sp1.clV¿WÎ/.,¨Ÿ ®›€%WhˆõoH	Ë¡XGÊáôŠŞû2u1“¡;¡€Øš¥WÍZ¤ÂŸ X[ØbERBÈ"$‰SY¤Òìül½]q^¡
¹:­`Ø=X"v:¯à4wkÁÓ	À¥Z9¡‰±¸†>)÷AÊ\{j!˜>±HŠdÓŠäy2©ƒ¶ÔÖ¯°XÉ‘ş…çş0Ø­yDùQ°é).1c@–ªİåÒ•†Oá1RŸ.eâLq?ş#éR”6ûæéÊÎÚÁËµo×şå…!=u/á?¯Q\Gıg,üÌÒkáìıCÙÕ};­ù¤RZ4ÔÁä†•–öL6Çoà¼¸X<|b­;ûpx>P\Â v6­mï¬<{ñ÷ÉãÆ¡\6’iµl$]‹şñÎxÿÓn±·7ŞŸmèKzB–¤b+Aqs†ã»ût•f9©ÕĞàĞáÜaÅ—Ú×U«İßÇT + ê™rHtã…nÍp>QıÑŞìãØœš…´llÀ… áVû_?µé®Ì$€s¸Zñá~1ş·b÷Kş9'mwqA¾Ä!ˆü™Ç€¤Â]ÂÀà`´bÃMÓ‡NwÏÎ¯7…à°é#UÓ!è¸kD¹aúáŞxRµÊæW¬oZ>øı¹eÈrRšH9“ã#æDÈ±GR;G1œîÂaNIœ=e…N1ÓH$—§œiI†’Äÿí€t’^Ÿ“ó*¥G‚5uBˆZ+{£HÌ*OÁ[âÁV›ˆ™ªzÌ[ë©NÄ$ÅGOÍ²™¦LÜ¤:´µiÂ¨İRU1¨Y…¥-h((M^,íëñCT”pMô5x‡¨Šë k ARé["Npv|ïİ»hé#›é¢*ÁyšY¬Í_W;«mêñ”ÄšJb½hÈ‡jº¥Øú¢Ø: ØMåZ€"µh˜P‰Ÿ¼¹ço”’7÷³ê p€Ò¤6ò¿´™Â1<–ƒlÈCää¤/íóæ¯QDquÖ;=íÍk÷~¸XÒ:ÏÁs“˜ÑV½9ÂëŸµGsCÜM×]`£ª>R= ƒú2±IQ‚#èÀ0Ğ ÒÒ÷h>™ 	¹‹eÛÛºUÜ_€•g
>ÁlïÕâÈ%’ª8
²H­lëì3¡ƒy©š¡„Ø.gÃË4ÙTè@¤ôK•cª5êÙ²ƒSä…KY-S’,Dør™9zQGê|¢¸}ËfÇqœµ&ÛÏm_»PFZ§V»A1LrxC¹k;½Zuƒ¶_æR=’Pqn!½×J1ß]ôüdY´ƒVhà$#	„ÊDœ’¡Éz>+q¨nf9#Ò5şÖúúë<›Ê<CÌÛ¸Yg,smD	tq µ°ıÁüaoü®7*ãfXÈónq‘Ñû÷ğï~“o¾ÁœEsŒsÅêË¹bs]Â»şÉÊöÚı»ÏVèj·V¬>][ÿö»ú~óÙÖó|¹½óêŸø—?ık÷ğSˆ×ozy{zÖœÿu8_üôîı‡[X\ºs÷Şı¿œ½ıç_1Í%×7¡û‰,udøÑ¸4ØIPi€MNÇ8ê£ÆF@*éÁo4•ÉGÌÃC3yjV}œ¨Š­38+çğÿ¨ïª;åxc¤œàÃ×lX>¦¹'„M£ƒêƒxj&³ ß™×½ho{ç@ùíÍu`„?®4òˆ”æ¦Ø{À¸Î#1ƒºÇQ²h#Ë®¨ÇÏ“6ä¦Ü•²fA°	÷3Õ†æ7°;O¶ãt1ıêö±;…	N§å	jr¶4NBÀæ•Ápxq=+Ò¢uÒ¶vW`í‡ªk©UÅ”ÉpÁIJ!"Øcß>QÄÀúçaX.8ÄYWœw÷†{ıGû¶î<G·aXád\E,ĞÆÜ<»A¢½Äª-1dğÜRVšw&IŞåÌÁÄdÎ"ØW¦Âæqá)ÙíI~ºë®¢³}_‰·|Š«²¹ƒL„Ğ»Š_É $[w"ll‘#ÚH‘QñÍ7X¹AQd®¯C;¡$H7µ ´X)aÎB¡£Ã>)ôõ×zı”‰ƒ"™<åŒİ§gçr¾¢ÚFg`Uø1t±í‰éŒEÈrJİ8:åêhH‹Õ‘DÊ3xÑĞGã¦´… ® ³±Öp³b;DÁ©yCŠh“aº5¯Ÿy¨'Ú+(ÑHÔvbNM'{”jm
tä¹Ò‚@QĞAØ£d©<š+¢»ÓÓ—¹@Öµw	ş[$Kjqˆ%ÿn±‚åF¢.;:îÏ¾;—	_Í
#°‰lìtgİ23Éó†ZY£ôUÊšTO)85)3Q\¥d`ùdtÉ³H¡Ëdô$¹~Çc1…Í©¤(£œ¯‚™«ãeBÉ:Vò‚uœT„I`¯ÉQvİµyGş&s—„Â¬Ó>oñş]'J\
ØNvçµ—5¯Çe 8ªl^“™ZQxêî 6W¨Óiw½eU_š:¤NFò†¢Şªî¬>ÀªÓBô‡RèÚ^¸Â¯ú)87•¹JZ&‹Ò§/Â¥2WÑ2-›¨P— iğù»>–Ş‘…2şğ4’ŸĞ7¢äeˆ{©êX_,Q	á§¡ª—™Nt~Ø,öêíŠº†E7°Uë¼ãÔø]Ùı$çİ‚9ü2úá»îˆŸ¥	¬M :kS;ªÆC’¾j‚2ZØüº˜<n‡hï”ìDxØy¨YÉ9å;…%Ò„u¼s_,i†Ëk¬4°©2ö>–¾ŒÓófd$6~€'¨pÑàè©`kôÜ%ÇExµúi7Œ$ÆnYÖnªÉÁÓtÕôS°"(k9¯gÅY*Ò>Ìl ñx©¤Œ¸°^€üË¹C'ïsuãÃ‘§ƒx2~Pã`k“<Õ°ÃX;‘ö„‹u9MŸP¤¦MòıÅĞŠÜ ++ ¾S–pM×&,d¤ê p¯FQşjÈ¹œ(Í/À¤£ÏçFéå©‹¾Í|ºØšRÍ¬.§2€	¬Æf.c‰ÿâ°iâÅ(W×bb ’‚ßÚddJ1Û8…ã ‚rÆ6˜I¦ˆĞê.ïG!—Ze÷ñÛ¾~mY¸ıÃÜ–bğ¿õ‰É©dûe¤ĞÚÁ"Éìrš&‘2Ÿ¡J„¬Óu‰©(“Üo€›Ğ Rò2ËvéÉ†…—iDÁ2:Ô°x(…ˆ‡Šˆî«voiõ}´M–ÑÌ°•ÛÏ2»­’Ş%Æü®°©Fæ³LMÓ-q5{FL`1àö@‰*sÀB$§F€íjf0Mç¨ğ…%‰ æf\–ü Ü H[l	Èõ#&Å÷
4 şYDÀ¿`ÀÚN°üÆ¤”Ç@Î!ã[çå~¬æğF‡sÂJW½©F#Zãx«ŒSwÖşeç yÏ?àb50|IR-g/‘ÑÈ—rAúòÉæóÕï¥ª].QÉªŠ»3oø»çÏ^ll}{°º¹ñ"ïÒßà¬i¼Jûó7ß¯­INÙ­=Ë×Æ‰Î[/^nlí¬<Ù\#³Ër0w÷Ş/,Ìã×Cü{‚«ø·†‹ë{ï¬ãÃÃ»øw¾\ß»X___“ßëHÙ»xú•/>Y_ßo?¾Á'«ú÷g>1—äÏy±O©Cæ§b5V¢:›[kO^®­|¿Ø‡÷ö.––Êï/÷ku\O7VWp÷v2Ğ¹½İ½ı½{?×+í¬|{ğİÊÖÓ5¨ÈUàÆ§ø·;ÿo{óû³7f¾¸İ«Ìú¯^nXgş'Ôßısì›éî¿c"JwşdÿãÒÏŸô3ÚşíW{·÷/ÿá÷öf÷¾˜;ØëÜøï{·Z{í½B¾?sKz&eƒç{ —ÇU6p<¿|‚Íği;½ÑÁÚóÍúÖö#ö¼_X¹}‹ëG\WÄ‚-ö¶Ë2Àû…§x¾ú’ÏƒrÀ¡Ñ¾Û@R×ö‹•Õµ)søN÷°ÖúwÕoã»rrÛ8u}:ìyóvø	ãÈ{ª„F›a¡±¡Ë’³g'ŞÓÒ*F>‡QW@ñ÷÷àıî”÷¤Ëşä÷Xÿã”÷¬ÿ3Ş×©Êµ£¨ÙNÄ]Pøêg"|4<šñ<Âr8ÏS`ÇaöW³Ù(3Å%Ş/¥;ı GvRÂ©Î€òr:CrVB]—ôo!(÷;]Ìá1Xu»b.I%V ÎËc`h³ìGúÒqâ=xä¾rááøÄ`É¦È
ŞCÁ‹¼àİ¦‚÷XğU^ğ¡4`ÖìHÊ§º9‹û¹sh]
NÁ˜f¯	Ş¶mAÁÀ*›¿87Á†?Ûûeä†“8˜™Ü‚-Ã>Ş­ì?¡``/ø`RÁ%À ÊI[|8¡àƒ»(HÀ¼Å/'\H5’¶9©èı5´ÙOÚ\™ĞæúñSRğÉ„‚‘ãA«
>à¸‡I‹O'¼Oî­-.Nêº¢e1rü×Hœ%ö}3ö½´4©à:
Şö‚·'”ºGuºç¥öŞß›4æ»D÷V,øğŞ¤ÙïA,¸2‰Íî²ëÍPP|—ImÒÜ½ÈŠ’-ì"Á\Íp¥uâK¹=`]/JŒjÑnpÂÖã4ÊDEÓ:şU;É•]ßRN°"´Ö—t…W;ëó‹÷qÆ&®—ÅıÄ¥LkEšPÆ¯h/ûw=d<àè°.O¼Ío·µêo	à@8:xÕYz²€
ˆÄÈ·Å‚(NÎÄ·Ù¥FÖ&°Ç
ËßX©™Å#ú¡>‹¨ã¢èÂ"BJÂ?•ö¢ÃBã•*¡UÙØ–†®–îac6Ñb›æUŠ¸ÕI§±vpñ)Z¬¶ò,œ
¨á/iå$âÅÂ=X,¤±ñN-¼Ã‡˜qRƒf·Ç°ÓÇASö¨m¸+ÍLTZ0L­iÖP]ô%í¹ØƒÌ8‹Zôk÷“Èµ¯!ÍæË‹¤2ò<}ºÎáØ|U‚;	¦KªèCV+l‚ª,*=ú?t‡}	›TãUZ„k×;†Ù˜)^JÉc,n¾å2Î åq·Øf#7€ğzP=]w±³ˆİ2Gz>¸0ÉoĞ†Ø/ƒ„¤³úœ·øì·9îÑ®ó–š2³z>pH	Èú0Œ4]0J²1ƒuÒJ|¨Uo3gû¼«0íˆÑâ!ëÁ×l¶œïñà£ŒZIçJ†pœ¨Ÿ3šI‚äsıi®Æ&Q&å]£‘JyzNÒt¸0Ã0ÖV<b¢:¬¾ ÷"Í«¡Æ†:Ò”S3ts…O­cq©Ët9¤©2Eî°
p’/nõšˆ<à¢˜0•cÉ¢Ì«Â?0ªãxb;áX:Æí ¶¥@Æ ½aÆ³Ñçk 7\Ü(¯#{¥)G·"¹1Bƒ	ºd3.{Â»ù°’(’Æp^« ?<À¥RoÃü
%U´Dò€§º&_-ÜÉp‹¸èøôÇkrTˆfª#M|Œì=»íÚMµï!ÃÀ?
 …Ü×¡H•kWêzï(Kè{Í7ÒsAˆL$Clp†ıl¸OéÀ ãŸ‚å”^¶Úşİ['qÓŞùİßémá±g¯S¤ °ğ6ùN†‚ Ÿü•{Öâåaö	©N¸1İŠ˜Åc„8Ş®d¨b6£”´9PÀ¯ì˜†\İ,0•$eîNH%S©Ø!ÛD4º:à gN”ğBWW¨dæp1ä†HÜ °ÈAy~‡svNÁêÂ'‚U*×ä8Â7R€«~O]á:ô´Cs<!^îö’ÊÚºä­½psA¯?=tæªc4	†q¨vH{F‚ÖñÏ²)ç)å#àÇæ„ù¬öDà*ËD.ä–E<sdâè‹£1¶é3¹MŠÅjèQÆL"¦%û fg|GÔ,BZº‡aÁÉTÁ´Š!€>Fd¯ÎÃÃ9ã¡çBMšƒß!HÃ);ºÅ`ËavFu˜P¬^jÉK©É®Bc_›
öEŸ~Ü97öÀ
 Î ¼«ä°s†y$<'ç!ZŠ~ümSƒ2şÓÇ\¯“ã×$oÉØ£"°­‹~8ÿÊƒ ˆ8­D°†0fM¸vº¯¯.[*X½"ÿ>V•Ùë£É%
°DEPãõñ»Aà¯QM`Ù8š?
˜?_DÎUÂ.7<şÃÁºÏY[ËÖ—êj¸•°>Ì)<C*/ÜC,…®±ViÈÆ×0òomıBõª2œÚuìE‘~.Nı¹Š8k¨ 2p(ît„¬pã=6ƒsnr“{x¹Ù+f˜ŞW¤)ª/ƒ«‚4£OÛv[]kc$ˆFAÔÆ81h«8zÓeÏãgl³—ã!Ê!Òzbt&>¬eà©¾Ã<ˆ«6ëü•ÒlW±ËW ˜Cï‚µG,±Èr»|Í{ŠÜ¶¡±!ÒöqpÏwÃ),ÿ„CMŠ	÷H.^œ+ÔÙÆ‡°¡ Ÿ}ÁZ¸ß,;ç¯Ù¦7Tx1À©à§NW„!W_5x(v2ç@¡=¸l¾4!•+üÚK}‡TÉébóqhIk.ƒÈGš»Á:jÛn´ÓºĞ¹|Y‰¹KaDC—2NÊã”²ä›\4‘Şè#µaÿp¯K®à0cÄ²‡sSzÇØYù|+&1GIc}ÏÌŠŸ’¼VWZÙ
ŸŠ !ö2¤qÆş«²{ÆXÈ:Å1¼1æ|ˆp‡XÄÀ:MºVyC9ŠÄ	Ìå ç®¦,cöÁuì‘sô163c˜³$ß‚Ølğ°wL¾Gş†ó%\w¬ğ©,ı‡dÃ¿^à6ÏŞøƒéurv<HN×ÅÚZ7AJq°‹„‡_
¬qö+qc‡ùSï˜:SwÍho£I' ŒN€”%¼àP[ŸC²Æ//\„DN$÷FeÄ‡ƒo±… 'ZğëÂKydôˆn²ê!ï1µ|,MF4” {5Í4ÇÂ”o®X‘Õ™“ÑËz*Ÿs‰2wÎ+£1ŒW˜Ñâìb,Vca†Ş«`· üs”®‹R>ÊxEmmrzG6óã¶ªSùş‚W‚T­MFÏEë„‚v 48y…;—ÔªBn<³…Á ò±äsÉ.~!äŒ|ß`ĞÌà - {ÀÔØAç#Ü†$å±¯Byá¤­òDØÄ) øÑ"¸Å†Sì ú€Vğ¡>ì‚éÆop’	cTÀ	ÿŠìá °¸—­Ê%ÇØ¸¤€Qn$j‰ã5ziøLÀ€·´$àÒ]ÎêªxµàgMáp+{MöV=Ş¬qz3y­AÚs\i'¹X
L0‚Ä1]®•kM„Î]À¬IK•ƒœ4mKõöÚa“uô†âèŞbÌ¬•Âæ¦BÿšöŸ­ü4€‘‘˜>z¸ ¦eˆŠÁOœtøS¯~Ó•r”dŸ;Bêà¦ñ¶dœ4*ïÙò²¤gWx‡'øbÛÛ‡ná›b‡;Â	àl½nÙ¾r!cX#p2\d“ø„`êşàCõê:²ãµ°«YÇ54¹	(óÖ
¹3¦’¨‰À8%·m\c4ÓFBJÍ1sê…7r‡wÂ3¬†–0Be ø”•K•Äô$‡±ÕE2h¶ŒÁ§X¨pmÃ¬›;™«V;¨áĞ²ñhM1'WàPÍøvT]¹‹ÉmÏçío7 Ú±ã^‚éÙQ7&Ø½ŠÉ
æ;ìÒ¦&Ôhq^‰|çá Æi•İ1&¯@òMçøl›EÓ*ú «'ª•}*àuaáboş2VjPÜ‚91Wˆ*)jBÓ2b~$2Ndì™‡CòFè#–G|
Öæ°<êR‘˜¤y{/LáĞ’p6¥©Uo•’ƒ12éQ’EsS.”t~A…'ôú'½×Cú–Ë_„p/ß–}Ñ&¼{7ì‰O\¯%B°`˜ĞÏfááä¼fXô‰8LN	ƒ,…JV‡D”X­ğf¨ªÅZ6Nä«Ü±‚³L×GVÔ«r&¥×—ƒ¶•	uò—Ìªô±sPªíüoÌ¥’„©6Œ¼o5H0C’ÇÚ1¹,ÌÈ›k«¾œÂJÍ ¹tú˜8ŸwUÈ× *]Y'*¹CnöI‹‘G!%@g]QnGY‡ÚrhÒRHU"°&¿]"š*ó*É£sZ€E0Dn?¶ Â†¬T¥l@ u=	|Ö×!=<·ÿjØ6ÇÏN¹AE9ˆÏ;	ÇßTSßd6-çŠ˜<ÃsÂŒ*>à{¥‡Ú“ÃšÚãÇÂÆ®ÓG;;«Ízı(éê>(cfØ&ĞÅ—î åã·’òáò‰Õ °;!™†í‰ıS×TH£Á ´Hr8ÓÇÍ#ñ<Ñœ>MÚ$xüÓ0}Hè¼¥Ğ‰ÈwÊ­äË¤§8bMO]ÊH3¬jÇ±¥´—é OÃ¹1MEQàü*à L”C”·Ã³‘&8dL1 BÃgU¨±“€[.»–hlåQ™Õ"´ÃI@E3™áˆ}èÜvğ¤é§–aêe`3s—ë,t…‰¯¬ÍF¼i<Fï¿˜W¬âh7	pVäW”{DÒ¶(RèaÂlgš 6æ=ĞŠL"Ä$¨ì¢sÜcˆ¥Jú-%áDÒÑ‡N±…ó²19Gu¬é£…Bù_c¦çÉÑ^-Ñ^ÍC˜é_EgJYGD<qíµ‚Z3­aÈˆ(cóØgÕ[j™4({ìñµĞ®ºÌÇÅ1RkÇüëªN$Ú¦(tnŒ¶áä<F/«\œ"Î¶	aqÂ£ÁEì\&¢ÃBõdŸ¯b5F$‘f¨²—„M¥¥dŞš+—XÍŠÅşíGµ·öúØ£Õpª¹éGÎ9 :~‡˜=µáFƒ¶ÁUİ³êÃ¿S1“cóz}åúnu §È@Ê–M‡ƒ›ŒP¡óÔöì‘/ÉcA{º†ÅP{\^ ²Úä%Å(ê±¤|±©<3ĞC“Ì		¢Í/IÃ¡;	ú5¾¿’Ø+]g¤îe•íh$™Õ`Cjı›ìò=gâ÷ÁşVZˆ˜Vû{ÊtŞE,@ÿM.À‹únL)ğ€¢Ÿ¦¸CòÍ”K¼š¯5­€§ÓNSx7¥…»´¤˜Rà>üˆÎÇ<@BT@q3$¹y‡™´Ùr¦5]—Ææ‚®«éÍœgDyï€Ú"ãœĞ^ÆpIq¦vU8i{ë\[ˆP6»bòJ“¿*[”¾
âƒh…©SIÇè£ˆT¸œhùš¼£\š[ı¤Š;yÚwÈÚËI=º¾”øW¢Ã/§DÅï
ü‡:Ï†tAJÌ ‰¯<\µQUÙ.´˜Mq®ªÎŞÂ„°ÑÙ£NsĞ*¼N}€Ÿ«³üQnåÍ¯µÑ&X…eSV^\¬KÀ$-ò+aˆ–'+°MëV)¥¶(+¦b¹)s_IºA¹R…PY¸y)Zí”+äÒ¸Ü¢šÔ×áˆh#Ì?½DFÂdKªÁDçWÖ¦î«¸Ô£Ÿ¨"¼‡„"‚áæ·‚e/RAyÚJÀ¼´UEzs@‰ÜQàjÊ)Å¬kº<áÁŸŠ§“.;ïõMĞ7ÉqŒ´…‡.À'•Òæ3Tâ‹VtDGìÕF²‰¥«ŒWhæ{!s¹ˆÄ«õH#æ½Zôh:gM˜Z]êuñ+Nê)>ÔBEÂ™©`İii3uâ2êXÒV0ä$NY·ŸÒTæ]oÃ‘=-ÿx1Àœn’“í°i83ñ=-£¦ÊJW˜ˆæ¬z¤t¥OÌ»¯'pF†›+¹9 ±p’rDÀå^²1šõ—‰ëõ“’’œÁ˜[N÷?ã¨Á£©KşTÑŸ+ˆÄ§r9E6°yfs£ƒŞ\Ï°–CâGİ•¿q¤óMhs­šÜÆ&´wM\ØXîKÍ¨#ñªB\AëD99^l63±†)™‘ºb¬ÑÿÊñûy>ÍÇ@ú†˜üEß£ğrÕY%¡×|¦ZˆVAªÕ
’ÅäÑ±Ü¹‰]å€§Œ1UIj[ËŸ+lfi©»6dc¦Li>\`±ëJ3¡jM}æÑÙëü÷02à.Á—rhn|4>‡~Ğ€ıJúÖ'¶QóLœu*½®3íj¦°Kß?PßÖGtQ%U4VR’¥š¾m/5SX¹@d– ÙhÅa˜¦®ò®kMs¥/³ÍS(öë¨» ˆ„w?}ÎãİŞ°	áá^_œì“¾§lC:Œàhü8HE¢õ0 Ùö)A}¹zK7À¯2w÷èMr­{TôX\ K†ÕM¨w§•ª©	†6Dúºrb=ÓoÒã–Ù?äÇ@ÄQµÒ¾‚¨ãUºcY¿_%uÑlòu~>
-û V@:ÔÚ„i•Y—lhÊN¨á ²j_2&ÕQè´G¡‡¤âÊ	3 ]ù"cóacBY08hÖï¥Åèì@w_rÑênô[pøµJu¶oú`G;+N£:ˆFóó¶Ï</åœUõ×,‰àV·HùRğ+kÄ€KR­Y>½ÍiJÃÊĞU]Çÿòqê›–¢Ãp,NÀ*gÈM>N¾¢âÉ‰×jKÀœr™fiˆÔhYşD¢ß"_·e¾´—Ó’ÈŞéuå…ïÉ[ÕÚÉİ^Ë]Ê*àú=aåø×@`#XéĞñYoÄ”èôû|±x9®>·¼½X´’CH,ëXÁL’Å‹[vRö ©‹ñ{ÈYŠ~¹‡§Køá¤£¨À#2 øÂû{O¿Bœš‡}z#0^g!3à±úš©¡0ag#MìñôÈã‘zŒ1Ş…õğ¿Ğ¡«ß‰Î*cÊ_È“KÓ×ğnú‰dYPÅ´õçXØ‰‹S(‘¨4xLé4tn¶¢IK\ÌHûH7”^1Ši“P ¢ıJÑÅ—é¦÷hCmºY
‡ÖX¤Í,cµaóÕ*d`Ã™/-zÃ=ó†ë¥t|ú¬7â!\£î"«rü®D5.İ|‡G¾¤Œù.’–ËtÓNœw~g¥=ÂÅ½9¡58µ}äE0£û.vÔ1/¹åÙùøÃMlºÈ÷c4–0íàYHµxĞ¹Th}H7ƒ×ÄmTÚh\W«eûÃ	–ú‹Ö\ëfğB‚…2šªÂ§ “ğ™‚ãRµ‰‡½Qª/ñÀt…Ë4ˆp)S=ºÊM5¯5çè|ArêRXÚ
Šªo‚9Õ6‘k›$R2yÂÓ ¯Ê™´²Æ£î‹AC–EÎˆ¶™¼OÊ¥'ft¬r4¢YÅmšU'jxë#ğ—d³ÁH6òÔÍ:®·Êë´uŠW˜D©’hƒÈ5úJ…×û¾ŞlÄŸ«çàgl™%xKtLpÉ¤ ™/ÉÅÆ•ÚÀ49L¬a’ålp=$x­_ƒl<¶ÁöpöÈ	Ô€N'Ìú§"ô«n$Óõ#î`Åºš°0>ƒ;£ZŠZV‰‚bfY¯/šVm£ÃÔİmªBõÑ4x'
‰‰@,íâ~=ÂÿBî
·Ñ(¹iü
<]›Î'Ígnã¯«­XSJçfaÚ'§ƒ£·WZÔjŒÏÂ&åyc8ëçŒ[mM"«~Z0Oşúqïø%fD–kÈ?0Ë1l<·+‡àÊû1¦Rö]¥+ç±ñ6!5#Ş{|×?ÃfOmM€_9~¬³‹{%Ô0è ¨È#wZ7¤e5ÕüYa³‰¿Z«†§….=ókêx#râfc·;Oˆ½BZ–º1W‰™rÆ‹Ø!Íı)Ğ½«Ğ²-ÉiÖËñ»œ{í6¹6“bãuŸ²¥É›<t£û>£o‰È³8éáL´ ôèí2Š'aÅì´Ô¦Ğ"q(aUÚå|èĞveW.'íiR66Çˆµ
Ô‡T¶…ŞcºßÜ›ßû'bĞpÇ±Ÿ7E4@7rÁ­€…6XĞc@&SD7÷{W4@äq"¿Âç—ÓƒûOI=5IG|5¢D6=¯~ZÒ7Yˆ5Éu¯ûBÁ6¹kh>LssYš´Ëãsûf˜WbyVt)RšÑX:3^Mõ²ìöQ;´ Š‰¾NĞı1Î?MÓhE÷äÑ‰–AÑ®°&ó?k}}l67,Y"<ù+U!ÙN”Ë«M¦ÑiĞ×éïšÁÇAWÇ "T;ÄjJ:†È¼ñ)´aµ–K^PHì-R;a´ªÙØ*id¡!ÌÕ˜°`ëàºÎíó4vR…URökxu°å»&Îtâg®†7¦–!j|¨ÄL¹§cğ…M°ÄÅÈÆ ßÉ²ï+N
Ï=Õ°ƒ:ËÉ—À¿A5©Lš;D ¡+”CÃ²yox/'ÀvÊneENw˜¢#d3‰ “*>ãÀ¸‘À©Ë÷>ÁNŒ Vd] åEd~,>áH)nª)øıÓ{ì±‘»Ï{§ƒ×eì¿¢rà€uÙ[Ø>p,wä  ö¡^À¨°i;Šb¯»—ìÌ
%ª9IUnP*`ÀCd0¾Ö¥P€]«#9Å?,pü¼½yµ p÷ØNŞğ³Ø~yÇAr4¨ÛlGWÍÌí“àTÏY”>‚;9›Ë¢Lºu³}tÒ)ÖŞwÕ*võÒ©NÉ_ESY2©Ì#æ?""qKòñæì›¿Ë}Ù«%*–jä
ôOØÅ3#‹Àc@àï¨Ä¹·Štğ8`–hBÒøÔù ®&ƒïJ=7¢{J#Æo’‚nM2¼€&R†-BŠ ,…k¶ìÄ•Üq¤£ÊP{''8ó[‘„‘c_^QU4qQDLªÆ\óû›*‚düw½Ã›Äaˆw"Ÿ‚ìQâ”ßƒT× E'ßã(œ“ÜDˆÄ}T£›ØG÷U™ëW9Åúrm(S©‡¦úª¹¸2Jr_p¶El€;/Uße²ß•¨¤_æ]8<ÓÀs ólhCTeµA6üŞiq.]¹I–L%àgì\OQÜ¹û‚Ék_çŞMu¡Ó×ã.À¡ABûW÷º9AY´y+àXp%`†ÅÄF|0'NkÀ\	N
£ÓÜ
:x‹ë£xŒ’Î¥Z2•ÂŠÎ³·m‘G¹-kaÈÂÁÜKÂ9¾úã¥†czGFC¦DªìP×m¾÷Æ:†@–ıû.ıå|äúÄÙB„pÂ¨>Ræ-NÈë¹6ÎàI¿Äo8£¦³ù¯6‚Í¼É<2Î‚ƒ¢ ´>/zöè¦¦¦ÙK
\ ¾Öò»•´ÿ°C64˜íüiî<ğ{®×rt&‰]B’ËÖwp$B:ìHFjp›ÜáÃz¾„Jy¹†Œ„›¼•ƒ˜4T«LS¢?(j'°z¿W\^ğ‹Øš—…²a)¤ê¬8/±ÁBLÓú5<˜œÉ¼+.ó4Î‰¿É(”Oûó3!Ş”‹˜\‰Éjqz¬O")Ü)—d Dq¯03ùÆÈÈ!:SG&Ô†iGòåy}nú¯¶8¯oC¨Ô“Óœ+ôµM¸jğƒèüVËN0”¶¶¤ÄJí$x6K…ÈÇÇ4£ ôÑ¼ùq ˜MÙˆ™M°z¬v`O¶+¹Hxü¢1I¤öÓÌ2^d²yÖRqN´´‰_×Ï ÚqgA¸¾³µ'k[]|WÿYu»c_.ı^º¬8ÎrÚöù>‰UZƒ›qÚJ›;Ê®§ú7r¢…˜YîH$3?Å'ï+0n^ÏÕÀßÇ›òz¿šW Ø`Ê¦äN“ßö43¸¡Îìt4psD¤vÂı#<}¤§>!rC§väWl¡¾ *Ä? xÔÊh!˜ÃÅÍÇ7ƒAxÉÎßÖƒÜJ]€ÏK.ßôÈH O¬Í×>&ìëO2@v†t&¸GAÀÙj½QW±ŠV–Éx*M¦ÿÅÉê’¼+a¬øyTĞªå+Ôpğ0”¡Ş»J^+—‡_‚êÊ]@¾ÊÆŠÖ«‘®ÔÂ„×£YÉ
Ú3Gç<Œu‚’~€­ëY{Ñ=AB¢<¥%2ı*Æ êpŠrò‰œè­"$Ë¨…£
ht/Eº‡«Ê4-®¥ÙìM®+û
S2À%§†š9÷çj*ÌÊû]èÏc¶qqŠXDRÉ•ØFœSdª(£x)$^`ĞÁ9²ìú}JUQ^Jæ%®£ [$CéEVÓäúİ\fªd•‘±‘ùĞI-¦ã<T+ô©3„ôX:+#L	Ç‚`öPÄµ§F‰yô6^eY[ÑKªdmá*äÜ?¯±ãV‰“9Àq~YĞƒóšœõ\!:H`™I€ğÇˆVvŠoCä¼.oØÀ˜‘:&"-ºè9˜ŸãıR³——Å¸§O³&.Y±‡L·äJÕå;Êµû
¨bwì!ŸşV`¡Fyî8Ã"_1 Ak=2?j0â¼0¿Û<°DØ©!Ó©³ç
o¦V«ÈøÇ9®ø:f¤6¸)¦ä
Jº¦¦kj<PE3º¨-ˆmĞi‹Y®xtv–èÀç›o•SZIFÆÂ›„ı‘	”CÕ -šG^»ş';$[S•:Œ`çÉãñí¤9*Kä¹ŞÔFQ§Â¶Ù)"ô?&JòÇTy%z)j.EŒ…7)Lÿ@ÃxvqŠˆ&Ü1‘g]šIˆ&¨ñ2t5 kªôİ4D¥sòë¡ÉO²‚ñ¶áX`	YXƒ&@N?§K{8@rM0´¡kÜŠ„u‘ĞŞ$ı…Mt`ØÈ-ã8ˆInŸ¯a¡µh³VÖÌ”„Øƒº±‘Àh¬5˜&Öšn'|Ä‡Ëâ‹WPª“Ô‚ƒ´BD!_Å@UŸ$ƒtŞ0«4… ¿Â<!À§ñÓ¶Än'@ÅÕu|2¤«'/×òO´Rè‹LÒè]A~q”2Ó\Ñ–'šQÕ%ÆCÙâ?ç!9irÒ„ªc-K¥Àsá&¼Øæ‘æXxå´{¹8Åşn?	aÓŠÜ¡#SÙƒ´X£ˆÇ•Œjû):áW`ÇkM[Ô?îARH4UT FƒvİNO²Óm€¾õ€®u’dôms<× 6âğĞ÷7ÙJ'ÄËOšW6v÷‚qÚpBj<öFÿ\e9ƒ>®Ä{£-d6“jïàü|£ršÄnñˆåcÛaÑòZ)L(º:8ä§K^²” ¶6¸~Ø?÷kIş)kâØ}¹ÄåÎ°>ö†¹H
½Åˆxôå×Ù	ƒÒÓ¸Æçt–hV—¸ÔRÄ˜'¦ HULMœŒ pëÆÀ¿ ï0oÚZ6¤FN@evMúG,9ë±áŸ›PZ	×Úæ"=Ó*æ¹™ ¨T:l ¢>Ğëæ"T‚Gò~ÆKõêŞ0ØêÙ$IíšøVâÕ\ÔVo>¨zÆRT€hÎÿÔ.ì§ÒK§ÀR—õM”'2¦—A+¢nR´ò]ÊGŠşFä2“»ŠàjFWèêÅÊÎÎÚË­ƒê%˜¡¯Š'pÔ¯·ë‹zD%Ï$´´u®÷ò¦¬Ñè×õ#fÙioıÈßÍªïL™œÇ²riõÆ Ôv#fj$?vq--µ#/hN¶ÖJ²&Ì|øyüë“SÀòYÒcÃœ¢ù™ÈÛzG µŸõZ(‘D,*óúcÌ­šHšå "¼ÂæËCëPM€‰læ;"&°–^Ìé-Ò5ì•^ê0=â­¨Ud·…Vj£Çúe¡Ó dØ!¿(´Ò¢’›¸iRí*Û¨·Š¦‹7á6¢P÷Y÷¡c7j	ÁC‰ @(…Ò»¡ğ>w„(#Öû¥ÄÀ¶n$—V¥-ãÅuZ™Øº«\•5±İ`nëê	[Éıî[4è:Jî¾ãáõ·®˜L ÓH8IfNæJ	ïÃkù™¿š/èg•_âZ$¦VÖÀÁUw°%ğWr	)‹“õ·ñÚUÌ*=ÚÚ\Çaá0áóÏPÄFuÊ¥òr0-´Ùòh—P(*Š®tÀL%‘ÍUngD¾¢%TZá=… ÄÑôk£Á¯{ó¦.gŞÓ^×îZğ!ås#½'òï0ñSôY÷3HtšSî=¦"Ñ4ôp}’{?®ÊLbC)“.ĞKYUìô“Èbƒœ\ôÃî?Ü[*ƒ}¬t±vâ•>w¥‹wõ ÙTIBõªpÕ½\$£A&Í[å¡%ïq?·FwÛeù¶%Mrª¥ĞÙôÍ½8É±RÉ9‹´ñU¼?$yoşm$ˆ\p¾?":‹¸±ùÏß(ÀsÅ‚~äßç­À×úÀüG.m•ï¸*ÜéÀ!Ø2Z^ÁRğÂN¢å}Ô|ôG»¡9ºÙ%©p,ß'+Æ(YÙS¤›<G}Š¶Ê>Ö‰ëNYÄ´[ˆjğRyl:Ò4¾–¤k€ÍHSÏQ_%ÌğZúBbXM5›jIBa¡=:J)Ñ³g	µ‹G†?ú$ÄåÅ£‰1FDt¶±èÆàdjy,šàR QæuS óÕ«ˆR¬‘ò‡WSš…¨í7™H¥-¡ÿ
c+æI¢Äv"‡9ÈTL§¶öƒLoóë«·8Ÿì¢ËUtâõg#ÀÉ½Dæÿp…s§ÂÄ®Y¾Yiò;Ó‘
²¯™!ŞD=®?‘W3¾LyXØÚ¸J+]›æÓ¨>FÓé^k7¡üôv§Ñ¾ÖjJ}4x¿!1	Ÿ•åvoCÿ&jcıÈ¯©^‚‚+I!¬›2!K¥+é ?2)W~.U@ß‹›§^UAi‹R+Õ2±A2²®1”TÊ]7Ô=±Cb¡–Ç_KƒT·¸+‰¸ZT6Û\Ú¬Î‘ÖÑ•ÎÍ$I®{£Ì´)Şê!Tvi%°Õïu	µàñ wX’JYÎz­6°.éy~œ71˜xt5óÒà}¨A  )À@‚=ôfÄ™\€]Ÿ5ö¬;æ+M¾"9D­¨U'ŸTM	ÈÊN˜%·’Ì®®×âJy>‰{6}j‰¿¨6ßœh'£7ƒ‹Óc¸¸ãç¸uû|†Ÿ¨3•`_bÚÙpó]Ä_Ì"˜ ı~ºÁU¼ˆ;¬>üˆ;,æ<k9>ıËßÙØÈ¡WÂoZˆ‘³ô;ÏâÔïêºŠÑŞ¼ç Õ#:kú#;P¦¶-‚48=ª[ ±ãQ–)eC?è:b¸TÛÕ ö)¶6ŸúfmUŸ1	]¼Ï—oß~÷î]çC÷ì´3¾¾Í[½o/v–äCçÍøìô·½ã¥_~ùàa<ß1“ŒIz.ô)ªÍV3xŠU
DğW"]J¦«’Í$‘ípWd?`0¤ù‚úƒÓŸ,•’æÄaJsm¿:g?#L‘–„¶L !)âªsĞ*KŠA÷b<àš&8…³;õ^÷•æç¼†Òö£Ö3šĞæ¸Oœ×²óšS2‰\&[È$¡) vÖC4Ú`º‰ˆ	·¡«Q& ƒ]Á°]Q8í½Õ­·ËÅÍ_?ş¦Ø]Ø¿†e"¹l¢äšŒæ@,Pñ±ß•ÑÜ¨Ş.úİ££ò\nk—I‹ 	 TÎS2İ‡=½7•È«&y$øtF =ÁöÚa²Y_@”=™èé÷³Ò·£ë¤_IÑN“yÌJR-}ÃÔòl°(×Üìn `‰ˆ\¾Àa*dÁÒtšbš*—ñu¨úğÇââüXÒàA{«…Äë¬b`áÃnÒUÕ•VPÒxË¨Gã¼'dVÔj"»Z‡ä§ŠıÓ¦i¡«Ê0p…ËÏYFP|e
'jä´ğaºFAO_"|ÂÌ°Ş-8÷§‡İ£·­}Ú™$Fµùej+fzĞH¸¢æƒÚ§ƒ@x-‚*9 B„€ë3F7ˆ%>d ¦
LG°–pâ„Å{ùE’òPÑÑl“L!”xÚ‰CP)“J £Ã¾ÒbÊÇ5æŠì?§ƒ\tƒı§5ÆJõ~€eÆ°ÈšĞSßøÊ»¸Š†e— `µ-~½Œ)*¶×«*WïBïÔ±×Ò¾aº­"RŸ¯æH`™¦‘J-«:Ü{ĞH‘˜ı$$äQåò1Hâ^µğtuš.r¢mLÕ›i‘¨O´Êd‡ÕuæOÌ«a~ÙGûóíÖÑ)Òk¡WŠ•àµ‚ğ7D’Šˆ“cóÊĞø&ú›Ä…p}¶.ë7Ö+r0®nù-Û'¿Ä8tXRŠ{¸¨{Œã˜¢Ñğxeø:	ËÄ§^qùJJaXÖ¡#ïhÄ4“zğYœ4FäŸ`Âõ6îÂ:-_w>(+ô¸h¢áz‡´\°“Š
{ZRvc!tÁˆ–«ˆ"¯¸½÷ 	ìe2o¹Jô8Ø‹ië~:ÀĞQ¨ù?ÉÆÅCä´'à¼_òë®Èx™Ôf•hiTc|ùìä
Ëİa3˜ƒëkÛq«l¶¬ıK3Œ2&(f¯º¨ƒ
mãÑï×HìNxM91[7wjëI¡Z!kèéÑ/ÙÑ§1éˆS5å‰ŠuH*y)ííÕeÛï>‹à‰V·„­P*âíó)(¿,‘“ä¨ŒÓÙÇïc¶¢Âó5@¯äÒìTĞ†c\å'B2‘‘?“•3ÀÓı”uLe:Wãèx4 5Š‹"ÓšNJMx}Â$ €¥©áCÌğÃ#JEæò‡7^x7<aÙ}5b•’¯zHÕÅgæ‡î°ŸD…[}õ(İFèt"œ 3fFûd;CØ54|£®Ñ ÏNKõÑdKC\¬"«|GW_·® Ìü­,ÕZ‰"[®“û;.’×À]ÊLTì§ÁgDÄ^Z„—˜Ášî«ui”lÈvPØË*™Å¾¤– óÜæi\aíÑTGä‹ª«“Ô³Z·o¬l¯nllnl­<y¹¶ò½å¶¦œ£3@çîmİ‡•“b&‘ÁFaNºJ<Ô8k)Ãs¸®£!ñ¤ Œ+øÔŞ„L7©¿‘®ãw*<©õ‰|ŸzÛ¤ÇOGgÌ÷ĞC?CsqÉ	‰^ÒÚ—9lÎük¡N¶1Ã}ï RÊ¸xy%òŠ”š¾pW_ÙÃx®aè_û„F;“Ù«„Z}ØsE‹¬|;î]²d~„èºÁÏOvŠ'{Ê­rm©³Q”pf§ƒî±ã„¿óäıÎ™Ól?*5ùVrw1aN
™r¶’xéŸà¥òª°ÀJ/yğ¥¬ˆã¬àÌOäÓƒ)^?îõdŒÁËò=‚#+G¤ÖŸµLœšo¼ÀT¼ÍõŠú„çÂat<±ªßÕ—æ‘ÒTvéñÇÁÆb$DÏyñäù³i@c&¡®ÓúÚúº#˜L¥ÍãR'R…‡²¥g½qÎ'Â ´÷ËwèŞÁ‹UêXš³O°=Êkó\@yÿü¤İÚ[ ÛH'Ä±—#Òƒ‹Tô‚àèŒ_¼M-ŞÃ89<š.ÀÁ ¿j÷@à+Dè¨}Àôd‡xUB†)×pácïå
YŞ0Â~h¤CCkñîÙŒ&QJ³,™És.“)Oä#ub-e‡³‡#ê´pbLçvœä-{eTÌà¨®+è»¹´š’Ôî¬Í,ôô4‹  ~gb¿rz™FNãåíŒ.ÈÎ›"z<ª—{#ÈBXjnÄ¼ ¤¼¢°ukpøÄZ¢Ùõ½ër=|´ãòêÿ8Ya
BSÁØ´tš4{¯§ê±„Ã«PsD-GK•a2Ãağ%LDĞ;â²¦á°ùÂ¬Y\!ÑR_[Äeµ„áH†øŠÛ¡ú®Û7@µ†‘€†Foñsñº÷I®h+oÒÜ*¡›úãùãŞ¨‹ëØ!Úóªá:IÃ^xa¤‹ëİ$è¨¢+nN~*DÑ7¢ûô0gX«v+®ÕĞØ¼`<1¦sÉe|<ª\‘"—h#+A6­DNØ»¿Äü(Ï}¡N^ayWeâÁ³V°ÃÚ›cxMë³ƒE|WKÙˆÔQ9¯§şÎ«Ì ¹ò£pŒj	
~B„;]Ç‰†{	½2¯kªGüù»¾ïı#[ınåå›v•şf€–Ìû’;+OÒ2ú™%¾ü
Tìà@\a"Tjˆã»¾¶ö4­'5V¤†XsC³TX]yùrcåÛµƒ—k;¯^"”?Rá©TëVØ~±²º¦ÅâoVXÂŞ€i[ëÉ¡Zû—ÕÍ•g+;Ï­ïdiQêÜ¨ŒâéóWO6×şøêùNìJúX’ò7+å·Öı$åïHùßVÊ¿X{¹º¶µ“×ò÷¤üï*åW¡ÆöÊV«K÷¥üï+å·7¶¾m†ÿ”oUÊ¯lcŸåÆö÷@RíV¥üêógÏV²Âø"åW¥ı¹Jùg[¯¶Ë+‘9CNi¼ú|3¥”ÖdûwåJùµ?¾ZÙ¬v åµıG•òßbf†ì|·BÊ¯	üßTÊÿñÕÚvÎ<6Ş;ëRşq¥<ño¬l¬*³ı»Ê£¨”ß\[ß9ØÆ ^rÖ¸²úıj±ü½'Òşn¥üËo¿«Uò:^»8Hå·/Wşyí`e5c:–¿¯ğüXi_àY}õróOçÂó±RşŸ×^îl¬b´§3Û üğ©R^á¯t å~¹ÏØbm{uåÅÚÁ6h¼¶µº¶8lZR}³½´°/”iíÁ¦*k*ó ”éN,ó0”9œXæËPf<±ÌJ(£7­4Áó$”ùib;«¡ÌÉÄ2OC™á¤2‹±¯rR™¥¥ĞÎÍIeîExöö&zx/4´5©ÌJ$ØÁ¤2KK §k{›SÊ€RæÊï<]{ñrm¢şFïùæÚÊÖöÁöŸ¶vVşEwQ¨(Z°ô×ú}ÀõÄülÖ¶ù·Ùà÷sı½ÕÒ•µ–|Å·¢Õğ÷–ş~.5NN¤ŠıY_gâ”.BP S˜V¶×î/Dˆnÿyw~vÿñîÂü—û³íÇËËöq†_ö:úíÖÌã/nËİÛE+"ƒm;Xek0:ëÎ!ªvî»ÖĞÜİ‰˜¯x¥îîÊv\.ã¢M’àÎb2‰fdRÀ	CØbaØ/Ç3täm¡ßØ‚ÏNÅåVÇïı£<†L-0İÓæŠ¬V3›Ï=±2„9Ğ9÷Ó·Ä\’òlGÒZøÓ¼Ï×X2×=«i~
`S:tŒ<Ç;˜H=0I¦ –Ã…BœuUœ¼Sê4uJ†'¼LÎ“oI*_|Ç´0òb@^ó¿ÃˆÁ¯Î^P4)*óÉ¨ãy¸¯Ä©§Çåwå{¬MØ¬DrÆ æ°,.ÑøäIiaÜ±åU;îí¶ïÏàË«sœ÷²Šœ¿¶ÓÔÅÜ Ï5‰Àh?Hë½hÒ#Ìé–l`qSk©¹­‹z[w¯ÒÖ:~Ì!&Û«z{³ö>:+q1²:C’óãÎ˜¾Å#&•ÉÁy¯eÀl3&lø%’ô§¯±´+`ÂYê”ôÒ³è´õÔ®B¦S~ç!üqöEï~èÁÎŸh¾Å#ÅÀ=7!{­7^ƒ>h$°Ö6bíÊŒ˜{;*Z¤-BÔr™Ô}­}®²`ÂÕk+b¥°f?Šgİñ›ÎY÷}[½£İ––ÒF–fL¼¥~°2v?lh3I¿Ù­™ì–Q˜˜ŞèãT¶OkJê2bm/šk2o}Sò£	8/,Uêà0 ÔGĞCÑÖ>ï0_,–=Åãíàe‚yh&ÅŠ\x—Ù…ŞŒŠQ˜¦¢)ÀbÒÃñ÷´ò“Õ^4“¸äÂQÖKª…Zï¡í2’¼,O¬§¬RÀÍ=õ«ÜZ„›~qhÚSú¢¹*–TÀC£rÈÌª¦/š«şõbÀëèhòñ%/PSBlHú}\4IÉrşTE+Á=,ì6·â$u"%Abò¢<ÜpxÚ=‚ÆM?Dd0PÜß;ˆ.§„´©Ğ²…ûD•	­²ÌcÀ–pV0“¦ÉOÈ$âè[4UÃ9q§¼½Ö¬©QNæLK:8‚æçKHÌ!¤^îóô‚­C±{oPì âİª°’‰L)=¨›*\¿$j—ø…¼qÛàïÈ=Åç~Ã *½cĞ1*Ş7NËB¶[ÏØFXÍ¡qE]ÀSÑÕtµum[!0M¯KÆÆñõ±=ÌµìŞ ¶ÌÛe9Ê_¬Ì©P¿2-ús'.ZAëÔ*søº„A¯Ú«—ŠÖ^+T–2(ÀiíèJK­~6r”C‚­ÊØ¦7ˆ\PâŠËòÊlÁ{şÖ_šï¤4ÑçqXøvü*!x®@Ñ£¦ÿÅ…àÂ°è€§,®ÍZ£f²'9d¯¹ç¬º€7Q×s4d‡“!˜ı>Í~Ñö"UEìå-lÏ‘¡Q¹îëûÒ÷•x ÷gÜŠMøæGdÓŒ‰³]|ÉÔÆõ&	Tµ!“»@¨"D„Iƒ	ƒL
P:Ißf~µa,M»ËÒMì}°ú®vïÜÙ/Fó¬¡-/˜y=Q;æxÊ?úØì~'·wÖò‘	›j”‰„ñ¢µäïöe9¾öqËÆå4‹ĞÑÙÅÒï;‡~a¦ “…X.±ï„[4¹öÅ¶>œZy¶Y`“6Íp3æ!ƒw¨Ú–>`‹ÌLV¹¨ ­Ø¶–î)nºC	éê®ØıAeÎícU‹‹½QÿoÿşñÓ>v|†¸7P<-‡Hl=.NMÿp=cí}oŒ_¿}ÿğüYY?ø‡/9Šµ/8X‚UÃlÑfìhaiÓ‰#N¿tb‡Öü~‘‚Ne[Ë®,ÖË>}@g_jË9bÒ€&ÿşe½±5tRoÎúÓ¤1!;B÷YuÂ½H«ÕèëGqwïÜİ/ú#ÅÙ0bÒ˜S±½»„ ™¿c¹£HO`6 ÿh‹Âóƒ!.ŞœgşW¿¿ï…„Ûç©¿æO¸¯ëßt‡Ã^÷u9¯\­µ6úG§r;‚J›*A.OÅ,f4À=‰¶‹‹·'”£>.K”@°tåx‡Cà¡.¿‰$9mu(SÆÙ4¼„—¶F«àÂçÃ)âÚ¥ˆø˜ÁéiÏ­ã¶±de¤±LX|IÕÀî"éITÈ¼ùQ÷Dø_(ÍÈ)Á<E¿øÛÿş?ób|Œ Ú´h m$hj¤×¿Z²itQ _ÛhhÄFOÌ"™PùPˆQAÅJIŒ2)(Œ"(„¡Ôs½î†6C/ÔYT;¬[´ãs'Ç|ñ·ÿ¿—ÿöïÿZÄ§ßò“qñäCqÍk¥ÏE-"óë¨ABÒáõr Ğàº\{
ÅML0a-Ú&p‰<èfká-8qÃò'…¤nÄè mŒê‚şÁ<¶IÔéÉ*¢ps#,œº–‰£V7ãÙ¼üQµeÁ°˜È @ÂÒöéÀM ‡·Ë—¼—~©Tj¼¢PUƒ¬°…Ö«oÖ‹&–mZ+šX¸¾ğ3±hÃ”uû”â™œiåúONQTœ&Ì‹ŠÖo}Ÿ1	Ú&'EG×ù"Pc†ôŠµqÂ¦uDKİÈVlRìjÎ.áqâQ	xÒFĞ½Ã¸±‡îİıs±€eo` b-¼Uoi™Mnwİ¶ÅßEB2êà^ËÖH9ÌöÍ¼/»ŠI/Q#~qJ
&îĞNÂÚ˜!8Sõ¸{2ºÎËæ£¨±…¶qÔìá¨Ä]êÈÜ3}BMU›0ò;¹âÍ‹4xìXJná¸‹ós}ØhÿAË<¦rû|š…Gev‰î™ÁZb1ÃóUh›8M¢›’Û‰f¶AK(8=EıscyÔNFN½ßa¯@Ş4š¹0Âİği?|ú>ıŒOÖl.²bŞøÆ×¢_Š€Lxƒ%ûÆ7“•IÒE’œ¨Dòb“ˆğ`VŒ |ú}ÀØ­ğéFøô)|z>}>µÂ§›øÔˆ‘óÆ7!ó¢ù­åM4¾L’Nßg‹æ%4­¡ñUšÁĞX Mi,æ¸Xp½`ûwcŸ~Ä'Wí9-™¥±“,¢±Dššº­WWrñÅu5à&N8Íà_ü2o™¦ëü¹ª	®×Yô¶uIM¥b–¹¬*ÛØ;/ìSSgz)72p sä‰ÀfãÆ¦fÎ"ºÎĞ_QÑãòWz°¥á¦Mz{7À‰ßÔöƒSL¿°%jğ'bÈÁÁ)Kkjk^Kı15!„Æq¬êîIíJ/ßT?Šñ-ÿ—Ü>Ä¬ƒÑG²
÷ôÉú:¡.ãdr?Š>ØúÍblìÕŠk·«Ú­=Ó~9Õ¹¼¢?xXÌ§Å`Šøg’~è#bß9,o#¹İşK÷§îèYŞãyY½¿] uÿ5è7™'Îè2z¡?îBêXçmô°Døtğ`u#+¯á,ŞÈÄ\qGÓÎ¦ô·5'­¥´ŠM8æ¤S‹xËã8Agáô˜œ`Œ™=ÄY5ØÇ{œz ²!5ğ[ç$ˆÇ‘$zÔ8ä—Ó„m†”_2DvûÏ{ı[2¨˜êĞñ¦àll{çOÈ7{±¹Â“ÑV'ë[ıÃ‹%"ë‹Í¤a­lâÅüÅúóÍ§L"|TÜÍ_ØJ!^Ü“H)tV†¶öÇÙé5º>%avpä¨Ç$We£cC`1øl'åŒZdl@—¡/ñšs<Ä	4D4
¼–ó$xO¶W,3íá]lğõBƒÑ8-¥UŸ[Ğ1´/¬pu òm[G(E•úwÙ†•F==h†Üû)“Á6>ÇQs°) Ú át¥lñMR…ˆ³˜!ÛÂÚ|Û¼!ØfT@oØZ¿-§‡nÓ5ŞÁêÆsŠ<úås,…h.Jü¢Ê"'"ÄN %>ùnåì°÷úbp1bğv®HÌäŒ_ñÊ¦ F“l{ÊÕ2“„÷Ø"ŸĞo_Õ§¾°£µDKeo;ª„ÀnxWõ˜ñD–
Èr’‘[
¨0€îÀI+| «¾@+aì²Bà‡6: =` 
ïeV}caÕQlÆœ}„¡;5Wœo¿¨Ì+ã¶baÆ>Ñ(sĞ¤ZĞ†jZİÅA¶HÙš†èòŒòŒ§‚Mx®ŸDÆ˜óD˜YÑ*Íä/ş Ç«Ü#"S#f°×ƒÒ0ĞÃˆ<c[:n2¬r7Ci÷„Š^Õ^}%!îBÌY£Öc–°¤Ş›Ğr³°pU“Éí%ëEÄ <‚dª‚zÙ"CP½ªTİ)÷rÜj@øÉI©auÚHzŒ†aÈØQ&bC	Óvaf*_#²…)%
¤å@!bñà‰LÅ;V%œ )iää¾TdÒb2ğ¨Ã•]Q]ç#diab9£0ŠsŞtXQP%Ù“Ú‘‘ Â( XäÀèú¯õ 6î¼â&ÎÆáD´(ş€çE—å*˜)òdßªÖ³õÓ]rD^>Ü¾.S3dUúRq&b¡È¨Éöàÿ¬/ì »+§ÌÑør'ì%¯ê†ê‚iÜë›ªÒôO~q"’ádµ¨¦á|ÉT»^F,S9J°ÖÊ)—÷^ãªQÉP]*æXEfF\ê" h¸G™–Á£IªÎpe«Xô#¹¤ïC>~VW¬£8]@å,ÜpÙ¦‹¢ñJs;P€Äú Àa'æ·0$E3O9¹PQ=š™g(ÀôG©DãÛâ sÊ¨‹„‰V‚EO{Ì…b9qTgvt0J¬Æ+Ç£…²óº“¸cE‹z¤Uü4Ò§‡ƒ¼e8lxêú‚`ı|#1tœ%İ¨y5îZGÀ+Ö@lÉ%Ì\õÄ!’€iSæĞcó5Í‰^Î\Om7°ÌÚ1â”‚å©“ú„âíêp­9Nkx­~²êJUWîÚA}ÉÁO™£ÄÑÛÈê–0 ¹BŸÒi©¸ß²œ¬ÌLÑ%–”;%
ùBYìTvêªã_\ôå—weñ›R9»'&Ü–P¯a…ñ°ˆ 0›Gíx6=Eô¯I<#%÷RÉABP[·]€+Æ–KîÒ‡O!êQÓ±Le"´õ¤Ãƒ9qé¢°¾ÄZÆCÛå-ËÒK[çŒŞÒ¨CBCFqÿ!FÀ<½/ÕÅñÅäšº q|è;,3i{Ü#8»§ïºH ”HÇ²ÕÇ²Ş¿ÿ¿‚ÊĞÊÔÆæ,8cóäŞ.dU©{>à”P¢Ê</nÎß„—ÆDùt*ÅæÖò¶ ğhnX˜s ÄÈ±“HGP“Ëa ßmÙ¼Œ,û¶,ÏuFysÖúá¬]gßš¸ğÁw‚A^ÎPçXd°0_z7Kêt	ª ‘¨UQ[L™Aöü¸Ö6£;g1Í‘!FáÉ¶CsíÈ§â´HSî—WvƒE£m]M™´n"GY!­ÖÍªR­m¥	•"Uéfˆ|ƒ†$1-L1 G`.	CZi%ÙA‘…'Ò>kpm+ÃÀ`xÊÛ¾Ùº™>Æ×Ä¿w,¢HËÁi›j@Fña_oe©Ç–]E!ÁŒgÁœ<?/7¡Z°z]BtÁ{H¢èğ$ĞâR1&NĞÃÂú`EœÉ[‚†£Ğ3—‡×c‡/|œ¾ò]‡b-Õ¹âî‚
8 Gİ‚zØÂ/l/ëT¥î .Yc¡~ñ·ÿãÿC‚10´¥“-ÃÕ8Æé„œ“Ş{H™´—ã&´©Ío&·è£Aà6ùê“VEÇ–4[8v ÄDÆå»˜7ãÌXZ ¤wvqfĞ"2Œà’O6qrF{–úê*€µ
17Jcs	/‡škG]$”ª²P4€£‹cPg!@A
ÙR2PÄ¦óPòD²"¬,$|‡¬vı0®T/$JlmŞ`KGNùÁrÃh[©À ÛĞBl@FİmÏĞÅde4Â!0ñ{ÚæŒ?¤cÒyø&øŒ ‡¨¶0a5· ’gÈ$Íü|,MÈÒQpe]ÂGğ1€8"Tœ¿W
ª2ºb8d:¨œ3Ó,İ/9„M¹ÀNh;¨€ÜjğæäW†)¸Ê=µX1×©˜èl”ø,âqVÌud¢LxÔm7“&×løª]Õ#èAõ¢U4ÂÛP'U—È¬„7|T¶o·ncVK»1Í€"mš»ÔĞhëU³øßÁĞ—<gˆñm·¢.^ÍŠ£¶~Kœ³BUº-uCV92§ztM }ów ‰Yº «Xš
©úøMŠ]Ó$Ì¬qÒV.ÒÂvÏ¤m4× %àñuÄÒCDÇl—K‰!µ’?·uc»­pËÓh¹[^Øİ1C=Òu• Nå×˜ 9„Ša†'yâgŸäuÜYˆÖz#ønÈn˜²O_¹§Ú Q|wt,°L%Y±×=µ‰ğHf‚ÃğÀjA±âÿâ¦»Ù7“É²jP‚yt
Ÿ©dş£Í`‡_²à†x8²™­+]Y—Î*êJP“ÆùµºØìuév şÈäC`¡[¥İÇEk–^a[šÇ7~iÍ“ú¢QL—(¾"š‘‚.­€Vç‹6n­;.H$$~r‡BÔ8ç)¹„+ĞNßLÕÆ›à
vÔ0©»
°O•§(ÉBôQéàÑ#ZæŠ‰G(B…±[Š‘y˜ÏR¹ÌÓNtvaÎÅ´Õ%ÚH¨F€ÁX†2u^ºø4gÚ:TÀMƒ.ïÃq.İ€…Mæ€sÅo¿g¨<ºàÑÂ>İÂlíbÌ“ÄÀ¨_¼]ü"¼øÛ¿ÿŸBd4fj°¸D„ôqŒNèjuó`¦ø88²/Ô‰eœÊ›:,_÷ú2wÂ{Ìü¨ù‚/D0ÏºœøY… ì0M	ƒyÒ…P°ìÂ½Á“İ&ml¨Á°5©ù2ÏÌKâMärjŞ—²PŠ-<³3í]¬—îßš¹np@“µ®ÕsÉQò'c´Km›ƒOÈM&l,Á%8/%¬’Sd|£L°N¡}Ğ¿À¿öİYÖæ}®Üu0Îç!ƒ¸òjİyò4ÓqÇ´–†R&Òj®Òeª°qR šBÿšA?8µX“ù´¥¤X.>”8­.†Ãy¯U¢v?=5	°D/38S¨AS…§E¢ú˜ôú‘n …ä§É„£Õ	i€ü†M-ç«Imìe§;§ët/ËNù¾<2ì¤§6²2 ÆôE¥Êî"îU ŞÃƒ¥°;¯Û,–À¨mLƒ5(m[ #p³XWªá‡AÆ¬eúÄ@ÎÊòDIV‡š¦ı¡ÑŠ^Ó¬h¡>kå¤ÆTigÆ™ÒWğùÆµç·C¨A[rñ`)é}Ñ;BŠ‹ª•Øygj˜-rA^ezÜÓCÏQM¢¹ïzvd2ÔÃ(´<æ`CzÎÚ¢;I3Ö'ã]ÏÀ"a‘EÊŠ[sÂüÜâöU‘œç 
h«wr_ƒÚ®ÍTo»a DÆ%vµECË¯)ñ!;’âÈç‘g·%”Ö¤F5¨Æ…
ä
Aî€E€TàE'iNQÀ¤°ª¸‚)©Pm …#Æ•õEAîaÆ,F‡†áuéæºù¥Ø`"= ¦5HedScì÷Ñ¦HkUëGHÁ±Õ.(#Éf€¡Ô‚±Um‡Ûc-¾R)ñ“ò^¦eSoŒ[­±®Ö2)äÚbÂ¢v˜-@ÀXP:À_ngWÌ/Ít
)!—ğaŒ(!j14³ÑáFacæÁ¹zÔÒüŠ#•ÓJ0«m­Ä¤u	–× ±g.\K×fG0ÓUÅddTÍD¦Iõ’¡H(£16E–ˆÜB”8Â“ä1!¯ Tfz‡Ì+úûoÌsSµÀ^S£I3ß(¦¹/]¾cy&ƒP“X:`ĞoQñ‰¢š!1k$Ô^zRFÃ]õ‚rÍæSa…ÔFç%,åñĞ2ç# ë_ôêf`ÖÆ õøŸŒNÙ%ÓƒháÉ)`Xğ`ßqØ8Š ”‡ÀÚn‚B´‘—Óòv
Š+2–T‰i³w4…Iİ)É”Öá±	İC‡=zà(Cfic9†j€Î-&^Ô$¾Ñq°	1àóujaÓ µ×@¦]ï”I2Úë;CW8‡aŠœU>j#|déœô¬!³W±Œ7¤­¸g·²ãwr›ÆIb¦BøX‹[×ØLå(K#`bÄó±‚ú$jJş§Û·5Ì€¹egş^ 	óº¬zÈ<cV¢qF®£¯i2r&júCªğ¬•ò¯f)hüÚ,úË³\¬³é9.¡ÈRí°+¶ '!q d…±<(ŸLk$…%ËŒ‰ÄRäíö‚û¤m	|1['İWí5À‹¡V…Hfß‡¡‚=ÎÏ·	:Æ¢Óœ@[™±®ÃònW.´u=mÕ§b$×“oÃ?àøñ&¾zÔ8 #¿ª%‰ßeIÊjÇÅpšÕÁYrì«O´IäEéûæO¥]@¤U›vUC["Êì‡Gø(9¯›—Ğ³´½¹4Àòó©’ÁÔDñ.Ÿér&
áŒ•R×9¡a9Yen„Ù»r(·Ç¨¼”ê'e%¡×ÍğìeÎè$‡#å%!°rY­Ñ„­.62JOåiº.¯qŒ†^i¥‘„P—’ã¢¾üL`ÌZsÔ‚íŠUæ©†ãJàèã?ñóUÅo
Uµ
—ıuÆæúZOÕ /j¡X	lĞÚeç¡É¢µ/Ó/Qˆ¹<<a^ßT˜ÃT\îvù/ÉÀ"^û?dP¯šhbA0ş[DD¿üê‚¢ª°Lê³.77Œ¥8Ór.uRkK‘È„búy.(6©ÕÚ”ĞD,`ÛòE‰WÄéÁåH»MÜç„Q“Şò$Í
Ì­y{ğ…ù1•2±oõºÂî.[»tzDzØ_şK+mUÈ¢%á«AĞ<>Ë/¿Ô:r@´†éQ5n#ı2³”*@ß—x["ª?W«ÇUM®™h7/1«¡­XCıs÷rtöy·7|räÚÊCñÌ&Û`ƒîŠ¦Øº‰Rœ¬Mö")*&ƒìb­DæMm÷\úä$~.Y€t>ËU”2Ààr%˜	%wC…Ü5Tº5yy+y¹ÜwM#´,4¢Ô½øÆ$£Ÿ4bêL*¦föú¥HÀ¶N<15"Æv‘fG¹ÏNsÚÑŒX§ùõùÑ7ÅâÂÒİîaÇòs²D¡¦ ßR22Ö'i;õ¡DkY|…ærâ)HîoÂ—àIÙŞnÔ?™B»&¦De¸kp5iÈ'ĞCO	d¢‚LK¥	(áS/¤¬»şb@50·RÆúRÄL÷x>V<ŸEK7¨8ñx¦é¸©+´ÿÊÎ³A^ ©ST ¨´Â…„8†<OóJ$öaË@«9aèòtl;ä ¶{GÂ“QjØ”&ÎgƒÓM Ê'úyª'AzOU½E]Õa<e”ˆN²Ö™ÙUNÈziºo}­b/)N*bÑ0½ŸÜaŞn½ûÊûà £ínŞ&·n—éèr{!b¶ÑXÒ²ŠÜ;÷…z“€_ÕN)GY33e`‹¾’–´ Ù½šƒöÿ7wuÍQAôYÅR¢»híb¢…”Xh,š¢BÄˆÑ@Rl¨#şvÏ9ı13÷ŞXyÈÎ™î™ééîéùêIí‘
=Ç lsòjÕ¬†ŒÌù–VfgÃ/æñ›èb(Ó&®%Dò‡ú’FµæÜ0~‹•©ı†Ş£y`ĞiÖ„SÕ“iêZ±·¹¼•ø^Ûo9nü•t¼Õ¹·„Í±Md*i¸öæÕ˜äÇ6s©ïJMl_Q$pÃvOÍI>¦5´®‰ıŸŒìEŸ¿aµt™“WwŞÔÍY&N«÷”ñÿfo„ÑÂI×)l2éÂ!ooæ\lİÀ”‹#é9BŒ%.St³f£k«5¨Œ…+íğYÇ—#¢Èw¸Ôyd…V”°=»#âĞ-t¬F‡ƒıh¥bù—>~Å	’	PŸ€M}_?æcë„xŠzë71%ÀŞ:ĞÃ¢YÇ›œSr‚™ÄB ‘ÕÎ'XÊŠÍ'šZ‘dI°0:h¸m7TPÖc j1}•š÷V™’G·A(n*VW¹X/}åµ0½›&‡ÁXšIÜÏ5q#Ì€‚ÔV…+46@Yığº­.)©µº­_Ûv»kú‚m¾#ÔEÄõáç ·+æ.ÔË÷›*ıI>{vnìFÃhóéc¼Ñ~ôøXà4›G\!ÓÆ›\+Çú?N¹85]²râJ§
{pù[‰(0¬Z°¿ğòòÛvç®q‚tå¤óK=­€&òÆŞƒûÇ8øˆ#öÄ¯u£šJ	“”ínV³‚4X¬¥ÏM<b‘Ş,wÅ‰'¸)UÒÈÆÎ4æŒAQİ7¾¯)¥†M^^â±³‡‡G¿àXç}Ûµ¹O3	 ·k¬ğ¶xŠ†.°{[kØ­È5Ãm k|é.åÇ.£çÄŠÙï-”€u¸èòZfh˜,Öég8]õÊ8X>NtA–çÔdÌJóşà˜B~€.îÈO©3;³†s¾uk¬¡½‡Û'± ÆúªÍÑ`<*.×i––+×p®ZÚJ+ÑğxÁ‹V1	3]Â‚Œ0[OäüßGÓé!Û[Z_º§<Ö4îıDªàîUµÓÛøÍv×.ã«Nh
/Ë¬BJí8~c<]ä*CÚ#“aCBó<\Nx_‘¬¯bÖ”¤°Cr'*‰ş2"3.jÔ‹İ1ñk<mT•ÈªµµõÌ¾“9Ô¼pêJ6(£cÊãq.o—*©ÍïÚš‡l}Cpüğm¶U«ëìüd±¢*CÚ0ë•öZNã~TqbÌ9ÃnáB¿‹Œì–º'¨d¥Ş¾¦ü/X’¦îI#<	—tªkÆÄŒ†?îtPÉgCXêûÍ10º™Ñª÷ò½„‚ñ¿¯-·VW¨³×¾¿—ê‹šn©ŞÈtU/Õ‰„±7Ï“ˆmr€àgÈ#ráƒÁ­ZŞ1 mAû<5Ì\Íaƒ˜WÀš|ğ°ÛKÛğVóFQL[»´0ô\¸é	[÷Æraß¿‹ÄıQA>SîbèĞSÃmíºæ¹µÇf¥	Õ;ù„™,˜R›AÛ×ÊeœòÛèOcºäŸîiúÉt
7;ÙÇ-cL â‹b…¶°ĞŞuç‘+z~Õy/9zÅ[#¸ArÌ»p±Å4ùäÇõÓ¥ôrkë"ßÖ´?`İ¹„gùàº7eñô/\50E^©wŞ{véã)şÁéõE¸¶›~W«-(\»ô÷ıgĞ_áÅö~ş¡°Ëk(ì2P¢°©yWügŒÿÌâ÷¦¿õ*A÷ô‹)ü÷Lqç™·I¢şBùé†£ü ğh‰¢„òs‹ß›şÕCişÀájàWó¢$©ÛLİbå-“`ë6ï~ÈùôÉA"³
Âm¬\k"±°ùP¥éµÆß#¦G(óÕtØy1CCj‹cÏâZµ8Oı(aÏgˆ.mW®Æn‚Í2Tüµş“qf¨xidÜ…µ^t«jTAl%açˆ—õ(•.4ãsãÜ«ÃQG^Á{o-\,›ğÌ1W_ ä0ëÆ¼ğÎI\–€thIØ+†úîí›áRœ"'÷Qr,w4Oæj"÷…87¹xWcÇï²–7æˆ¾(2€UEÔ‚Ş+´*²Ù˜qûìˆøW«Y%y¥p’}íŠ/U ¦ûÖáÒ2ªB¢yWRfqE§5´5£)Wr}€e§´ˆ3÷CËÆ÷"ÌhÅæ¤®Ç‹N·éqº‡?Üòˆv—ùß~Ú¹W64Ó¾]hÂ‚6³Ş‰Ì˜Ø=ÖK:şgƒIœQÀú@1È*fYºÚƒx¥uÑ sÎŸ.~÷yÏ¢L«¢™¾noÈÙG;­=pËn¤ÙïÄ‘ŠAÚÎÀÊ)íX•n –nñİ»Ò/gÒ&±Ş4ib0¦	%à)ºŒcáj©NhÑ$KX:½¦¬ZVÀ{£E˜Öï*å†¯ıš ¶`£>GÌÔEQlëŠÙ‹:W<EÕÀz©—fë-h¶±(ÅÓäÖ¶7>7ÌbQp¯ï¹^"ÍÿÑäF¼«œAĞu[ı“^.Y†ğ%tD¯$[†x FaG"õ:Íöa$´Ÿ+ĞÔu4PÏ¯¡Ûp
èå³6˜Ò?ÉÕ–ÀE›|Û—2&¹vAŞæ</Şšş!ïø"ˆ½¸xòƒêÕ« ŒÍ"ìtoò£Š¡ÕT
Ö°õ*aTùìcã§88wŒ/0’Û#ã>8°ÎšÙÖÇ¯1ª&õ®9À«Œ¬}ŒWº¤.Â{2/˜9åÙ$æÛ…ë`Î¯©Qƒ˜#÷;Ì5÷¼„V¶ì8Jğşë„wvP§£ @L}|7aT9z*s˜ôÄ0oF¦ç{g´
t-àyšğr…+_,¦Ì2º<ãàª–‘sÇw1½HXV‚´Sô¸*—8@D·ktòÂc|»d‹öh•ƒÿ¤À®ûvşlÛƒù˜c7…íµY°º©ØÈ³¹qóÖöÆ&^–ıæÛßo(3YÈõİöÖuf[GSGo¶n78,<ç&ë767îŞºÓ Á²µ·2ğáVAçW"‹ÛZü©3âĞS“µÉˆÄÈ+fkr²úŒRşDF>ÑvCBì.9 Õˆ[i?bŠm@Kâd’CİI™Üğ¬ÀK‘4Ÿé„—)øI&‘Ş{ÇÀŒ±Â~ 7HÏç,Ó‚6
cI}ïD±tÚ³wb±ØŸ¶¸n=[`ÜeØbµkmÑ
Z,nô<‚Ç«¿MÊQ-…‡›<;ƒ‰A‹{´ÿä!n¸òOA‹=*µeĞ"±àzÜ	<Øßâ„ÎÿMŒEos"»È|Âî»í©ŞÔ»4ûxöÌ©J®½Õá¡uÈ§i€q$C›ÉM&[–H©yj ÉË ¬° ¿Nòè§ÎdÂ’á|RBÈ??Q_¸&£TÏ%Û$Ê;&Âp|(ÎQTGbç£N„2U;Rz•XÉê|T}(±Ó9¼ÄÕb«,$#â~‚ƒ€"ÙHÓÈúlk®§SÎ”AÒ Ö£,)"ú¼K›h)Q(¿Ieƒa(¹Èäu1«š’W_T‘©m3òµuÖñ‘·Sg®:«¯:“kíuïó:‰Ì@şÔÑq‘Ş|×]×"‹1]“j!ıVG³—ÍŸn4¨î)Õ‰ÑH`7ù–¡J6ô‘£S„øøõ+µì©­qş6¸nûœÚ ¦1ïîî/ğH5<™COÍ@¿ashô‚6Ô¹úî¿3Òv³xÁ! }SÅşM.‡cŒØÂG‚\VaVâÅ|Î$“ñµ”ÔA¡ŞõÆhİA¥ƒEÇÏ£aŸŒtÊMctƒCAkŸkj‰3œ"·Phù‘E{¹JyğµœAZm´4Î°G…(6»-;ÿ‹ÈÔğôcÍn™¸~^ïAA¦uñ3<R_2A´x+)JMU0±`040031Q(ÈIÌÓM2ÒKÎHMÎÎÉ,.ÑËMaÈv-ÛëŞìÍ]qVùèCşˆÖn§ó—Ëx+)JMU07`01 …Ää’Ìü¼b†õ“æÅ¾ZÇêúeGøÇŠ«¯‚¨(Ï/ÊNËÉ//fØkà¯ï'nºíóƒİï|÷öÎá¸÷ñ0  ª!ˆx]»N1E©ó·¢A%ˆÜ"(¨è½ëÙ]+~i<›¿Ç6B´ã3×gîàÓ€ıöp•Œ½>¶…F&)êDì¦Æ‚!-f&ŠpÏoßi¼øÆx«ŠÌ«a‹@<“mÄ½EáKN.ÊmYà,…œ¤ÜÌF\Š¥‘{ú”p6Ş“ 3©i=äAƒ“÷ƒHC!>™Áy'—¶÷¨‘Ã>Í’‡HX¿ g2ÇşT¡˜C•LL¨/È.ÆÇƒ®ç`6BXª½šŒó¸ƒ¸@i•eç}¯Gáµİ¯&ofôq«'Wİ¤ğîNÕÚÕ/~}™2\ŒÿƒÚ©Õ­ş—M)Tb¯õŸÄ#ùÍ76z.x­VÍÛ6îÙO1ŠH‚lÙ›=4ÉF)Z @›ä°ÇµÈ6e«+K*E¥[Ô¹æúˆ}’|CŠ4åØÆÉe×Îï7ß¹,ë%]Ï^¾ü!èZA­’ÅJ7£Ñèc&iUïvuE)IñWWHÉÔÈ‚ˆu¦SÚEmU4şçµ¤ŒÚ¢Ú”‚Ê¢c¶X)ˆh—=ŞŠj£¶£¼« ‚cßB-\vy.äXÛÜ©L*óó·j=¦¦nVkĞ6N"úwDÄInE¶FŠ²6•å@€È¿genqò.SÛ$/ëZ†œ”óISzÑ„®PQ‘ShƒCÈõèÜè-grph2!—%IB:òŒRW|ì)Ö¦I©Áá">Ùğ ÀÂ%r&¸­™ƒ{±ÙØ‹EÛG–Bu²Òø3âµ)-&Ó¦¤-‹•®WQ"ESf8›ÎÕt3¦àÿÏÿêã(cF\ÇëC1>ªÌ’¢ÌTñQ8uFæfpj²µîIÈÄ­Èš~ôE¶rb"Sa@V Æ /s4‚#ÿ»ìAÜvƒ*òaLuÃdlMşXş	š'+‰0"´òıª®,yVŸ±“Äà¡B4«4zÛ„™©Ù˜şôŠ™ÂUÿ4¢ÎRQ­E¥k¢g)æ¢êvK!ÑëÙ×H™ì'ıpÛ_fZœñãk¤t}ÉÏ/¹ò\>ÚO¯‘Ò6§4ËŸçÕ~.÷óÙtÃ1øÈ‘¯…Ê=ÍháŸ€õZî„»L­¶V#¯»j}‹êŞ×0˜aÿ{[`g…h24!–"b¥›nûÙIçè#iºvkLõfØÙ}¥¢é÷³…å®×´@³Ãú›Ôèßôü9ì!õ74³ùĞà õã›¥¾VNíşºõò•;_pÚAËt§íJ¨ÌTa–€…˜x_÷í®¨š|,ù³Õİw‹¤µĞ$ª¾ÓƒF½ÈFàé€¡a½¹©AÉv5~‰XãòŠéÚ&_[aJ®n¨  néÔÌà$-Ş<u>T6ãv,1şÀ¥½á4ø„~ºñ7ûĞ'Ëı‘Ï…¯Â|;«0ä*çÌõbØ, Êé‹ÈÆ€«3ï‰ÛÜôüÄZµ ™íÂÕ-g¯ïULW‘×YÓvÛöX´§ oZ‚íŒŸÁ¼b‰IƒqÖTæ’<¨}ŒÏ”»8PÍÇâ’ÇOØC§ıãhpµ<ƒ'Õ¦ú‹)L0‰Ãzø,¸ø¼îE	Ö7)øƒe`õº<zL/BŒş¾5«CoH³¾ëd ÄåÉğıäpšÿ&ƒ½=y2¾ß:n"ú‡…áª÷*«~œâUÆow~EíêuWò=×ÔRñ…é½vnF_ ÊFÒfx+)JMU0±0`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|!æ$eæ1py=h‘§ÂõõÜœµÚ/ş.<î4ÃÜÔT!)?¿¤¸¤(±@· '1O7ÉH¯8ƒ¡Ö@±¶Û«m{ÑTù°âÓ«B®ÎëmÃ£^/?'…Áfñ5¶<™£[„¬[¼#^"g·9Ä)ùÉÅ%e?³É$ïIÚ¹1§YøÇŒÖké¼ü”ÔøÜü”ÒœÔb†Sâo—^:ğmßÿ¸»çO_¿èÿ¨êÛ‚ÄäìÄôTİœüäl½¬âü<†ï/Ï×%ªÒX*’"|¸¹ªğbdgªbˆºİç¼D²‡ø¯ôëâ?äúhOEÄq˜:¨§+ss›å{İŒ/¨}ÜğÃbı¼	aÏfÙéA½]_\¢‹«ü‚bP8q¼Ÿÿê‹ü£‚…ËÖíTy@XYâ©âä¢Ì‚’b†Ù5\'¥W·éâ|Ne×cIœî KÅÒxu1OÃ0…™ó+NbH+¥6M…„Z100€J;„êØ—Æ’cÛQ¨ÿs
Lyö{ï;_*ã*¸,gœÃ.
«„Wğ|ó°ÎÜï¶²ÁV°Œü&ÆnÉù0ì(ZÃœ?ğĞ¡äsV‚5±5çZ•W‹r1§Nªm¶·K‚Í”Ã ÖE}×9OßqÀ,t­%Dq Á™>jg“Œ^Ë¤ÃøŠ+ 6:|Ô	'8EAPXk‹
´¥0ÁÏ‘`#ë.‚0Æ„èÛ
}HùJ[á	*(W@ö›Ş˜=Ğÿ!ù´^“°·é² Œ’eY–§àéùŠÎ­S½A†ïiÍ ×´Ê[¯=NrÆk¡M5æSò#Z5ùÈ tÛ-u\ÂàWñxì§ù´øÛ¬œûßÔ6ş[¬äõ5ûœ®²/Êª¡xu=oÂ0†;ûWœÄàDBv›V41°tj§Lup’+±dc_š¢ªÿ½G`a`»WÏûqµëk(^Ë­¡"shMla»ùx—	ŞŒuÉ|!¤¦Co”`OG–Zã¨NÆ;ÕÇ½Nı¤ŠéPy7³mQ>Ï/!„WP´Éëo¡šaƒ˜I¥ôeFæg“ïÛÁ¡ÂŸĞGJl<àxMe¿€³¥%ìXÁMj”ùüÃã]æM9Ç>Å?òVõx+)JMU02·d040031Qpöpôswõñw×ËMaø¯\ú ô®’”Ä‹×ó°[Ÿå2~UçãéìêìÊÀyyÑ¼É•çİ/®Šø-scrC×&¨’ WG_W96{¼/İİluHq[»Ge¥XÖ¦ó.J&@ ”™ÇğáqÕmù.ãş ‘„Ş{¿.H¬2îP„È¦d—0ˆ°LºTl‘ß¬ş}š‡Ç‰uáŸ¡6dæ¥¤Vèe3ìÙşzùÚå÷x×…Nra>2‡Olİâˆ9™IkãB=W$¯zÏ/}J¤åğëvI¨	‰ÉÙ‰é©@3òóÄÃ}W°.l0Z¹ıhË£Çs3â8Ÿ  ?p“x+)JMU022d040031Qpöpôswõñw×ËMa¸cù63èGÕ›‰Ê=ş¾h»q4T§³«_°+CÚâ5×5/İûW‰A×d_ä²[Ÿ” J‚\]|]Aæ„rÇÌ®fXµ°{‘Ã–Ö§›Eg¼gÙU”X”^XTœª—UÌ İÓ“,^õ³´ÊeRÎ«í7Û{&·› BNfCÏõÀ‰3“¦TÜSğß+Äaòô7Ô‚ÄäìÄtùy)µZÿ%.­á>nã&ñ`––÷÷ÍY bYRx1OÃ0…™ó+\1Ø–R[”
!ªt±0t`l‹”ÄçÖÂ±ƒÏ‰Š(ÿ»´beğâw÷î}¯±¾!óÛù•”M×[ jè­ië¤İCû¡¸ÈƒlŒ“àFâ¼‚¢õ#ÑH*àc0ÕHùâ¬t*)E€Z=¯Ÿ®e}ğ- Š:ìÆõl{<Rå[”½­İ´™‰Ó=k0ŠNÑ’QßS.0Å‰ŒnÜŸyŠÉ¾SB!0[-åÛtƒ›uz[)"`d–sÑÕ}­ÀÄì‹LÇ8/¹,³±4eÍ«e-ŒSpXi6òIU™c4ËÇ„·‹{şE2··  }º”…´Ì“|A.”pH¹oÒÇ÷©“¼eıÑÇ\kÆ$«—’î·f•şCtN²(~ Ô’éx+)JMU041g040031QHÎ/JÕË*fHèV»§½kšôÛ\G&J¨±«óÿ…*IIMK,Í)©²úÄóÄÆüÊ‚ëåî"óuØÖCU¥%fæ'¦Û¾ØnûÂ3¯*vGİ\’ø´òG•ÄS!¨²¬âü<IÛm¿÷
7Ê³Z•ï>µ8}µ†e` :÷xmRMoÓ@åì_1´‘¼–Ò—JU‘€¦RĞª	pÙØëx‹³kv×(¶Ä…À‘_×_ÂŒ¿Z!|šñ<¿÷æy6¹ÙÀéógOŸNJg'¥'Rß6‰b£‡ÔÁ9Xù­TV²0uatÖM
á³Ç3êiÚßM/¿\Ìnn„ËNîD™ûÉNz‘/Âfşúfv½øÒÅVŞÀ«‹ËÙÛé?|J'ò;ß%ë„¥öVI²:n¥Heç?tÌzGOUî¥e)œ¿€”K¸OÊg,ä·Îè0¢%réÁš=Ñ,WØw¬<5v*âŒ!…¤Ï@›m†è7ó«÷¼ÖIÖé_"´1@	ñ[£ô`eÄ!,}zÚ(÷tZìP ˆ•·QœR‰tq?£š‚RFCUÁÑıÏßGH/¶´khš1ËUÔÚQ—í%s¥¿"x½H½^±îLºÑšÀ/J—±u£}UUd¥­H	«5’×'aJOôÇğ
ï>Ò=AóÆ?2\<^d½
ª“îŠ¦ïº*?M¬ágü{u€.Ì~o•—CøİùŒ]y·GhrÉs³eëû?¿ ?((¼S™ÀO—kTr©·>«¡Í…¹ˆ6şÂ‰Óx]PMK1õÜ_1éfa»‚ˆKŠ
=ÖBÓtbGÓdMfÑRö¿›ìJm=%Ìûš7kë×ps}{¡½‹&‚„€Ÿ…‰EÙÀˆhğ»Wš)i®2h“‘Ö*Ş&ZÖoÈÏ®íXz‹úÃRäYÆÿLY…DÊ™ÿÄ¸Kául-%ı«KC–1ˆï-*wL´ä0;˜XT›'²ø²wZä¤ªèØÜû4`‘aC÷Ò(±™µñáQé­¶¢RÎw;YÎ@FØšíD)åjXÂåûUyL´”6íÑZ¥ÓBQå÷{™k±:lzèËTb˜Àtš÷ÿ
©÷yqµwOn¼BRü ´‘^xKÊÉOR06gĞs	.É/JÉËËOIÏÍO)ÍI-æÊN×-J-È×KJ,Îà a™¸xKÊÉOR0`  	°ğxÍYMsÛ6í9¿BÃsù~‰â­Msô%“S;i"!	6DpÈ±šñ/H$%i3cûàKà½Å.öa½%t»Z‡Éæ·V+« 9bVºúGü±ZÕCõ…s1f¹zDnYÑæ;‚K—#Æ]–U¸äÌú]¸E¤¶Ìğs‰ê‰W(ã´:[Í7Ï—O'íVRÆí-¥œñ
–6-™ÃŠ½vÉÔ}ÍğèÏ³`%@‚u°îQbüæx‡Qã	ßó#Ûm?øÂÔOR?r@üİ-Ep>ÒSÁÅRñz>M{ë;gx$½E¥gKå´™T’éœÂĞ‰‚µ†ˆæs‚ÙÜ#çÑBÅI9mæE)yQ„ÎÚ5”â—2²	Í´T6fnÉf&9mÁlv9ÍTY}=,9¼"¥»l–aÍ%¹"FÌ¦>±ƒõD§i¥~è€h"xó½ª¢0‘igff®ƒ©©.òÂ/t,£dvìl±*Å¯F%‡×Ddûï\ÓVŸ­br=?úã¯»OÎQŠ9¹£>Á&–äâúòêBo"ÍIÅ`öAİÁt­uàpÊLÆâI·±™ğgsù©7\Æiùòì –ãffáDâşˆS8À5çµy1ÅêTØû
¡ÂŞ¸ç9bk&<ß›q¢ÀIÀFÃ6ğfÓ­k+«Bv@ÙÁŒ«“o‚­™näÍ}B Å¡®6øóÙŠëÑº‘ÛÓ{U6Ø™YM;ÔFÛÖ4#]qº…2z,	zÂü,4ïçÙ‡]ÓÚ‹ˆÀ^of&%ş¤€–Üõ¸—¯æŞ+—‹ÌÆE„¤­k:S³’Ş±¨Û˜¯é sæ’>Ğ¾)»ª>|xJŞ‹(
·@ßíK©P_¯=$S‰çº¾ö™]ò¼îæ×ıú#â0‡ÇÚĞJÒ[Æİ—ˆWÊªÖ¡•Dñ¶N>ÒüDPºS%lP¢EOU$¢© ¾kƒü\¹„\Ùæ¸~ñê÷ÌÖt3ó÷Ø0ÉÓRù¼oÅfz•£²çH¹c³ÎGZìğ¾UaŠÄ]Yd¸×·ª{V²›Ôô¯
xlO·lšÉGT1,Z¢1õ¯xí9^»z3£G1Å«j*Z=v©m«Õ×K¿¿Ö%ÅBù¾‡B"°=UY³ÿÄ‡ÕÕ£ñ–›FèVˆ@.±.ë52Zpˆ¦²_nDv.‹ğ¦!ağİ™¸,¼ëG¯AÚ½12½ìZX«†ÚT´L9Ñ+õ¾0Ş*œw…N#hŞÆ¡ yWğ†JeaxãÅ.]Òä	>–´ÿÂ¹”³Ëëhrõ2\Y ×Jfq(ú;j€¤/ÌŞÇ­*±–Ó^¦Ú÷b[”~y¬ÌÇ²H¸ŒIĞAXã¢9Ù7¡;øáù‹ö+¹x+)JMU024e01 ½ôÌ’ŒÒ$†·ëgo›UÀ*#œâòèò“¹ÖoÌLLÀJ2Óóò‹Rf:_¼0±}î´×œFùfY¶ê¾s’2óñÌ¶ãÕì9b5ÅuÃî	¶\}@3ÌMM’òóKŠKŠtrót“ŒôŠ3l?PcË“9ºåAˆÀºÅ;â%rv›CLKÉO.fØxæíg9FÁÃ·&å}i·yËßÅéâä¢Ì‚’b¾ËÚ×]ü©y¡âÆñ´Å©>»ÿ
 ÁuW§x+)JMU04´`040031QÈÌKI­ĞËMax6÷ÑìM¯9{wk®+ºqèIOğD¨š¼Ôrİâä¢Ì‚½â|
‹+ó’u!&f3dîùà>éß£¼%Ïtæe¦¿V[wo	 æV7bxe=Â0†]Í¯8Šƒ"© èPqÔÁÁı’\iµI¤Iıø÷&)TÁû|ßG4VÀrµ=°k|ÁÆ[’•…ì[Vk4ÊÙ° Ğx#0ô„ÓîxØ”Öæ®‚ö-¡'p²­ïæ É£B¡to#¡6Š^Ri¾ÁáL¢«Õ¿@ÙZ=¨eŒ÷€*0ÇÄü"Lyï‰&ÓÈ7c,ê‡kcı^Ç1ODùÕ1öNRx+)JMU054g01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|!æ$%gè–%–æ”0Ìx¾¾b®Ñ›3Ël¬íİû'èĞ¨¢Ì<.¯Í3òT¸¾›3£VûåÏß…Çı€™›š*$åç——%èä$æé&ég0Ô(Öv{µm/š*V|zUÈÕy½mxÔëåç¤0Ø,~ Æ–'stËƒu‹wÄKäì6‡¸ %?¹˜¡¤ìgÖ#™„à"I;7æ4ÿ˜Ñz"—Ÿ’Ÿ›ŸRš“ZÌp*PüíïÒK¾íûw÷üéëıÕAƒ¤ 19;1=U7'?9[/«8?áûËóu‰ê‡4–Š¤n®*¼ÙÙ„ª¢n÷9/Ñ£ì!ş+ıºø¹>ÚSqÜ¦êéÊÄÜÅfù^7ãj7ü°X?oBØ³YvzPoä—è"Â*¿ NÜïç¿ú"ÿ¨`á²uGg;UV–xª8¹(³ ¤˜aöAÅ×IéÕmº8ß‡SÙõX§; Ú~×Vx+)JMU0¶`040075UÈ*Ö­LÌÍÑË*fXØôqıÑsKl3T¯”¶a’Ñş¬ cïYx+)JMU°0e040075U(*ÍÓM
åé¦å$¦ëg0<Y|1v;K¦èÆ·ª¹ÊO2ôNR‚*..É/(O,IÎ ©k_¾íÆÆY‡ÖÚè2­¼»ÉX ˆ"çx+)JMU055f01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|¡ª|³SÓ2sRV-«Ô=çøµq«×âÈÉÙù—j¨CìJJ,ÎĞ-K,Í)ap‹‰Ù{¹LJ_H­9vÑ[aùâ÷3û Š2ó¸¼4ÏÈSáúznÎŒZí—?÷Zcnjª”Ÿ_R\R”X [“˜§›d¤WœÁPk XÛíÕ¶½hª|XñéU!Wçõ¶áQ¯—Ÿ“Â`³ø[ÌÑ-BÖ-Ş/‘³Ûâ‚”üäb†’²ŸYd‚wˆ$íÜ˜Ó,ücFë5ˆt^~Jj|n~JiNj1Ã©@ñ·¿K/ø¶ïÜİó§¯_ôT‚ÄäìÄôTİœüäl½¬âü<†ï/Ï×%ªÒX*’"|¸¹ªğbdgªbˆºİç¼D²‡ø¯ôëâ?äúhOEÄq˜:¨§+ss›å{İŒ/¨}ÜğÃbı¼	aÏfÙéA½]_\¢‹«ü‚bP8q¼Ÿÿê‹ü£‚…ËÖíTy@XYâ©âä¢Ì‚’b†Ù5\'¥W·éâ|Ne×cIœî š¶âGxmSMoÛ0İÙ¿‚=ÉÆ\-ÍnöŒ^ìàÛ¥‚BqäÄ«"y’Ü6(òßGQ¶“ ñÁĞùøù´Qf‹å÷/lpœ·]ãY™$oÂÂŸc/¡+ÿ•)ãü›Ç#–÷/{áêwıËš^ZÄĞzóW6÷ÖxBùuDI°/ŞüÆ:zñ»‘6E`¡vĞïŒFÎ¨7ù,ª>ˆ>İ
/2øL ºhUU”Ê0ØVƒ·ƒD€ Ç¹ŸòèéjC§·ò#%õÎïsèEgãcââI¸°F€ğE L¥	¶5R‚ÁÓÅ…ëÊ#t+Á±Ô´ÿZÁCT T|Î[äº¤ºVä÷­P.*Š²ç^òF(•†Øî°l5²­IõšÍ=¹„ ş!	U"Ib11\Oğ\fîTvNˆ)wgÆ!Îìã8b3$J™5’ŠW'Ò}
s»8öRF0@”¦Ë©{uKİÀƒŒ|q­¾ˆé·Ÿb£oò!WnÂ“Ù“Ñød†Æßpå˜¼B	Æ„Gòè¿2A¤ƒÙJrùÑëƒ/µ|§w—2/vÅÍÎİåËÅbY´=ËÉò¯¨± æğiJİH,:>bZLœÂİL´8/§ûä„ú?±îJx+)JMU06e042 …¬bİÊÄÜ†¹{yİ™3v:‰ôì|cuéúª““Š{xKÊÉOR05`Ğs	.É/JÉËËOIÏÍO)ÍI-æÊN×-J-È×KJ,Îà±t³Óõ²Šóó¸ OZx…“MoÛ0†wö¯à.µƒ^rêÁó¡‡®x—¢ÀƒãĞ®VWÊôQÄhûßG‹VjÇ–“E>|)¾¡v­ÚÁz}yù!vÁX-*gQÕNVV(	ÂÊ>Ù$Æí~ceğh´NKHlw@UÃƒ<Ï!vrµ¸ğú
¡Ğ'¥kÛE½M[|÷Êüåy’¿¸x—ÿH½ÿ%oÕ•Öe—üãPVÈò¢†ÄÇSaÎò‹0]¨Èh`lÉ ¾hdH<lïÉ»“9[@ñÉÈx´(÷‰-uƒv	F9.ö\jäàq	-ÊÆ>,á»À|ÃÎøıUÆe0ˆô äÀ¦TiæË j¥iˆ¾a«Ğ„¾Y­¯O¹qÆ÷€/ÃEÂùSk6èG-&Å[¯M÷I qKÔı	ó'Ş#gN1~æ–Æ–6é×S6K¨”“Ãöfi4®µ$Ç”ëªı¤~N¤Ô*ãÍâ«Ãq<Ê C!nÔ_p|5ÎŸ]¶›ÒŠgü‰Z%Ò=íPO˜c~ûW¼±…§ÒâúæêvswıkS|İ›ÛYÃgZc/Ã½ÔŞµ˜âñ ´5´®Ãƒdó÷šE3”×€I²AÌÈá ‘C`ò_890ã¦¾øÖc£f<?ˆ‘.²è/D3xeRÁnÓ@äü¾bšJ¥¬}Œ¥R9 „RÄ!yí}‰ìµñ®SÂ¹œ9À©Ç^9Âïôè'°ë8Ä¥Ç}ogvvfÒ¢J1NŒâÖ6qªMÌfƒTÚœÆX²ĞF;-ı™árÆF¶…ƒİZÇåµtYå|öl1Ÿ@å7&ƒ6Š?YvÜV¨uÍ+©"Îò
£Û«ï×x°Ú¬{xT*è³bEÑˆüéë†kˆÇ¸½ºş‰§^Ş£òqĞfÈ¤ÃÙÙaÓÓãÅlùâ˜HAtŸ…hÉ­•iÁ^öª‘Ö5mæÚ†a³F×ÎâB»%;©¤“XW5ìµ$Á%Ñ9'‘ç=¤Ğ›@‡·Ã+=_œ¼{8 î§'¾èAÀÛ{{ÿ1üŠçÁzhÙºJ¬Ùp#İNî1]DŞó»böÓ¢×¤R]¦İÒgsÑ›òˆ(Iº¿Q)?p·y9[ÌŸ”[±ûPäûÓ­B!Âe
1–}L»Ü\şşóëë ,Y4,ÕÖ›mœ®Œ„íû°Ò‡ş|»Ä¹'õÙi…1•â®¹}&áiß_oHôŞî±7?¾hƒS‡†+Oò$Jvx½VÁnÛ8İ³¾bÄ•Ô:J6À^¸A-°Àb/é©IĞÒØf+‘*EÖqıûÎˆ´-96°½”CÖ3oŞ¼jVê\_ÿuıÇå%ü#+i± YÕ%V¨¬°R+Ğs¨×vIO#h¬‘jºF#¬6ch\]kcĞª\Ã¨¡
˜kJ¯"r›h»ÄîM%h£0H®¡PdÀ1Ìœ…J¬AÔ5
RAî«+°HP„Å&¢˜tñsGQ®UcaC{›s-LÁàw'&±³²ŒéHTéÂ•˜á³Ç8…¹Sy—TãfI-¬E£ÆeÙQ:
›h•hÉÛŸÉëå(¹™$£ô%¹Ho’û·ôs3¹O’ûÕ»ô>¥w.¾ˆ‹Ÿiz¹ˆzÇWZ:¢d)•“Îïx$yƒlK¢ŞˆÒ?ãÜ>ŠR.™jQXŒA‰ŠÈ"f‰Ç-RF+çì=¤„Ü:£ OlçÅy?¹vŠ]íŒÁ·÷=óI6zv²ÕÂ.a:¥Ã)Ø¥Ñ+P¸‚Ïë?£MseQi·XR¡UÔtbğ°ƒ€¨8ìz»€…hÍRÎm2ÜÉ`ÎşuÕM&›¿•¥"*$äKO {+ÁX¤²½èí!’÷‡bÆáŒÒuªÀ¹TX²Ã¼’8ûîêaç‚óc7–ø¡.êö±·XÏ¾’hcxy	‡é¥rey{à.è›Zˆº¥®©{™lcyĞÔCîOJSçæKø†ë	ÄçN´Ÿ†d”»¹cû>¯°¤fô½²-âoĞ‰tB½R6+i)¹äu«0Ø\ö¸‰'ƒ:±Åû¿íf\B†tğ™AñmpÎ{3'½…õkîŠw>ˆ<xË€zòbôºT×ñ¡Ty;¯c}û4:ßx¶Ú0`&¤2ïˆFĞv´ò¢?ßESÈö@4¡0ÄoÛnwÌfV’ÏX$Wéÿ!™šOĞ4}]±£¹8n%º`BëäKaDN–ÅíË½'f´?Pà=»¡ÖÃ„å¡»ÕpÃYftô£*R˜lM·V;4î¸:ÚU!yŞïëZºß˜ÙWm×ÇúÊØÍî?áÍÜ­Î²L´aoaQùé4dîö0‡öØM†cEê.
Q–½[‚®ôhø¤pİW%Í¾\v8î¼ÄBÙIùÊÚè?IÇ‹5xµVms“@ös~ÅvÆ !„¦¶µÔN¦c3N;:6Î¨;”\”@„£i´ıïîŞô‚1úÅ|HàØgwŸ}yÈM’İ@ÿp÷‰Q
Ç7[­Û0‡ÑjÁàrö½ŒsfÓãxdXêù§Ó‹7×g§£áõûá«áÇwh›²%¼gÓáİÂl_Lßí/Ë€úÓ^üİ V,Ì	ÒÕ ºa 	é0ÏR>ûóó{4®¯(Ì^ ãp%É‰äGçÃËÑéÅ»ÿÅ`°‘ÂvÛ0ŠÖÉxşˆ÷>\]ñ ³!ˆâ8UH+êf÷ªªÏ˜e¥h„§a6xÇÂJûØˆ8-9£8ÿ
: `Q–ErïêÊ‘áÚ–5ĞÆCµOF:`’‡³TÁ$ù¶ùùŞô»ÀÒR&šö< şü#ú¹.âiŠóæŠ›Š*Ör-qk€Y4æHŒ)Î)úPt[“2Éà†YrË>…ódÏYÁÃùÂ‡<´à'fO@ÜÁÉ	nH™$"x™§0	“‚+“æ:9ìEÊÍNÉórØåB¯§ñĞz¤„½A1(#ş'R$óG3[¬®-·Ñ¦³Åá‰[uÚ®›‡:áÚHš>c–ğ„ËbSq©'â¢Bc‘)š‹hhº¥NU)•i]´5è–J‰8Ô®¦>Ë³¥P·ag¹iœaVUßÑ™E 9`¯V5ğ+­zT EC2
U9’¤iÇıÀ‚.ì“Û×—ê1ÎWÎXÆhê"K®AöÈ‘Šÿ½ü$iV­7T#HŠMdLúr>Œ^š¤Äz;-‘Ç9¥à×û~½Õàë»Š@êª–#&$ØŠÑÎ÷å¹”íü@ã$)%túTUœ"‰#fº6ì‰8 ËYœ00+ùp–N±z/Ğ@Vf'IÜ•áWóÜ9ÃÅ·"…{híTNéy³JÛµGd]Qd×$£š¡Ú
­¨_ŠX-GúStz®2©VÌ¬ü´áÀEm¬¡Ğ	~Ä˜Ió8ÅõmT¤^ÒRÒ2£kXõw°.­-æô÷ñú›ZĞøae…ˆ’X`DšÔ‚qÒZÒGæLÕ-‹HCb”¼‘ÉqKW·œ-P³YÚP·ìæ+‹8ôÚ¨Y|•°vO™ò#;<;¿|{‰ÿ”Ò©‰qĞï<—	CÅ]d´˜’5ı{2N½¾œ,ŸÚ}×í{¼zC¶˜àoq:öÀ(¢0	sƒtQ½N¼êbM‚É gïñò7£<L#övâ‰—oò½©­dô½İ®xKÊÉOR02eĞÓÓÏ*Ö­LÌÍÑOÊÌƒ±õ²Š¬,
Îxİ[[wÚHŞçş}üûŒ,g’L2gÏd[gm`$“}Ğm„Äèb†ùõûUu·$NìÌfçìò€Ñ¥«««ëòUU{šdSÙ¹xóæÕ_<WŞ£ñ ü(Wr|ãËÑàjüÁ}ñ×G?B·å2Kå&*ä,WQ©æ2Ne¹TREy²•·oÏ9İÊë*gò!Je˜Eµ’Q)Ge<[–qºw†¬¢2.fKÙUi™ããî‡À‘…RrY–ëwgg›ÍÆmb7MNì,}…y¥óB€‡HÕl¦Š"ËevK<YTÑBÉY”$`Î»ìºÒ0“cÆ8-¤^Ã‹B¬ó8Åë(‘Q…eåŒü­K—˜q–TsUÈU”nå,“ñ´*ã$îól%3b¥p…RZ÷+ÇÌC¯Æi…Ù—q!7YşIBdFrI«›åë,‡ ğä>ËEŸ‚“P$¤¤qãî88îöÃ¢IóØÍUQf©û¹Uq"° €|ç‹8#¹—©’¹JTT€­B=¨sá»àå@t`JÙ}¹‰r¥—tmåÅùù¹]dÎ¬›…Ì2PƒR’­WØAYªh%WÙ&(3q©k•º3È©Ìh‰øôm#ŒÛhZğ0ld8˜•ÙTñFÒ«E´Rba8­ië!õL²/â«é’>Òr,Š&§jF$ş™­wä­'ÃÊ:mÂrd/¯²*ë9®X#idaTrÍ6àfùâl]ÜŸ°5Ğ
Õ$Ó,=]çÙ=T¯Diü;Ö^ŠµšÅ÷1)è–d“m¬rœb‡Ø¤‚´TPßYYa]ÃÈË­ûÙJxb˜À‹Î Ë¹R«–Á=¶ÒK@C›­Ñ Øöö«®ò™’Ç{V‡A’Ñ2YCiKÚCzêêE?Dobh]®å`oŠÒ‘0£„Q%á@Ô,£…'E†m×ÃÛSèÊ¢š&êgŞñ2ÂO<N²Ì|µŠòøwUbä¿³ª°*MF(ñ	µ†ÓOşôTû™óïĞ$s[6)ôLhflÚ¿lãöâ‘¿Ë“ÇÍÅ¹ûÖ=Ç
òJvÜ‹İ‘ğSr¸wW?ÜbatÑq_Ú‘¯hl› £±oi,‚ÜŒ}moñßË$ø7²}Ø›f<ín:nCª=´eÕØZÃñk·Ó»7´~ÔËã‹3uı
S+?€Ó$#µ¤¡Ìö§¯îLı”¡VXngolçKï±iÛcÛûÚ¦…±õ£6Ëí±/ë…HIcí€¯½ä…£)¼,hìÍÛ9Ma)øìÏ+®²¬„%ªâPÓ=k“óLé‹Şáº\"DmÔòî0jóàZŒoT9oÙ!ŒÆßò0I<ƒçPğÁUšÄŸ2Şrd¢J¹Íª†¨b*œÅîVjÂ‘ÜÄ„ÁNô‰|år¶D`‡Öc’Æ3I9FĞ¢ïzi™ 
ŠBù„ü
¹[˜ì4N•]MÆ48šƒ´ZßÆaÍ±,Ü.G;(  >-½ââœØÆT!¢P”Ï{à"˜3)6È’_ÜåÚa.(fU1]ØeÈ%Ù2ƒl	å$ÑFÎzdßš)h¨°Ì6äzî m¶X‘+³dÎ>¤¹ÍûÎü1ğxDLÕnùˆ·ÆÊ +cW>5¾Ç8	WÄsxè,©Å€03L
%(„}Ö’d€6s:ÂA ÃÅ‚êHa7ó‰KWığn$½~Ovı^0ı‘¼„ÒëvıÑ(è_K\€hÃÁÈ—¾5ü8¾ô¿ mÅ¼íÀ¿L§ÆÊ˜xÒïyÄ„¼º~¾÷Ã]_ˆÓg|„è`m-ï:ôı;¿?&}™ªrCq’ŒÎXâÀ"`ûG'€!¬é<~ˆç„# ‘-<"nµ±ª£1Š&½ÅHÁŠ½‰±UÁºL|Õ¦IN`ğ¦6F¢³Šò­ÆzD…t84ŸÆbÛçÙ¬" Èh›yáÊQ5ı6ß*P©ò†€u@è9cX<aS‹fVz‹\)¢L@àvº‹<J1]‘†aê7 øÀ‘y¶¶ßŞc0ğa–'óÓé©ñÄB® ÛæÕL9"J£dû;Ş„ÏÄDÀ_Œ`ÁÚ
¿¸N€×ÕÃ“-^ÀXÂTpñh”½p ŞÆ‡‚­¬-Úz+£$ƒGeÈ“’ã$+6’ fmÛl²Œø3éğdúÌØxY¶ŞæñbY:"v•ëÈ£®½#g'÷Š)ñ÷Kşş‘¿‘İàşkş~Ãß?ñ÷[úîœ;ß<¶Ãc;<¶Ãc;<¶Ãc;<¶Ãc;<öâü
ı3£×X.€î
•Î1|ÍU‰lz™‹øº!EŞ¨9¥¨VY ‹/]J@È¸à5‘ËØGvc)Ólm
çt,}2MÎ©²TğşÁısb‡Xe¸ÂmÚSè§~¹Êîµ*lXe×cX»?EôÅ	£`¼e¢¼·UVşaŒ§¢æY›„ŒÈPØ9›LÖjRæ¥NK#9ÍcuoĞõ¶ÆlØ`»Š` ˜Y/búÑe›Ã¢Ml¶‚oóYó—<qäd0:S\ `‘ÑŞy÷G²?¡?ı|»Ğyn” B¯?ü‘#ı_è1İÁİğ6ğ{ pùïpÕÂÿÅÃ]ß‘—“1¨á:ïMJ;‡z„ÑFİ[/ààñqoæÖÄLùÎ»7àÂ»nƒ1n…ò*÷Á‹àPÓÿ(‡^8º“[/”ÃI8Àóã­ñ7æjÊ„®¯¤‰‚Û[âPı«!ÊG ûˆ÷‚°Ç„ÀOp}3AÆ¯´ŒG7"/}¬Ë»¼õåx`ƒÏE$8Î!Æ!æ4ÓÕ<ınĞ#é†~7 à‘säÿc‚'¸#{ŞwıÀƒÛ¤í„ùŒ&·c¢y7èWÁ´#!Âq@Ú|…÷‡YGàq×óÃà=¶ö=xG<öÈ¦ı÷~_WÒë½GxîÙê8
Œ´Í»Æk÷?ÒZ”m2ª"™\á!¨DÔBF‹Å#øã(S” ó%“…ÌõÆ•}ØÅ;¸”Ã1GK@9Dcx!ªt˜:Ù8e·İŠe¼¦ÙPˆJg`ûÈ8é¶Cnş_Y'C¦BĞ°±,ƒâ¦5 èºŸ- ;CH{V1®ÆPAJ”9ÌI3 ¦ä+™¢ Ân@_ÓSTƒ Øi!*g9~âmx˜ò
:ˆî‘ó'‘-‹¼òn€.­u
ñ“+/©d¶ŞBš&,“dA§é–ö!NísEã¸ ç)UcÈ[“s>´sû AÔ ŒˆK0ôûnwpgMG6¸ŠLÙ(R¿çÀ5KØ§I 
'a—ŒUãÀf‹;Oy­,ûøH_¦†&yEˆ4÷¨¡|RÊÎës9ŠPHÌ‘ô QpÆ%’İ÷ÙõäÛWç¯›	~@Š(W~&Üß6Š6&„Å<
Ùè (v€ `(í¬³G'Øµg"Ãš¢U£F¸i ¢<O¬(‡!ÖCXò¹X±•ófíÀp(KL¨œ};b$BeF‰FV‘²ØG_Ò¢¥èÊÌ× ‡İÕ<?h‹ş¯@ˆı©ş4ÑnÏÈg`	à5³†oƒ˜WØ¶Î±Ô¿	T À6¨à¬Üi°6º`e§fÌ<!ş0 ¸z$¤şçñÄãØ¥ÔñrÊaßÈ;¨)Ši«!fRP¿ Ø„@*şpJŸ‰TšBİ(‰‘Ÿ¢ÙãHöc\€B}ŸÄÈ®êigÜï°ø¤c:àtKÕ™ç#a‘ñ´d‹$
vÄç`ÇP{ï{€G|ğx(üÕ€U8*[ìÕšJYº±dB·8G2ÉŞ«}]Tr[i§«„l¯ ¦Ù¿ì.ËU»%Ä	\‡Òo«ÜÇÁ¼G¡#^"¨«¸S@²õó nŸÈÈ7ÛjÏwÂeÜø)µ™.E>±‚öD`EÛë¼JÛyT^Øï¼¶@Ì¨]?¡3„e¢Ñ*?,cXaMÑĞÍWª"o;@7´Ò§UäP½³Ö°_‘ÛG_¶¶ ëÉv¯ èèárC8{¯·‡Â¾C9V*Lñá Èj0Ö£õ8eó‘¦÷Æ"Ÿy°gË<û5´%TÓº÷uÀC…¿ÃU9’ŠÛf?›¢%±lï‡êròP]NpçŠsj/Çöµ÷gîÌèê«÷«gZ—_´°ı™ƒ54ê!xQúMQäI¬*
UZÖÑ·q¹ÕvöpE5-Ê¸¬`Ld¦÷Y‚¾/å;¥ú­”ÇÙ*.éè;½_+jf¼“¦İôU¸dÕ¸X=X`­3Xİe±Ù-”ê”iò‚O p'Ä†Ñ’3n:ÉfqÂ
eE’
z_¶’ŞZš¨ÒøWJØàÄQ+©òˆ/N –ËãOèç¡AÅG4Zæ‰ÂŠ;ğ=îÅÅYç¼ƒ¢%£™F¤,HÓT—ÙÔH¹‘‘ªş¶å,´9D4Ü‰ÜÉIxûÎÅYÎWóàb1gm.^¾gıTKíÿ¢ŠªU"6'µ£œk·˜jì°†	¨ÌÔ†‚m;PRe:u­ó;ÖTw'úÓÒ!S³Ñ‚zF:ôÏ+ø¶dHÏŠ6µpmø›’¡?^aÕZô?[g}$;˜q0PèŒ KùQ}.
ş~³Ür?Ü¤DœH‚ïåÌÁ^7>(j˜3€ˆ#œ¹è(£	s©’cDŒ‹/€ğº«èC~™š&bâ\yoÆPNUb£õšÂŞçIZ7[­²t£èd!eböX^;S³÷ĞÇk%m¼.Æ:iÈÙh¨¥¢€§#!5[ÕÕdTYéò²8 ï{½$Ó§ğ ¦i£Yw±Ğä7m+”•ÓÓ‚šdÜw²%t“PDthR=ĞÙ+^k°”mêÓf]÷'òZ¡ÜMg×¸Cjı—<Æ‘2ñg¤fÓöDÔœ\Ôú “d‚§4°ñ²Œğ‰xÒ¢ByGÃ¸i­ nÁpÉˆ!Ö|º^ıI4'	“½!¨Òcì¥Ëp]­»‡ûé2JÜÏi°Ó"&m°ß\7¬6
ùXg€ií¤ÊºQğÜÖ@;SFFıÜÖ@ÏøpÁ!Gtxc8>¢3ƒ”Té3«1ôœÁ·`[¶£ Gğõ‚ñ‘µĞZÑ©Ïî+4BFğ¦CGôÑl£Ï@gù¾˜ÎêCã›p0¹¾kÏ;¢Ó`L³Ó®GZĞ‘§æìq}¸ZŞE00j‹µW{+àË|­œÚQ²uÊä¡§Åîê¿ºÉE÷ÛJo ïÄ‰-x;RÉÆhë©sQzˆnÛ^µşJã¸
ş½&zËøf8Vô¦Š2=;PŠ>€¾9<­Ï¿‘2hŸm)ø`:ã	<O=:<É`ˆ‡{dŸäw0uSL¡î·X,MQTk4ö9Ùi`h1Ô¼q‡®äğv{Öb •Á,ui‡ø#ÇÂ¾‘wÇú|IŒG§ØëgÍ™êø'ZËİJÓ3F`È‘:áì»ã¤y³Flñ-ìêæ¢b/¾Ğ$¿‘h`ÃÉUdmËÍè¦3ôø-âkıëñ@ ‘=ªÏD9T!¾ôˆ*õ°Mç¾=œºÊ{v“¦ÅNèp uŠÇRƒµ¯0Z÷ÈëÖwİîpH,ô»he¡ïÍÍjİĞÂ0yhšà´«:ˆÔïh·£î=¢9à‡>ÜøÔ¸&æ½¾ğº|(o£Ù>qéÈ¾}\û}4	1P·îñxq‚ê8p¤úÛd,0/‚ hô±:VÆ¢§† Ÿ0Àü~0zç1UúOÖV¸âßş:ñ<xÍ\koG–İÏúea0$e‘”’f¬DŞu<Î&ÀŒÄøƒä(M²H¶Õìfú!YNüß÷œ[®j¶h9–H$Š¬ºußÏjÏ²b¦Nÿúå“ÓÿšNÕIY§I¦¶EY«b©¶wõºÈ•JÊÕ6)+­6Å¢Éô±ºÑe•¹úròdr¢†Eİ©Û2Ùª$_¨ešejÙäóKªÑÙ@¯ëz[M§«´^7³É¼ØLôéÜş•é œıeút6­õûš@'Û»ƒƒAƒã«ºLçõàà`zt Ôk,c·i¾òGãıßN±jªÛ»2]­k5|>R§O<qrrªş·Ô«¢¼S?NÔ›¤\Lv×bÙÇ
?¿T?
Ô«bYß&¥VßM¾HH]ï¾/N<Ã&ïÀ¼\,+ğPIó$n¥u­s5»\õõ
ğÿc82ÉuıTˆøÎ‹…VõZ«RÏ‹U~Ğu»Nk]m“¹VóuR&óbQu!ëşõjüìÕóï¿ç¹½'J½¼M’æ šTç²(Õ¢ 3ëuZ)üW¯“šªb£Õ¿òTĞ#+5ÌÒk­.›““äd’µÊ‹|<¬k‚h­È&ByM¨™®*ªÇõÊÀƒŒ$­ô{õ®©jUmñ™*™æ¸‰z1`E©Ãït–	™8t<VwE£VE±ÏÀÛcEU!«Æ3Ul)¦G‡Baƒª¼.2US¬-5~ÇøXøÙBÃ€‡ŸX…Ÿã~X¨Óƒ9*X”‹Jo¯ªt³Íôp:WÓáÅe}™_¾?™áÿùe©Ş>A'çYò©¹o Ú[]ªß@‘¢Fóu¤Ô³wz^‹0¨şTî)mJä‚VpÛf–¥s’£Ë¥è I+PX,=,²@†5M¼İh¨ä¢úJ¸T|÷‘ˆQ$!L!VÕÌ{-:VÀ”)”êú‚ŠwáÔ…^&MV«™^'7iÑ”°IKß÷KØm’×Ü_ ®ÕFQêmFJˆµè¥£_%Ì¾csìÁ@P8šmYÌ’6ãì,”GìŠ»¯æk¨Z5¹óışWÀÛ¥a’ãÔ¤†{™50)à”×e‘©›¤î°áj‘³Şßœy@Jİ¦‹z­†–æ3õ×“Qğ­²ô¼O7ÍÆ®u€`Å+N6¹†˜ÏUVä«+Q«¬g™d•¡§yJ§}•æ†¶H†Ë”8O±ìK=Ó`Şjl\8¯±LK(4Qò´êE„CÑÔÛ†:ø^,©ú,z
-û.„ß:4§Ò¿6Àïß€&LÜò¬‰ã\Á:ÆÒ

”„¿‚
UT¶iÌ×÷b­ßoa3Wu2ƒx¼lë²‰ø¯ÔY§dŒ!ÍÁÅàE¦Z_9Ó°$ Ú”bmPÚ9Ü ,:d@ r‚mhu¢&5 xxı…x¬"::¸K:¶mQAŠ<bÂw”(dÓ:VB9O¢“‡Ë®Á©Š®ˆ|²(!‚‡€‹ul/+î¡Ã(~„ô `ı€
Ò!&ÖS\µA&@jWD?YÇBİ	¶x"Dƒá!2áE¨%K¸[‘àÈ,|}YÔôZ°¬t©ä=îô¾œD²+:¦»Pèğe•J"@V^‚ê£à›eúşª‚Åi¸¶+Ø8ÄªñòåU2ÜÎ±Ù©¶LçÉyHS’İ&wK0|Ûqà[}ë¼ùa¹d–Ó„yâ´÷ê€ ®è“›"]Ğ±Â*Bp¨]G¹Wşß0)1qZÑ·R„ë$WqUƒÈ2‘?ˆó5f˜u„üæ¬,®u~,1UR#ãÄ7’iâû¾3÷"¿Zßm×:å²«»ÏÈcœhÓ*³EìUpœĞ¨¹ëØ‡&ƒv1Ÿ7mğ¦†·_"ä1XÂe´v y"70i²Ño‡²~VêJâ5`Ã¢P$‹²Ø>Ô"ÿµHê¥_—I
.†y£Z–ÅÆøúğ˜MòşÊğ»õÊ/‹¼ã•_—PY°Ép–#[B8’k¬‹Œ¹Ki .&“ÉÛAìØ!UÉ°>‰sI$Á{9ß29³¼BªG–K‚X6óº(‡&k¬şöqdÓ>®AòüÅOL>q<Â¦;ü¯N¬?WƒA¼`7Ğî®	İÓ¹Ñƒ³9Ã%a¡ û–õú—s^"€;–Ú®«;}kvÌ¦o‘‹Qçêo1oZµ9WP_½DH\ÄK8wzàIùÁYÙ’_¬“&N\òÛ¯—¯v$/î“ŞÎgñ–X˜Á_ñ²hsŞ#èxÓ}î	,ñÆw?Š7ì
¿óI¼¼GºÅZ°ïâ¯CÍğïã%f@‚¿dÙÇ£(NQşX¦7t<¶ÊÂGŸõˆ€4D>W¥tÖ—Ë-TçP‡ld¿Ú4máé‘BWãªLªî‘RıÔ™­FjüÔ¾õÜPGÁ[¥şÉƒP"y=³YÉŠ^l
ƒÔ!SRrFpÚ`ÔfRfºâ_½XMÔ!xP\^Ö³¤¼Dm}™Ï’‡œº#”S²’Tb)|8´Y(Ÿú=H×†b¨é„ãrIåájèİ­!§—õtu¬jÀ>(V½F#"o°+Èp^”hi ?ÌÕ;›ë ôÇ]DvMõAøtºo-v6ŠEG•ºnJ¤» G‡ö’Ì+é½|ReÚU±\°9—¯ŞzŠ:šòJ:;ŒÂODR–çàŞ¡vMoR*;ÖëÈÈË6$J¸úkƒÆ—Dâ*A„ºER¡¯T¥µŠË~±XOYèÙOyÆäÊš°	q,0=cÈš‰Rÿ(Šëã¶ÅD+w9lÛdŠN‡dšMÔ¤ÊÌo¶}àOÈQ)üşÿbGË:Û·ÑQJ±9êÅşıxæßÚÕ Ú
õïzN¦÷ÈÀ¸›4ÿ.{Q_q›Vºß€™<Â/‹‰…{r­%øåæÍ½5ÔtÃoŠùhŞ®³vbV	Ûœ¥ tX Ñç»4Ã’%[¥¶Ût¬zKjß±Vì ´å®3Şj=SÎ¶‚låˆšÓ}¹Sa™Ÿµ}è3Z¢EÒüÑ2¢cÉß	õh~ì‰E7…dÅ×ìä%b‘Çb­­oÁĞOöhƒ½E!³ë%º¿p‘IÎæ0ZÁÚÖiÃ·~›®X«¢·ƒàôm÷Ğ2+\yGoÃÎ]ºLQ ˆ LÍ¶I®[¯pRø¢z‡€Ô Í6Ô‰!]
 ô’PË¢t2ú\õPbÕU¦—-‰Œ/&=üZ†Â'ÚõĞİSê£ÒèñuJ‚h­86Z¦óv§ñä„¢PŞê¸Â*ük7Ü—£éÿªüšÎtÓÌ×& QÂàd€ádN¯ÍÏ q%Û–øa™ı¤®">ÂGãm¦êrÃ)ïdÛTë®E]t,l’é|…ëX¾TèƒëáÉqÀĞQ ½@¢³{4ˆâ3VÛ³[éØTÌŠàğ¨¤ó‚eiß¡F^é’İjpc¡b„Ã	ÇiÉÂ6ŒŒ0a},wy„F×éÆZŠé­‚š0ü‘*”¤ôv6¨A6h%VjÆ…MäĞ¤Ï˜µ'£_¦vÅx(¦ÕM
õ‘Ø~A¢˜îğs²-0hd½ªe™×Z¦O{5—Y¥#>1DG´R]a¬$(TStNÇ,0û%—Õ)Òˆz]Í
ı×uäd‘hWÀâä‚RåâîG5[%OV`Ù±Â !ÄF˜Gå:ïtY@a‰e‰	¹¯aSi	G‚Xè´Û&„W‘*D8OòA-cp²íœ¼¸5>Ô…®p&bâK(¾nHÚ]„)\œñˆv‚Å&yè*KûC-ll£mœMàDè|—¦Sƒ7LvIÄà•Î–¦â0CáĞRBm]Ó¶ãÀvì’;ÎAÂ~”#ŸJâ^m"JõdÂÜF)Ôô°h;íPv¦1ƒÌ¡PDìí›éºTyÀÓ_DQŒØ‹bF¢Sà¥(ŠqäxÄ$™¸cDÙ‰5¬“›ŒºZM¶Ğ,33¸.1• µd|¥RŒ\´G4Ô˜Ã!Â²kWQ‰:$/¢RK©7-C¬Ğ’—zƒa.°ÍG3iŒÇsqb`7n]%@˜©,¤7i·r¤Õ‹ÅdŸL–®¸·ŒÖd#›qmÉÂM&áWÒÓ‰FØ(~®0ë6#[Œ~ãV½(Kôø~Ió›$Km²¡şô[»÷£n8â†º=_Bè@ùÓ|B=:ÚUİ£{Ö?İÍ3İ&HÈ‘Ù±º¿«Äµ½	È.{ZYÁóO¶‡æ|¶4‚>Ê)ÖæU~3FµÖÖŸšUÂù.å„2~À‚Q"£d(Õxi"šëér/^mñG ge™°«<ÔF.;à†·Fİ¹Áx%#Ä¨—ËtÂU#\#¦!Aôd#kÕ„çCP¿¦WƒòÏQØú%ÖÎ}Ú³†A†'š•-WD=’‚ã„w`	§°ÆÚLt`^Æ¬—aŠ‹ÂˆØâda¹`Crwœÿ!4|aÜ	Ø$ëãt¤4³uPlg<Æ	£j3W‹C”á§p`dû¦Í`â(é{ DiÎ1!=ÖLØ´±ı>•úO›IWŠÿLÂ[ìøí!Î¸$kÒæ±5t«,=\å|_4ƒ¹‘„0/phm°ù
MÇEš\î$….¢ØDIeë¶İñ©©6r¢øYHOæ—wºvW1(¼¼ëô|ÕŸÿlMã"6 Éùé.p“åŞq0àR9¦c#æ€ö§…#ùgDPà ¸zŸİµĞÌ;jY6°ûP5Ş,÷ÂhŸÃ‘ø²³Â	ıy(˜ëDÔ“ôÇZNHd¡³ÙÇÀæësãğú4œë½½J©r¥J\ç^ö¹ÊzéxYl¥yfí53{n»˜ŞZx”ä4‘\øië¦Í_ÑğğuÇ›¹ÃM¥Ou
Wª-‚Ã,Å·¢‰ÍÅ§#cC!Öb+‡Œ1MÂyÓ±´Ak¯ÖúÀ¶'¦!<_İÓ
ÚÓWŠh!£œÌ ™ÖO6¸U}ª2k'#”f‹µó0ARkzŠî±š#?‰ vì\ÿŞX:n³îÄû*Ê ÎQu¯²Ë?îšô¿ÃÛsíD|‚ıøÂÓe¿ßõ}úïø2nÓÉ@ØàùÊXóI/â­«û0á÷B{›ìÑùÙ¤úı÷Ó‰Aäé«Sõµ¸ˆ×ÍÅïÙØI$xØÉ}‡»RéÅÈ:?ç}	ø¢ê_ûÈzÊ“·’ó¡à¥ŠTàS®‹NÓ\†¡^·½§³,8K&\œCH=Vaì<I}/. æ’%j«‰Th=É|y<nzÅêJöóeD ŞÓf[3{‡´ÃÁ èp˜M{k‰@²NW¦²³“ô^´]x²†Ğ§[îÄPûÕÜÒû¤e9«éIÜ­õ}Jp#oµÂ=Ñÿ uİÛã~ÿA¶»íür˜·fzì6ô$÷m˜Ü§üí¸ú˜1•÷¸·µed½˜õŸI)?ò”}J„‹û¦5H¯odŠôF6]tıí‹|qº2"è¡97±O—z‰wĞÜoQ{#©[å~ßChó˜!öuò“ˆì×Ş/³ıßFÇ¦‹Ú$“¹DØJu´Ş¼İÅö¯ î[¯(ˆ	Sìwflì®Y3óUK*[¡ôß6hõÜ d†Ãèğ4xlŞ°è^}ÿ¬c“Â²·ù©i·_ƒ¶§‰+jzşÄÛ¾$öÌ>íM´«’\³¯0 _p•—Î¼äş©°¶ÛñBµaCmaós^dÍ&G7¬·‡JÌÃ†ûŒF©ğØo4·XğÉsı½¸[4÷,©ó!ï4Gq•G2bÊp6¬ıØwÓ|5r¿/×·<[i
ÙK!¦©-C” Şvúu&m€¹
©‡%aŞ.OclxvAjƒkÓ©Ï½ú.9…
Xx™#ûÖÚœªÕâé´5ŸH£)‡¯¡Ål²vÄ'<>¥~M¬F3=ùüC•É“¾:E êó2·zÁ€ÄqõBz¼43çğw4½‘ô«AÈOoš£‰I¸.sÛßûx –ò	x
Ésôè0z>·<)óYîâàÀ=Ë&hŠŒp9B,Š/sºéÉšŞ6sQd¢èày²Ø¤éÛ¡‡$ª°KÓ°³6kíÔ°íÈşRê¡rìw*^–@.p(=°Ãøï?¾±c)€²·º1Fş#>…®ËÓ÷ıIäC<0ãK”z…A¯ÁpÊƒ[™Ç¯ØWKnpw¡µºÖw[ğ¡=¹r6G—¾à€ÔCÁPV;O3™‘“¥ßLËş	·vñÄÆäÏÅ `xm”®„ko±Šö`64O}Mp§ ]åCíã±2pl5a-àvB”Œ» ¶{õâ“ú-;ÂÕĞÖ˜­a~¾ZöºQEÏfãöªd‹å¾ëI<,gKŞô0ÿÂ]/	oÂ;ŒÓDg£èÇ¸&1­…Ó•‚ØÖ·öèšö 3®ğÿ—®y¥Q×ŒcÅu5$#|d·0Ã³ÏûbøUßÁó>àup@[®«^ñ9bûøäÏê²~ûøOÓÍÊ,³Ï
„Ë‘·ğAK³ôh4üï³‹Ÿ±ë2;â¶Ö*ğ€M]_ı“Œ!á‹xKs³a[Ü>—´Åešcîı0<2¡ø…ü—ƒx-í[3!Â½<™×Ëä•6îmdŠo‚¶™[p(#šÉØŞ:RJ/0ˆ²]õEŠ«mÉ.ÈX¨ªiÁ¨]ø¬›7ÄK’N<q‰ÇÇu½öá+Ó¬ ¸Ÿî`şÒ?Åd,Æ ~½<°zÃk™c²8¶ÜÀcÿ$;”LVqˆœïJÚzˆË¼îOwÏTÃ¼*<ZŠæ$[:2¤F|¯pvyaoO¨Y–ä×&n	9ÓòL–^Ü‰HÓ›¶eü:T×2eŠH®Ê5Äj§F†”ãX&¼³¸Ú3àøş’9š¿A|€L‚ŸˆŠZ…ùË_7µŞ	î†Ú|‡°Œ`™È>ÔóõWÑäùšpw‰,ü÷ßİĞ›pØî'%R˜Û×¹ı®½o5>†•L©Ia3„Ä èÖXhí<\z¶ô$MYh<ºwg×RX±`—çrqñ&×e{G ¨(X³‘C°ÌÜä£ÑğVP±z{Áµ&CìDæUÕTC–(´)ã±?Î’€Æ¾@XÑâ
àñy[Øƒ°#Eî‚â>BÒ—º¨uŒy†P«8+@Øğ3DØ°ƒğ>Æ‹=ÆJ96gOßxÂÖÈ‘û˜Û,èRµmWÒäˆq¾1[íƒŞà	:Ù–ÛbÂ0…Z™˜±îñã®0¨X­^¤oåŞ„Ù‡¿ú–s‹g‰c¢»I˜¶×¹×çvO¸ÏÖw-v!2}ÆNyÿ¤W/Şo‡ƒŸèIä`ğ›Õ i‹³{Sgºšî‚ÑÙü,İñxHy"Å1j;şÓ&§ÿmŞœx…TMOÛ@í9¿bÊÅF¥FH=´r@jW(Š¢Å'Û8kw½&AÿŞ™õzíDTä{½ófŞ|¼yÌ‹G¸øúåÛ‡ ®*£eb‚á`ğ$4<\şú9Ş%XY(Æ¿µÔÑ9¶ŸƒSg<}ø=^\Å“»éíıÕ4¾]Ä¿§7t$Ül ¬¥Jƒ3~ÛÔ¹‘Í«ÆªÈŸ°9$…¢ø5Å·f’NB%gÍ¹Ô˜ÊDg­‘>T¨œµ?NÄÆY¤˜	
ugs÷¥â×Ë\Š
«`0ï¥¹˜Ä×ãÅ›Éµ'\%"º‰]QæH\šÓF”¥TËÆCV«ÄÖ')6¥ÌÑ†s1B²<…JšËIt‰ÕãeO‘dl G#Pu7– ñãLL´ÆçÊ:ˆ²BE²
}¨Ğ&ÒÚ—™ı4ÃVp¾-8³;êµZ†ÍõœhYC"Æ¿=õµ{î™¯FSkåàÃ}ó„¦Ï%†F,Ï °Ãââ¹ùnß^_ÛìûY¶ 7Ø+jgKö¿1‹h¼pgaQM?_´@ ³ÒÅn‡:îÕZ[åÂI Ÿ€]Ğ#8YÁH4LRIÛè"kÌ(ßÆŠu†J±lÕèŸ+Hós˜Æ×ñw¸LS`us#$+LÖ˜•¬¢¶>†®^C†¯K(´\J%r_Iâ”ĞÉVÃV(S) wÅ!Ÿ–ä$İFáğİoÄt˜¯eÀúìß9F³F¸óîŠZÈÓêNÃÎÀ·z´ân±ôRkÚ"ÍãH‰ßÖeÏ¡¿—SaDÏ)ûN»mÂ^{N»‹Æëqz~í³ñ›£º¸uô«ê= ¯²>UäSí/¼ƒûôh7²¥É½â4«ºm f"¯Ğ÷Êî·íùÖô“Ô7îè72am³z‹ØKÚÏç)êú]UÛ¡¶šö>¼°«™ILY‘ï(zÏÛnS¤uîÊB“ÚFÀ[o8øp6Fgx’Koâ0…gÍ¯ˆ²eH”ª©ÔEáJSZ3rã$äi;PñßÇv( ‘FÓeës®ıù:QêHZïÛGC’äÄP~”d
	•¿s%Jİİ6ˆà+Ä$HVì
Ã¼0$L ¸€BË€»Hh<ç¥ü§^A¢Œ2€	oP—Ùò+w”¶¢‰¦ÂÊ²Ó¨„¿OiFUCŠ+%Éâ()F—PµuÙ¶D’BÑñš$"ĞŠÇô´Në¡©¯sè8Ãcö¦?ÛÍ5¸îè€LRíÙÑQc2÷²Ùx\HkoÛ=°¾ö×ÌG[uñ¶×ÌĞØ4óê˜}Ô”v_®]=XŞğÏŠ&‚¼¨¨Ÿ&ü¶² uâÿ†’VâèÌî¹ks~‘Ù9“!;ïZ"çÿÄöÙaCôyzØ Ë\Z£ÉfULğEíáti4‡}XAã©?Ûï/è¾ëß­´©…~ÆÙ*_æ¶Çï?
„íĞŠút]ÚÆ×‰Í&«ëc=˜ÁÄƒ‰ÜLœ x3hò¯z¬YI:#f¨œ€Ïòç2á
š×>É(!©?‡yëObë©qjüÉëpx+)JMU016d01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|!æ$eæ1py=h‘§ÂõõÜœµÚ/ş.<î4ÃÜÔT!)?¿¤¸¤(±@· '1O7ÉH¯8ƒ¡Ö@±¶Û«m{ÑTù°âÓ«B®ÎëmÃ£^/?'…Áfñ5¶<™£[„¬[¼#^"g·9Ä)ùÉÅ%e?³É$ïIÚ¹1§YøÇŒÖké¼ü”ÔøÜü”ÒœÔb†Sâo—^:ğmßÿ¸»çO_¿èÿ¨êÛ‚ÄäìÄôTİœüäl½¬âü<†ï/Ï×%ªÒX*’"|¸¹ªğbdgªbˆºİç¼D²‡ø¯ôëâ?äúhOEÄq˜:¨§+ss›å{İŒ/¨}ÜğÃbı¼	aÏfÙéAÜXœ\”YPRÌÀwùOûº‹?5/TÜ8Ö³8Õg÷_A ^a´°x}RËNÃ0äÜ¯ØN¤*Ä¹ê ^€G×Ù–€cgİ‡hùvÖN›¶šS²3;;³›™q3x=\‰Ğ"´ä+Mb<,•‡çMƒ0Ÿ¡ò˜‰¢¸!.‰œñy°š*gmYâ«ªÍ4“•ŠT_€jé&“	XÆr&SğÈd€8¥VkÛ
ƒvAo	Ù3³„rÿ-\_'RRß"‡í–öOÏ»¼ãXç
¦ôF›¿K/"ç\»“dÚYŞGĞÔgërí­Eåó†ªÒ™›½£¦3nWê‘ÚjWƒ®ç©åX\¥•g‚ÔBnx¡…ó‹áİht'SŒaZëGeK	¢ÕÊ(/†¼ƒı	äáåà7b}y|=Åe¥¡„Î~'Èå-É4‘U”u–iFBøŒÊ÷ÇKìb7€q+ôZµ,ú7=Åè¡i.Ó§ñ<=]«Í%õx…#ë†62ÚúÇLgvl=ù/q®‚¡'Ú ú0b°ã?äŠjşÑx}“IÏ²H „çÌ¯è;™WšfM¾™|€,ê+²ŠxCšMÙl6å×³æ0™:>I%•ªTÚ5M5ÈÈò/#É2À ”Á’„x˜òi*Ü2SYâ!NE‰Å"”!‹!ârªOHÖà&R*CÌ¦2ÎY)KáíÆ¦,DÂyÎñéKä	T2eG€Bª¬FFp“´àd%I`%^¦›lL
’ŒÕÏiÈÈğÕv$ëë÷WQåtûJ»æw EçX(A	ĞbêC?ñÇŒ ³­é~ücûù¿¶¢/†ª ¿ş)U7w6pLø;ÓV‚ĞÓÿâ À2©ª(ª¦(®êî;Í½š§ÁÄ§‰ËZQùª¸ÊÁAh¶
%³wÅ‡ÓãMÆøx£ :Ì• 	ÁËÌQ_ÏÉÁ·³íô…íeº—ÜÃÄöêf?Ê–Ã£gœrº_B~ñ…o
xë‚.ÅmåÂ}OpDÏÆG¹4´!lÌñÏR¬:v¸³}l²t7ô8iQä–ßo
$RprXÓÇ¡8v³İÇŠŸs	Ö\÷x'=KóÜÃAù†¾2¿¯2/¶ô^B,‰[
<mÈk-4•ºZİuUùAJİ~=‹‘çÄºš®}	H±ôšù$5/:Z@ı®úÕ§É1båˆĞ·q5ÉeáùãÅĞåáéÑßö¦J~İ`;ÛærèL·b+‡fªõª£µ¦@¾Öc<˜³QĞoQ˜Oçâ‘dNºàÅn_#IOü®ÖÖO¶éÓŒZK)BûåJ»H'4ŞıXfƒµU‹{ÊA³b6VÑ½šš>¢û3©—ƒÙŞšMã<İv‰L:*Ñ°™ì³ÅShË©ê˜Z45Ÿ¤Uc»%p%IVú²*"ÇÛ3rßÙ^[éëKŞíåÑouKBÑ[ÒZæÔš­vfÒ”„šã§ù ¨İ;î3q}™Õà¾jOù ä¥°ï1ê¾â(à#eâFÙ˜k¼»
|Mö¶Úc®Î~àÔY\ÊÍ.>o|Õß­ä³ç%ŒÍŸ=ëûp§™Â6¸q-K{ë8§tÑ½¥Àoå&i¨¿?¡ÛÛÿ~¥‘,3àéÊö¨5˜¢Ì|cù/üL ]İxm‘ÁJ1†=ïSŒTH·)±TPªWÛBw“YM“š¤•Rôß¯Oâì¶µ"’ùgæËŸ™Â¸..»'­ÓÎ2øN¡mí
¬S˜HgC„2@<¾.µGÎÊÀÒŞ>³Îçæwî%´kéX¼¤|­	ãrÅË <æê^|\[ÉÙÂä¶]tEÓ–[Æò’¥ô€ÁsEÍ¬C*‚ÛíÇ—èÂöıŞ=y¢ÏåıØ-ë%¥óÀw–GeÔÎfP8µ€+á¡x!M ^cà›`˜GùŒá
È¦Xì‚Œô×ÆÜèª	j™°ÔV×Ü8pÙ®WÑ5©Òj*¹>ïÃ´Õ‚³ÍŞF5¶Ó¥t	üÆû|-thN^ÛÛ÷AãUĞ/îrùÌ5ô¯¬6Œ`B8]ƒh8  	Ø¼¿Ö08|4ËV“ôÚ¬"äêˆüñÎšqV	mëÍëˆÇu)'Cç°3šœ¢˜+–‘Wröiä¼#xAŠÃ0 {ö+|_(–åX2”²_Qd%5ÔI1îÿ[ö	{œÑ³÷6}D¼Ìaæ™¶•‰¤ca¨Yb4Ì8¦\iRp/vLŸqİ
®R ´æÊLÔÒJk€%&eÁìä=çğ2š=ım³Q»D~÷.íyÕ³ß=PZRD(Ñÿ„‚ûÚïâ´Åîıª2­úëŞæŞs˜û 45HÖx+)JMU°0e040075U(*ÍÓM
åé¦å$¦ëg0ÄÜ’ßsQgï¤Èi%"k–§~¿:ª¸¸$¿ <±$9¤®}ù¶gZk£#È´òî&c9F Õ#uxKjÄ0³Ö)z0RëgÃr•–õä(Œ¬A£Éùcr„,«  öŞZÄŞ¾Ídâš™Y
’×ÅxÁšâıV‚c-’ÔCÎ+¡x—6g°E´6ŞfÄ¸6!EcBad6J^ó«’Qq§[ÁÈMÎ?Š:~Mê}Ù{û wlµõô®YkuÙkqâ_±hı4ñœË÷³Ÿ$g¦×#Ë-GG=û€út	Q{x+)JMU07a040031QHL.ÉÌÏÓ«ÌÍa•™“]4ßøÌ®æ‡G…ÏÚF3•BUeæ¥¤Vèe3­»Ì¨6eFâ®ã¦?ÊªÖ;+(ñg  „ËÎx•RËnÛ0ÌY_±§P5•a-ĞœˆİCô@SkW-Mªä2‰‘øß»¤v_¢ÅYÎììÎRÛ%|şôñLàÉ5ŠÄ4Ë¤ƒÅ¶E˜Ã¿¡q˜‹²ü@|%
ÆWÁ(j¬aÔ[ı„r£¿Y«Qš¼–$xÍ š¤?˜Íf`‚Ö×SpVR{d€¨´‘/,ß•Íš~%¤/ÍÊWp~~À'Èğö–&	±8quÿã»(
®c±ş)¯(S[Gœ7±Õã»¯·óÈ:Ív³PÖğƒ¢ÓÓèıD›]·ƒ}c{lpr‹–ş—nü0}»üŠºù÷Šwéªl%7X’ó¦ÍºTRë|x—$»?èé~v:[%¾´Ö‘ç]|NùÈÉuµåí—Ö­'——Õ’s &) SW <ëH'&l¦ÏK5Fáq„ÕşxTÒ:¬%	+]wÌŒx4T%i mŸÑ)é¹pŒëhöuHbï÷ôyâv»LaiBÛ¾‹g×Ìs“R2ò(¹Aı~ºD”@æávRO5®dĞ4§­fsb4*²Gòl3x+)JMU07f040031Q(.MÒË*fxüÚHô¸Ì—EM8SûZrÏ©¨Š’ÔŠ’ò¢Ä2å«2·§9)¿míãï*ÙE#ÿ ñ¦"xe±‚0Eûo{$¸|‚›‹c'!–_[”ÿnaqp='¹çÖÊÔŸ²zK`÷ÃRˆI2\ç‘ ¦§ï™"LÓ£ãàï^7®7:XkÔD79¨qGQ+Œá# (çYÃ ª*ÀóaY~@{¥J±
1˜Ö+Jé=v645½ö|„NvÅÆSÃ]’gY^[“=ñèu[ ÚF*É˜ìÑıOñwL¬á÷Ú—LÀxÑNÄ E}îWÌ£Æ]3Ğ²€1Æ_`°$Ğ6têúù6û	>Ş“œœ×ÖŠÀˆúI:3)TÖ1[oƒW)ûài$ÔFßÆÌŠ²Š6ã4lÔyÀÉ™Œh097w³^q$Í^‡˜Ñ’‹a CæµõÂ>2÷Ôhy,‹öë»Q©oqmŸ ìd&å½á5âpÒó¢ğ¿ä!U~ş¡£ÊË;ì‘r^k‚@û|}PØ¥QÎp/2CYÿ^ ±P"¡Ğ’`áûéö²	Ì\7îÃ±cNxSËN1íÚ_qjRHŠ’–ƒ@ŠHú@„® !gÆ“1ql×ö¤P@jİUªTµ»V¨¿Æôj'­*µ»kßsî=÷Õ—ºÕ•µ•G“ÊÙ¤/TÂÕ}æJâ¸G“WF^0!	éí·÷ö7jõœyf…å'®AxVjĞŸWŸŞ£ç™õB0°œ«f!Ù n¤‡®Â<nÉJˆ­Ô±¶Ç1x½stº½­Z[¥ÁŞzŞ	æZ4§9Òt`ueÒt¯R*¤IQ‹ø;À2jß±43ĞÉ..p>rıı#¶Û;Ïºú:ø©ğX]Çåmªëo°ÛîõîP·®4å*Ÿ	¡ä’tOÙÈÈPå¤VÏ‡Pc1/´r¸~÷–É²ĞÅyÎóùâAwc×r>ÒhïîPĞ¬²ÍÂ¡ôŞ¸4I¢¯5æ6ã²ÅŒI˜‰	$z?Î¶<CÉ™ôeVòlø§HÚpË¼¶­Bµr>N¦ø·axi¢d&!Ši5éS¸Ì
ã]ì’óäà è‚aÙxëÄi…£#,.âäuX,µfğƒC:iGZh;<¤GK÷9‹›¡¤q¢*)#yn0Çú2£èÉ‰ÑhœçÍÚ]ı@o(LìÅu¥}hh!ÏÃªı³j6Ògÿ£:ò~W=ıı«êy¨št_t[çÕ^øªš˜dãî¿~F§
Ó3Û}°—Î.´^›HüÈ$Îkó†ù¬$ä”0OÎx}TQoÚ0Şs~Å½Tšlê¤i«x@-h«è*•öaO“IÌH•ØÔvJÑÔÿŞ»HLxH‚¿ï¾»³¿ó¼0søòíûÅ'Q9ÎÛ<õâ2Š¢i¡02S†`Õs•[ÕqRäó„×Eÿ²feU¹
±xXQ´¨tês£QIËRe½…5å ¼éÃÿpÕWVÃ«ÇË ~iÍ´ZÃØZc{b²ÚÈ²ˆœ)áK@îP§4/*ƒ\Ã“;'
|:ÃôØäG¤7§W2Àz™§K’Ñ˜ÓÉ…‚ù2µUácêàí2zÃvJ“U…ŠÕëÊXïâ‡ÍJq‚ı³µiI$Òˆ¥KUÊ}}µb]M
DOF¿¦³Ñdüwvõs|;ªeND'™ÔU@æfv÷ûP¢£ˆäÉ¸º»?ª¢K"56TÅõx2zœ>rª™í±
!sÖûpğn­Ø:ZÅŸ€M^G Ø
"wEàŸ!°çczµ"şŒn§ã×T­êAàØV{jG Î¢${uÎ6‰%’‰Ù;•èdYk©½ÃI‚Ô*é¤•ó8l™¦Û8~Xİ<×Òn~P!ù&VÂ°èĞöÜ_3ƒÔff)WÌ‹"Ì<]Å–JN0W2·îtêf¦SÛÃ©fÏKå¼,±ĞPê˜Ùscº
%˜‰¹îL0óJeÿ©ÓÕ03Í~3C…ÌD§»6á-ÏÛN·¢áÇ¾ã«tw';¾hofçäc¸ˆ?Ç¯MwÑí2mŒ9œ¯|±ƒÅ MW`xw”Ãq( ¼¡Ïö­J:×	mèL"4«¤ğ®e,x+)JMU0±0`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|!æ$eæ1py=h‘§ÂõõÜœµÚ/ş.<î4ÃÜÔT!)?¿¤¸¤(±@· '1O7ÉH¯8ƒ¡Ö@±¶Û«m{ÑTù°âÓ«B®ÎëmÃ£^/?'…Áfñ5¶<™£[„¬[¼#^"g·9Ä)ùÉÅ%e?³É$ïIÚ¹1§YøÇŒÖké¼ü”ÔøÜü”ÒœÔb†Sâo—^:ğmßÿ¸»çO_¿èÿ¨êÛ‚ÄäìÄôTİœüäl½¬âü<†ï/Ï×%ªÒX*’"|¸¹ªğbdgªbˆºİç¼D²‡ø¯ôëâ?äúhOEÄq˜:¨§+ss›å{İŒ/¨}ÜğÃbı¼	aÏfÙéA½]_\¢‹«ü‚bP8q¼Ÿÿê‹ü£‚…ËÖíTy@XYâ©âä¢Ì‚’b¾ËÚ×]ü©y¡âÆñ´Å©>»ÿ
 g%ÉxIN19ûu1 oí!ÄWÊÕå/#·9ğ{Z<S*CJEÒh­,ĞÁ?¬ÉFifvig
zÓ.FBäl7–Vio4!›´kqÇÉ}¥`¬Ê2FtÁlÊ)•²Lìj6Ñ‡Îì‘~¯Û˜€³p…÷ÌsoØÿš—şóÚ°ÔWí”·›U^ÏRK)Nz^\ü¯±ÈŒëñ^±¿¤§78suº1}Õr,8~ÅíWî<qyZú©;sV@Zetñõ] xì½mw[Ç‘.z?ûWlyÅ D‚–Ïœ93ÊÈ^<œxİXÒ’”™uC1H‚$"àÁD)ÿû}zé®Ş/ $ËÉÌZƒÄ"°wwuUuUuuuu÷é|yZ=üê_ÿ÷Ãú«çËÕºZ^T7ï×WËÅ ®&«Ë›ÉªV×ËóÍ|º_½®êÙrQıÏÑ¿¾|ôê\­×7õ£ÃÃËÙújs::[^jõÃ3û{ŠFßJÕÙÃÃßÏNîèæıgŸ6h ^¯fgëÁgùíòæıjvyµ®†ßîU_}ùğËƒ¯¾üêËê¹ U½\^¬o'«iõİr³8Ÿ¬Ï¨«j¤vşZ6 jU£…ûŸU÷ÑÈõõdq~0Ÿ-¦‰œ-.«ùìt5Y½Ç{yu5«ò
ß&‹jy³~ÌõÍl5=¯@o/˜j}5Y?2`>ÕšœOëêt¹¾"4à>™òyu³¬gşsu¹¹.Ö5‘Ğz7+tÀ*^/ó÷Õlq±\]ƒö·ÓjSO.ÑCÓšCzssƒ­…:ô› SÏê›ÉúìªZ/«zsz ô€-Nò´ºXÎçË[²ƒDWõìúfî­LßMä)Cõë˜¬§—„~±Z^£‰)‘.¸BênW³5°Çëj5­7ó5›ŸT³ùôQäbS=Î=wdÌxN9\%dËù´>[Í„‰@FÀ'|€ ›3TĞµ‹é`Ï«k;£Éùù2"Ü.@Ì`œ]OŞNVù?¨P?<À×õû›éc<İw°Äêj:¿y<€°Rz
ß\_OÏ? ƒƒƒùòœO/&`Øãú}=ª×çËÍÚNÂı¸ø
¨·ƒ½\Èrºº½šBmø“Üª¯–›ù9qcï¬§‹ŒID'—äùTùkGÒ³ÃÁõ ú‚`‡òÆÙ·×®p6_ÖSD®½2j\ĞS‹õŠ%f!¼ÙœÎggÕÙ|R×Ó:
ËAuTGup ğ ¥‚ş¬ŞC«€	$zårPèû¨:’Öb÷¹„ON—Ğ-ğè¶¿e!+{”Š«å9Uæëœ|³¼ÙÌ'kQ 
?¬¨\¬na «ÉuÊŒîTÿ©YDä8ë€ÅlñvùF#a§UüÙ•ªBT((Xe„u;ıËôlmˆ®aO7PÚêyÕÌñ'«H0†OßME«ÕdFnœ¾ovÂ®)‚MŠ ’´æSBD²)Ñ¹â ¤<UÒfímÜ^A¤1òš|¦Õbå‚>B?›l8 ´£uš^SşÏ#°I]ÂpóZrÃ5Œ8ª.€éBÇÎ…ÖÎ‚³æ J„´‰18[M!(ç;Ë´b=YĞşPj”tÁÍÎ&s	7Ôój’F —?±R4¨bæ¡!Ê¬ßìfá¹÷ïé#´( Ğfú¶Çppñf‘™õtÁR¹ šäüds>{3­57¯W›é ÷“››éâ|I®×0-BcÿjC2LôP5ª~·¼BöçKáø*Â9Û ÕëÙ_Åƒ [ÖÄˆÙ‡U;5ë#¥”5×º	ä±|`E¥ËÙÍ½3ÔtH•Œm)D¿Ã€ñŒækbûbrû›<°µ_¾š¾[—O#NÃotÔ¨‹’ìÏÔ’[T¨äìì*Â iJ Ôğ7€áXx‘‰¡H£K" Gâ¹ŒÙ4ìèí•½©¥ùdwÚWŒ][ø ,Æû+ªõt>ˆ*£©ÅRœ3¸`p—Øª‘DiÄW¸àÆWta¬êôt3ÚD7H¡Ñ9ÆĞ±Yg…3âJ½I“.GÀ^áC•u€	4Á!ÅŒ•³sŒâyèˆÑMTù=‡—2S5®†GózY`Ò	ã_òœò¹•¹0+ËÅ\Ä›]gíÙ8ÃhãÄb£H‘"/Oål!nôgB{½Ä ‘>R#:‡Ÿ}&rS½üÃóç/¼|	dğø±ÿzüs-ğìù«ïŸ==ú=|3°‡|òâÙøÙ‹ñÏ^<á‹ûşâÙÓ'ñùşüèÅË'/Xôh4ùÓO~8úşéoôEx>şÃÓO¾}öÛ§ßÿñÉoÆG/~ûr|ôê•To«éÙòr1ûëT¼Ë˜r~òøÎKı\š­1ˆl:î©A¥7aİ–2‡v®Àc¸İÿwƒËp OàëiÚ‹¯ù;½¼ ˜j^ÔéLb|3:ÄÌéSÌ1®b	şN/WÓ›^²©gR>ûÌ	®.§kº7o‡{ÕŸÑ¸‚+°Ópãf«:èÕP—LRj8P	\é{®nVSü‹×ŸËóéŸ÷«?Ÿ-/.¦òm]ØÃéúŒÂ†ŠoV‹
ó,Œ²õˆíjøÓáÃ½Ï~j`È×3LÜÆ5ú8¡i gÂ<[Î7×‹úQõÀÁNoGß>ûı~xú²úÛßRkêÖcî,åùæ_¾¬~*š¾šÔ°À«¡ªg"×Sç‘5şL\¸Ú[/9îPçÙíâùjy1x?âP_Ö/Z ë[-`Ò?™ošuãò©ü1Q;©iÕ¢‰úî&”>ƒñ¸†Õ‚–¦³‹jx¯Ï½Mo"ÈAD¡@ÿ|
¿§ğBWÀ.ê®8ò9OÆŒb	¿b=½yüĞ{R®~¹G¡¦¾‚ó0ğ”k}õå~…·"¤R*ŞfbÓÅ%îñã
 ¼LÈO gÇ27ß¯¾¬NRU
ìµ”¹‡ZƒÅæútºPøìZíyCÄ‹wN9¸¾Z-o«Åô¶‚_8ŸFÇ½Ï³É‚1Ü‹¬¦tZ9ÿà„`&ç§„«4GÒÀ˜NèÊœ=¹Õÿ¬®á×qğc#®–€' Ğ9| O2+ü×U—ævÈ
3ğLú5¾ıØÊ¿K×í´ÑÍ¦¾Îëj:‡³|¤¯w$H›^kĞ¤¦úã£õŞÕ~õf:¥ÏL‹}1NN&;1ô—õ2ä·ÅeHÛj$À‡‡¯W¯;~½Àß·¯/^¿{x†ÿÎñßôõ»ù_¯7Ëı‹üû¯'‡=ô'°Æq6E”à !4U´6ü€æö¬=‚+:ëKí)oja}öU¤–õ5í>)<;©TCôpõ½aTßèÏcyIÓ60¸aÖ,²÷ö±5aêyP=<ÉR³¼aDğ±GË}<ÖYÒxÎ¿7ìgŒÿû70»|7†+»ª(Öówà¨2=-xôo6Ùr+ñ?şGCğÙ|ƒ`šÁ?F“=Ø ówD	ë‡¥ƒ#íŠX'ê*Iy=½A@mòNFÔ•x•ĞhˆâÊ"Z»’—_·À(+%¸H§…_l‡ÙLmb”]œMÖÃã²H~ÿ„Œ†l¸:1‘<èê¤Éj5y?†½Ìa’ñı!fü›$N5ßxĞ²j{B¹1å•&»äZágÁ~ğÀ¹Hòs;åÜ~uÀWqµf9÷.;Pš¯¦×„)]û¢¸×Ş`–8)	1:Ÿ¾{v1”2B Ñ¡ĞĞv`\ê2Şp=\‰ÁÆ„g>Ã„ßÚQö+p
œ1@Ã(ÆËç¤sø`ÕÙÕ¯%¼"åM'Y&O³z1 İï³&øxºŒp:EL¦úÏ³ÅŸeBùçëÉÍŸ•›®&˜©"µ\½±`ØU¨y„Š ¡`Eá|ŠÆ1y”Õ5ÄmÆ@9GOÄéiåìv¹Ä|n³xó>;¸P\Áv¼^ÂÑ…Tís–|sŠÈ;,s0œ4=÷*ê".fVÒq‡5r4«å¯Ã>ç1ÉºÜš®
õ½eŠÏbƒ)ì…¹öêøåûëÓ%|w8Âäœ”¸?èhK‘âHš0j¶[¶¡ Õ…&Z˜÷ûfú¾îl%s K¢:("…¡¢C±¦cÂ$~ï£ê‹Ò™É¿²p‰p ²†y6œk„‹±®¡±2ĞåÆÜ„BÂ° £(	x99O‡góÂ’'sø£Ì~40qZL§ç FË€ˆB¦ø¡ÑãR6n$>ø£4‘¬†˜¿ÂCJí° ?ÔcªŠv`‚âh’xÎ~5\àŞËoRS„`òôbzÁ8-,ì=â=¤Š¦ğRBè©…o€rQ#CSM'¨8jÃ™–<­’¤0MsôFE%Uë‰†uÖË—6lNG—£êXEª:’Ùõ	ØÿorÎà…¿R1: E3.÷òÕä’ş5Ë$ö/š¸7Lë|6©ÓÜ…ZÁK4.²¨²{)ê™¿ˆ§¥vÉ<“5>çk4“³†‰¸ÌÄÏ1+‡M\O­Æñzy"ÁO®îŒ¾ÀâÚjÊ&e®mOÛ5>,‚¸«Ğ¥ßA—¦ÂgŠÌ„2J‡5½ıÉÆ]í¹Pùãvm«“7ÓñYQëÊL
µgõ¼ëéü[–dì-FYĞ
‰"6†)@©RxÏ¤™DQdŒãP•0Ë~Š—^3ËhaÙ©‚à•C•Â"ó	¹Ã×·ããÉÁ_OáëÁGşºª¿¤gZu2Z/ÿ€àøŠdƒ*céˆb»ñk¯*èÈØÀ¢ya$û—@i/%CÖ|z99{?&ÊC˜Zç¾BDñïÇÓAG›ác0QÈşàß¶Ey±:¹´üœ`ÅVJšVR‹X¡-`CDÛmbÓ‡[Ne5ADiÁ¿™KÇG”®>cWÆôôºù÷X¿(º¹$æÈ²®#ÖŸ‰¡X]ô…ÒÃÁ"=‹¾cBìCu5cÀ¨N€¡öUõåÊ{6fdNºİßPÙ,V§ÎŞ EğRWé†{#yf~üàµ,.íÁÙÂ3üºz‡¯PóááŸø£èpt¯z_ïıê0H8_°Š§cø–Ëùt²Èã†¼$ÌkÂ¼>ÆDKøÍçüH{¾¼Xx‹ÇªF'÷ÑÔË‚,ËŞWìmŞïC~S9":Äúîé»Q}5»XÛŒn'(õ[Y·q–!ÎD…TD)Ù.{].>Qn°¯Ş wFJÀ®²<Ÿ%wÃ¼I>Ã"ÄšrX¬àğ‚?ã3Îkµq²Îü¸\ŸÚ¬C—8réEt0ï•^«—Ùƒç—úqxÏÇ!«®çÂSõ"ÕJc¾†ÕÄ3á\–¼\üI–Vóİ¼c¡p¿òÛ£oÿ¿jøö!‚»×ˆiÏN%Z¿÷(›ÓÀTê
ûÂ¸šF<xàW=Z±dG,çç¢u ÄCÓü&ö÷©,yËfĞ]ù!¦-JvÁ	
¼\"°Šø‡W’QdüŒv±bv1ƒc ÉUÚ«õŒ~À•¬æríI&œ;K,´ÕLpj|³gş*…uHäa½4Óc¦¹F]gİõs¸Ç°Øû†±©NéåÍ1jĞ«³_ÎQu]Uÿ¥>üQS‡IãEğ²$î…®õ_öŠÃVSÔ”JpÍ'fonFzZX%¹uCHnNµ±‘
Î4-<Çô§n8x
Àñ¢ÍÍ“ıê¤Ò¾úŒşàk:ñÕ>‚šIB¨2‡e¯g’0ÎIpAm¨ùr6‰FI%õ:f§KâTuôŒA38f=ªf*à6+†‘Ùì>+á–!cªÚÂh£†¦]‡õ>Äp°¼Ô2“İş’ÅÀ!Š_õ°GÑ½:a»çc†ÅŠS—äÈ+ğ/à¥$ºÄviaø7›&ßzAä*Ö&Öú;X²¹Om…œkSí5K±™ìºà¤³ÓX]µ.òï®Æfº Óóˆ›¦ËëğoiÆzo7Ü~²İÊÅFEh{-^,ùËY¿ØÊÏ²„P›)f!c!~WGMÓğV§ës(µ9x£WÀ"Pºu¥çÌê|
€a	‡O3Ö!zX˜‡è(6VÙäSkÚJÖ‡XÓDE˜Q¦KNl‘ùĞÎôÆ–¤¨ÍrS\,±³y·q”nA)½œqÖd	\K‚¤ıj^/µÓ\dp$+iÕ"7pwObw³˜¾c¾E€Cˆcôİ”ìÖì{¤%âÀY›bpì¼¢é`<
RlÔt¸>»„?óÉæÏÈ,‹ş4\
ôÛf—/êl±ß][êhf¯	r;o×ˆ€ÕpÔ‚›”¸Š§\±Àüÿûw.09Q@æ+·@6HÁt“Ë4ò`ğ„^¡ø¸|„gex/VÓÈÀzPƒç¬M¯²éá•Ğšo3°Û	2Ï±ä÷·Ä¡Kâ»]i„¬iãº*ĞÇeÎRVj+d_Ë[|pŸr^Øp^1ªÓY 1bƒc.@B=di¼érdhŠlü*±q¿²t	vÙv)1Êª/fFl9,ó5L‡Ï„D¨0º™Ã’™Ğêà@NÙ3Eœ9ÒÈ• %C^†¯yòW\”F±îæê]ÔÃâ5YŞ~†(A#Êé$f+œğƒÂ“hÕDHŞ™tÇhåî±ç-ón‰Úñ‘gßÿÓO„»¸^âæÄÉæ6&~îWÕÑ)(@ºrµeA
$o‘¾YWc¬ãŞ¬Æc$›JTõr7ı¥ï&ĞŞá:–2†®}Nìä~!ÿVß"öR?…S6d^Ôcu‰ÂW,:™Ú Q¶Æwº³ "ÇÔ_Í¦ƒÄO±D†œ=äèÛ
ÚÁ	Üó\Ãl Æ2JK\„–ëa¨f¹„\“%¾5Ï±¹,SÜR"oR¨ëgMWH–tò>rÇ1iq¤)ä')PYbKj_xÜ†Ëk1fU.Û° C—%|t8[j&+Ùùah8wi* œ
J‹cª-DD²ehO½ Ê£ÀÁbÙìçñWjéXV-,éNgÚ¹Uu¢ºÛ¥ñ<üW8Æ'ü÷ËƒÿŠqØÙˆQ¡!e¨a6ßBÚ‚C%ò£â'¡¬kUîM>ôªÊÜFâ¡¿÷¿%7Ê_Mg)Áô}§nŠîß—!Vº$ƒiU¶îbÉ¨¨‡_Ô{ĞFcE%®éò¥Ã
^ûIêÌ‹âW_álI¶µÁîQµ%8D‰†$Ä†WÆòp02İ(LR”=²|V<Î°½tÌ$•ZRUÒz8;O‹s±KÎE´"RÓóú†ßéF
)æåw–™]fícLËq<_›ÌÙ0Â4•ò0JXÃ°°TáËé‚ÉD£Ü@*±]h™ÆS¯€¢Ü"ÄOwa—€XZª[ï¸TÌe/Û<0©lû ö	`×“mÒ°•Z‹\:\Éş1pµÌ}½»ŒwYsÓM'…ÓkQ¡FZEfı?ÌdZ¬ÇÈ‹Cö¾•o‘*6&[R´²|};;_c;}Ä)×Ø4ew¿!½ ı)i©®ÚÄèQõUY …JüSYD{”“‰XoOßC¤™Ú"”–’(jŠ<é×’oEd×H™Ç`(¹î©İ\ş îmz_Ç²	£ÿ¤Bú¦É"”j>jÔhñU~À>…’û‡­—%3­{;ş(„É;ãĞ6°#Ÿ­!QğÚ¾
¶\)p~)³Èmì#BIÙ¦šæI´¶úJíçºmLzl9“eĞWËåz\c^ÎıK˜òÑ_¿ÔßCşÚÏr“Í²sÌšÕ#Ìf{ÈNÅPƒl †Õ_¥ÇÕáqõz-ÉÆ¯ß<8¼dä¼Lƒ·Ü½Ã×õƒCÍ»;zùí÷ßWóISæËÅåøÛşŞÄ& ÿla€‰šÁÜeÛGJ£˜±Dl¤ö©î¾Š–lGh0/ìÉÂ8•ÕL7×çM!jô¡
 J?Œ´a>³[3Ğ»;šÑC"£±÷º!ù5„
ŞÄ÷Bœzîp•ÀS¤ÄU_ŠY*…K±E£%¶ÜšÊ¡tÈÉ.ÅFŸ©dIó¯Óê[®èñë»{Ù»÷=D“ÙüœCãı*õé¥%%^!©ÚÈ+ÃB¢€xö[U¯“j¬«Z9H,töÀ€CÉdÌ¢yd7‹¢cuô8„8;[ZZé(TÜ›k·È¯•HöÄEÆ0,BØ»¸ÆæH7fùOä(">“ˆœodŒ.=ìtã²ÑL¼RâS¬­œâc²‰O«Ü±$	C\¨¡ü¡Õ{ûÕåj¹¹éÔ|}ğ¡¡.ƒŒNE$“øÚQf†ê±õ7t’xz¥ÒnA*<¿Âñ&S êáP‰ŒX’}:¯±IMŒ$2šü…+È£êÇ°OQ†$‡wàßqÑM6²å"TI?ıÙËƒy•VqWuDS³2CŒÍš© r¡TC"}ä?¹=³9w • †Ÿp‚oÃŸàÈæÇÙèŞd×³kÒAÓ†¾çî®-¼É#{ò>w‰ˆ2„™3ğ•Y0¯œp!CÏuüÙ4\·Õº¨*{¬³
7$!ÛSdW—‹ì“5bŞìtğ%øº‘©ˆHó;7t¡ëãPGçúr¬mn3®3.UiÆI´’t*Š¦~+J±¤`Ò¥ƒ	ıÂ,õ»!R¯9Á<P“'şnƒÔ6CI=/ 
(¿;Ñ	µÖ´¬ÓÔ5ƒÃ?)YR{£íÚÁõ _¼r¬ÂáŸàşıÿıŠÙµØÄ…¸<Ó:ÊDV·È¡È[SX	Ğ3y)“ü×c*«_ûâŸQÿä/†*ù[ØJÎ1Şª1o—‘&bBîúøƒá¥s"±^¦Âq\8G
+*#é+¤ u´Â?e}az€LTÆœSQ6¬I\o»Z^¢Vòc™ŞaIIf!2ãkLQ{±Lè ³Œ›ãıü,®WÆ‘M3ÙZAÔx@Ğıw†SÇ°ÖjˆD\éIÜ3mt#Ù˜¶Gô_€ÓËË=¤w¢Aó­û.ó‰-`É™œ-¤´$oG?Š»˜Ê)ÜTn º¬®—]{í²ÆĞNxyk™ÀVò€ ú¬U ò®Ãö†‘­QÚ´àHu­ìé7Öá'a¨p‘g¸ZèÈqàÀP
µÇ™v`Ã|"•+])j…aÙe¯cˆªÍ#=>á²÷;&B÷üI@.®úª%åŞÀ±ˆû›
º:‘”ê—ºtf&‹‹‘¶šÛÕäFFZ…Fs‡ãR.0t{­yQ‰$Òá{@D	Ô_<n„óÇ-eAÍ™u>L¼4î?±ı:§’­³Ë¶DÜtğ€,ÒqÃí*º¸UGšÃÁ
›ØßİÀ[=dû7¯÷¿yüºşÛ¯öşöú˜NÂƒ—ŠpIã_‚B£}(µÀì‘upêÖîthèë] ‘ØØiObW’cjiõ|nLØcrvÈ;‘Â+ ä z»ƒ°`DB$K %R¥D«É6¥ıFÍ„KC”YrAoÀBè"ŒÈ.üNàœ¼…8ˆ³€Ù ºÈİ³B.H· ±erÌu04á<©œñ-?„Î{g+YsdFİ;h+8ı—X š-•Ùl]…43Då•ëm/ÄÎvÒ Â^¦_-½İ#)$?‘Ã3 Ho>šº,ºœÓbÓD¥0Y/][@#J,Ûß¡^2!í1oG¹c¬˜]ãAÉ%ËúLÍ"èÈ’Ş*X×Ù#İ-:×­ö6²ÁáfÃæönuQ-ü+Hxúj‹~…¨vó¬›+äÛN‚ à¦ sÜ7ÅÇ£wónq˜™æ÷c¼Õ€9,#"-t:K¯¹Õt6¹_	ÚıB¾£ÿı¿°”Q¦‘]ş–ÇäùPÕ€:Ø¦#|HQ7‰X¶û6Ùï±›Â0J”(ãá1Û‰®‘pƒI7ÎİíG˜*‘æcåÒàâÁçKpàS•]õ`E	Öíd’%ô(Œk‰
ÉéT—Aéç±<>æà.oyäÃ"ïım0¦0¼SšºûN<˜*Í°qW8IStM&:‰•n/:@—ÔÛ•(·*/*³Õ×<¬©›DòÁéÍcÛÃDWB¬›+;€J"u¨n—H)O¶1ê–$&BKäÀZñè[|ö)‹2D’'Û›O3¡)«r‡…ArÄÌ4ãØÿE-ñ&7dPZè¸Óa7÷=¹×¡ÿÄÄe*FK$Gš0…Y‹õì‰qº´€—6aK `KÅ±—Ñí¸/§qSªÚa	H9dÉYÒÆá-Ù„0à'R‚fd¡Õ­¡tğ‹Ô,˜£p$ *@¨…§Â´ rŒ€$Î£aÿôÚ(Ò„) ¤p(êDÌª 	šøè),~‚²ØFu¹Oø>GnÀíMTKU6ÑíbPıNrÁIVîË-*X#Kµ×ç_ÒwOö¬ßmMæîˆ!’’²­¼4¡ÅúÃŠs
8ÂgÅ‰Øğ{oGÆ‚Ö´ÃÈm;ùAp$‡²ñáÄ –’rò‰(€ c¼N:îä×§ê³á'¢Ôä ´nƒØIë'ê³½OD‰÷Ù6xttëb2	3Z=µĞmÎCk½ÖDcz†£½ÀÛ¿uÓØn¹|’•c²xx,Èú¢˜§ÿ%BK*=NÔW3vnÀ5ğBkªM1 òÒ
l‘’“Ì-Qãù×“·—±ùé²á1¢¢SVıé
pÅô/bÔ°h”Ú£é²5Ò€zá‰¤8zçÍñ‘"KªÛ°ì0@E—õ™RÛZj´ š(#šà{? ¸Ôj7PÎ'Å’[GT&W®áèr‘> eK%»à)HvŠ€L¹Öè.gRşË’¼ƒîTJ¹äI{ºBß"Ã¥3ÁR)Ö<x­”.ÕĞV»}`´„¨1tLtäÖ"ÌÆQ^ˆvxæìŸrÜÆ´l_÷³å*m>?–fòˆÿø”[7Q”NzEÉeôKU;ÅxŸ¾V‹Y,œ-ñ,ƒ>ÕôÕså¡	Cï2:+²}×ğkƒÏAÀ¸¯§;ßâìyÛ™h€{ø\ãÁq7ÏÙ›iãÔˆŞÑ‘r um)1=/ól¥_\ˆJ• MÀ½EÄùõ=çË©2ÈmxÙ} · ë
Ë¶_†•íøH†×¼4Ö?ø’aØÊ…3b@Š#jYÊ?än&Ï^¦BÈ3k×A‚î ü Üyè9CHJ@ÅŸ­–z;‡ˆ¸ök¿mÑ}Ë$¦Üëåú·Ãô˜ggük¬µiŸî{,äC]n­­aİºtMQAd¾\¾1)Å=Pèt19<¼Øu²8› ‡)'nwS.[°Š„QŸ`[•6rƒß»)úÖ!6”Rh‚+>G	^bgÍ,¦<´wáµLš›èØ9Îğ¸â>fj÷dó©~3«0åÀ¦hœâüøIË%#Wp“Hú ®äwËLéC}s‰_0İ¶Ãl¨$®ªO#ÉĞyh¥r0¬jV¼öì?ø*¯dı{Îx*òÈš^ĞõfÓi±[WõÌ75¯ÉZcü“²m‡Ç¯‡8ÕERe~õ0¤×t¯PşdïdoÇâ¼º/u,'u\'ü×8iæO;¹¿÷:5NÀ8ó<ÖÃÒôu´àqØ,™šóçşÌºÎC8,Û›|šÏOöŒŠò¤)Šµ¡E+Â¯}ù!®Yú]ÒZx#gnÛ¢8NÊC>!uM»–Ó3?1²æÃ×æ9WY¯ˆ¥  \KÍÄÖ6Ø¨RïÎPü gÒ>PÑdÊ”>ÆÀØgˆ‚AÉ‘Ö3§®#]\”M¾!TF™„]Jœ¶·@<hîŸqÎ·ş*„ÖnÌ¡Ô¾g+ôôPc»kGR”†êê%<Î;eˆ†Á`^¸l¨ĞJîÿj.gNáô~(8©2g¬°,È·"N¿¶ â÷rÂã¬ºc¹•¼Ğ÷â >O€ã E M7˜¸¯a´°pİI(óô|F‰4v¡®ôÙš”ëp}_Â´¨ŠdXÀ®NVÇÜs[ ²V’wƒ#b×·¸2‘{V²Õ³ŸwØ±F;ög.¢ñ‘l8¸_cÓtfDóØåè‚°7\¢sº…I8ÍCóR_wº|·ŞBW¡QİBÈ=Âş¿™Ñ«` †¿´ER]R%Î ·èş“*Ä “ˆ³*‚$ıf¨èS(¬X°9"ZNÔ…/!Š.)êl”QµGÌ¦ìúhi:ÙDì¥–6ì3oÉñÓœÉÊ{Ï½&°°"ÙòŠ:C’+ĞĞ¹(VªÀ¹5®
”p’£&Å¸ hX$şaËÛŞ¾´†U+¹UU ìF»¥o‘]1qæS=?2»ã|¶‡h-¨Kìyåf¯F(^ÿ8ÊrT³Ëåª¿$I’áºxÏ¬Ù•$™>³«Ì l·¸-‰kb1*™8‹p3›îC÷A|;™aj!p»¤Äü
^/»¸DN]#Ó±p;è9ëb¬¦P©ä<wÑLÿÚÃ[p3â8TÌáü—f·PG<%ÓzhºÒû‘*´xVâ[ ¬dêÚŒRá&ªf¨ÂØd²Ñé5ÂÉ\äÂT#Xz•­Œj >>ÂxF0_wÄ2=/[Î6ËWvXË{ğß-¤áˆKüÂ±o3:Ê†?\Bîbd)$9q?îIåæqéfjĞçŸ íjäy˜¼‰*ìOˆƒ”Ö€òœF%»ÄŸ&ÈÚ®ÚÃdg ZÙUşn±QŸÉV=|-µÓ*lO{Ôêèãë)à'X+áWIlÍ/#fZ1+.Ì·o)áiÔÂr¯9D!¡(õãõOè§ ÜâûÅ¹Í;«
@nÿZÄf’.RÂ×Oår¼Ø„J—'=+Âc»	E£Ó¦W­Š4Ñ`ødn7e©P‰}Y@ŠR#ï]ò¶é`Ìq¤péòÑÃ~ÛØÕeòXÂn»øf»š×¤Ê\J†è/¦E;Œ/™5mQÎMø…›ÍÎ-[°âG¶ïïl¶CVd–$~±o)mVĞ'd\‡K×2±ŒZÈW €ÇFBñ·Õ#¬¹Eí"*ÑCµRÂ|+ëóí¥M®” ÷²ÑÈ¦xôÄ¶ÖÒí§½mÀ˜¼½–Ş¯ÚÈÇÂvG|wÌ¾½Ó‰5vR~oÏQ²TÅóŸ…ËYø„+	{­Kùf£EQÔBco$ÂÈHCkş„ãâyµÉ7ø4YÂ÷]ùàÚÊõDªˆâ6Á&"D5yk¸æ°q‹ÉöÁ$˜msìV±cªŒ™Š}rÍ‘ÍBğØƒ!§íK®r¹ÓÏ#à®A|?f(Æñrkü êë+?Îëe}[uåäfò·O‚˜nwQ»
¢1#ãÏöqrÇü-³dôn‰¬¥uº%Š…Ã+Ü÷4¢GF–U Õ¡ï“8±†ƒ¾ó­Ÿú'ÅÒÑİAV( ~Ì?©ÜvÉ› #SyzvhªK‹­‹¼(³vì*œ$Z	2Ó›¿rR1S?*s‚JCçÎä‘e;ˆ“ê©èıêÎ)~ĞXh·x˜US×Ğ´ş„"3Áİ¾V*‚â§ pĞ		}?›ÎÏï»İ Û(«`ŠA2¯ÜöÄx•.­h”*ãa1Ä*ÓÒ–ÂnC„YvdKGltÅ+	H¶3ÚìØcmÏ¸;Œç Qğğ§ğÜÆ±ÓÀops0(¹ùñš7yKl ÊA3ˆ~3 ˆ[E®cÒ,fNÓV—™zš!QXárn½‚Ûß„ÁäÆßŒH@Z„Òåì®&•ÎÒæ2µ?£ &„š>’±?›ñë‰ —ÔÑ¤1¤©÷3[ 0ˆ+¼•ªG¶4¶ã‰Ğ„Sa9ªQ¿j°’^L‡á´î1=cÙ¢/ 1“D¨f¡"B—ëòÎ°à{à4'[lmÁ`ş„Äg¿ß©"LWùÆ±tM,/E´{á
T~ÔÚHˆüÀ¨áÁåÊ<Ì‘Ä°åéà# êœíˆn›*Ê:Xú.À)Ršpj•ñ¥|i‡+á­}+_ëÊ}Úiiª£iÌ=*
ì‡¾%W‘ƒİˆ'++±»\i5Ì¶FJ*ÂµãÄy$¡–aA5«† «¼â$1'¡çiÑåƒöBÏßy=¨Æ}ü~—ŸMF‡¹O¦.Èa9F³é'Mqez}³~Ÿª¥÷í±Oˆ©A‹Ó‚Õ@kÔâÂĞÑÜb¹8(›$·›2“zÖ!±k}º"V±ÛãËNÉ&Î_n~ïèÑ²@âë{#~Iá „‰Š#uÉDäÁªd¼sÚ›÷òSr`B‡˜öõ¤ 7¯ú'£Hô}8#¿’^â™,Ç\AIF™	.ù o,A§ÂÂVÙQ«/&·¿™Ög¸c›{#æŞyğê¶êš¸ôs×á¬lAd1á¨’DWÓDĞ<A¾ÖÙÅÍpiaaaê¿Öñ¬È0(sIzëpñód©Òœ^X­Y2„aRh¬÷lşa»»èïWè˜éèv=ïámR Ó¹pïNımr@CG_¹cWñ·T§ïÛÜıúŸø,ŞqÓI?¼¿¯ÎÚıÃh’»»ÚÓØG¶7à7S¹®şàÜÀ»´ûaˆ±ƒW„ë}y­‘‹3àÑç“•ÿK¨,“5
 eÖú„38†:ôADÓ	Ë§á#ê–¹<&kõH Â°¸Oâïüw^úŠQ‚·_'p2¶Ç¹HÄ3ÎïaršOq’ô‰®be£4r´aÖ‚we¹›ÅY…<°²P\½U1ğãØ£æûUŒm—a€F“Åúš¯QóH•&üL’!«1È.ôØ;E·éá2<P\ùá_÷pl|b1Kó“}ÉòW~nº›ú»4¸?è^éø;4şOv]{ë~
-Åüj	§#éå€‘N‰‘ÇÆŸdfm@“üe‹ß^á´Ë'áÿEŒôÇO5ËX5D¸®Æ“/õfÖGñ‘ğ×ã}ˆì2'ıd¨èh‹…PWûÃSûŸ‰³¨g·ùpRwç¯µÃ¤OÙ!3ğÆ\]Åèø0Úİ³\S¸4OPêRn„p÷v,ƒäh4+èrü¡;R¹…{Ç³ı<›9	ÖÈ¨H‹gN"­H³YS­&Ğ
•®0áÍ&X ÂÏQönnÊÍ?ŒÀ}ÊÚIOV+KíFùŞM“–n9G‹
+?òJ2•-1C<@n>.±çÌ ÜV×²×ò^q",Ç±™u‚ÏÈésş§"«<‘fÊæ˜¹o.y¿í«Îğ>¡ÙB=O¦»MN±Õ­´rµĞÙDBŸ³µãÑqï‚Ó°ï-ÆîÇÆL¤:å9¥Ì4e…¡å‚›y8’2éb¿]G¯ÑôfÈ
¥AÖ´¢Ï¯pË—Î´Ê÷ùµ/=3Lò áí(£*^'’}ZLEP)ì0p†d‚Ù9ÙÎuœÉÁı«0f¯æ Ş/A6¡Ïëƒ¢Z_”³ŸwF‹–½jñ0GFÃ¼ûÈ„üF…»+—Ù®\¥naå–
…-…Pã·8Í É²3¶ óFÓ˜È]9[ÄÙyD@…Ø_$ÆŠ4e9 ]kˆÖÃäH„¹ÿæ0[X±"VÒ9×¼ìjøbz}¸‚†™ê÷-cp…ıC;Ø)3çï×W0 ËÓ¿`_y;:a(ÙkØ»©.¦ğú¯E2·Ï¹ú±bs¼	iZ3`KL”rı~eÓ–•5t¨%—º ª¹ÅæqšÒë%ZÔŞÇâ´Ã€›`E¢F²øƒ5»âºJ¡‘¨xgå˜µƒ¶–	çîáâ3Xf«…°Îz²@¢¹Ë]ªòÿZ{®#¾4{“´e^üËê’ƒnÑˆQq ’®³‰D²„–Rk„ÅvElp;û)âº^Íp¹¥9S¦İe³jEíÌJĞ*Ú¦øR=”g×\a9TzPF=.‰|ıĞù&y:r¨²O¯E™÷/G7l	L4ø‘:åpµÎGÕÿyï“(¤1r‹··ˆK‘|/ª›[L’Z e^P†ÖÁáFç›3‚¯ğ•ÃXğ[`Óİù´¼8øğsP=Å“‡­¬qp(ÒA¬åÏ«š%Î™,Aøèéa;ï+ÿ÷ |3È@ş:]á¤äUA¤%·´+â‚ÓÔºW=ùHDxQí>ÜÓ¥‹oÛ=ÏgØN­AG­o§8{’bfS5é0‘šÇÕáñC©½rŒD¨WÈEw—"^u5C:+¶¤ÀZ#Ñ<ğ[ñä¶ƒmi½J;!©’"ÕTº„ùÂ‡é443Å-ôƒ´–VVf¼·‰1¢1š+-^ÒVÛ)VÎ`SÆİğâ^æ„[¹œ´©áòuAUäÉWŠ{±K ©î	¡oÕ«QOŒä 3#ØB1_ARhrÏ'¸zØ†(¶®±Ä-4W'@¼˜/'Xv¤
Â¢"·õXxpg5Ã½ğ™lª7×;5šûş¢âi%m˜hÒI'º‡+¤#İD
6f]{©aì^ŞÒø Mr½»İÉ®HN®Îª€˜A¡2ã xT,ø­–7+-É"ÿÈ0Óp“¸šÌ˜!¿»İA/›ÀÇ¼>UR8ª´àÙ6,ø#=¬IÛC)ŠXpu0™¾æ9ï“9Î’ 5Yül¿xG{Ù!ä`<ñÉê¸Æ~jè1û.wŞªGÖ<ggŸ"IüÍ´H¾›ŠkP¸¢Gï/u0=LğP”’W­„ÌÌˆ.;NÕgm;8±a|ÕÂ;à"R$$@Û*xi¸“f,NÆÖÏ™ û•4$kÛü‰¢haåºœj°áò‰XÛò‘ØK=Ì¥|a&«ë•m†)\	ÁE­|JN•Obô‚4í|ñ_I|ÿ€dDÿ[aJ¸Ü¯DNøÓûÖ˜Ôûœê}iLë}ïü{T]À#vCHáC6öÖ4†÷©·8…T’›u{%. tVoŒäXCØH'6%ÛäfsˆóÙŠ§\ÁAUF,…]´tµ„'J#UOç	¶Nï0®ò%ô©ü±LW.sh%Âé[™–]‰ù 5/…Ùï(Â?åér¼‘¿å+éo¼
zQğ¡œpe@5¤,Ä~ş)_øÈ”r7Ë×Şå¨ë_Ëbg˜XÖ†„V7iĞÈ¡OR/Æ…;.‘¥=¡ù‘U–ÔÅcPòµqñ½Ú´RQÂÌfAacó¡1®ù˜Üj>3~5“şæ3£;Gò‘I¡*É9bñ±îí1#®Ì©– ö…%{+ğ4jdWD›l°;¤Ó·Z'ˆÆŞ—	6Ü%A†[âíhl ,xHêr­7§¸Kàg8pe¤‡ Şb«î¹‡œ‹µ{;å™¾dóèb İ=$bp:Ğ"Ÿ~îØUh[)zœòÉåñÈÆ»¤Ôö¾ü‡)ìæq!Èb\².Ò¹’s…ŠBAŠ­£S@õÁ¢J+hÂP.ŞäÀHÛJ~pĞ^²f­¢tppp°XS¼±õ_å <+ó³ZRÿÍëÀf'ø˜¸‹©/ò¹_¨Áö=— GÊş¹òêGÕ¯~, ü´÷çdöCó:xç%¢T yƒÎRF{\ÏG8ğ)µG IÖ¬Ê2¿°vÃ!"&ÑHŒ‰¦½×1äÅ½‚—Å²QÁíÑ2…"¹3ûÕ½¢rC¦)ªq+b$í#F0ßóô7ß‰R¦&Œ_"Ëx‡‘Fjrxı÷,Ä)Å(8tå‹œèı÷D‡âÎåìÿ»Áäâü›èP!ÍçÇjbë,ÈìP½ÂØjN•–çhUSŒ-èWW!Ahä ıš†úırƒ/
»¦té¿ƒ«	ÎŒƒo&i×˜;	<Ìr$Šˆà_˜mi3[!1q“i-ªS•kl:kÎ‘&Ï y„!‚”ÃG%šƒç\E»FzºxÅUPuÿw¾…'Œ#Èu×¹òŠÌ<jfÜîsšj»ktãQœÌ5X×?Î|ÈøÃäÏÂü÷O¶"õ‘/,+«Iÿ–Aô;ìz,ó÷5îA‚;{³+då&¦¬PL£)İ‡‡L¸Èóg>û;[i¡®?Z•<¦49,IrB1[ú‰ô´å
İwuî#÷?²—wQ7ª™jÈ'R7qß„²^•c,şE\áÚêú›…»ä•òX¨ØßY•’®tÄOÛ]ô$í4”4	üü|=0‰ç ^ò,á½eTrüËš·“¨·ìûwŒ'ß!m±Ì‹›öùö…„ÔmíõŞúÇK[‡*$¼q;º¹Á®~Q+Ş»˜Yñ_Ø”ı÷Q|ßÒ€Sú£‹ô{ß&9êqMşs.Şküó4§kM±¤µ}’èétLæc_§N¾-Ş×İ´µ°eÂiIDHÆOXùï©¢šqä;¢?«å6ËŸ.ß2I÷+ùŸ(TùSE†ìeß:f“¾Ö{LŠ'ğ^q|¶¼yÏ“R®ë¡üÛ(¢ñú8ï'jk¨3À±”_ç±ßnŸ¥¶ı}Ç—»$©KÈÜO(2½ºòÉÏQqdƒ,t&üÓúæ66–+¤Kf8éc»8yóB±,&·Ö)>bâúwTşæ,øg€o—›Å– U|ı÷Uú-ƒCÇ'şGÍ“]/­Œcüœµtëá.c±#_’Ô=Aşô*uFı¨ñTBôRyÛÆ'‡ÿe’Iß:¨jÍtCx9°ş#Mÿd-¼ıO£UE‡şBúã§Í”¢”„°û5S¥ÜOŸ4†”Øbxºu¨`\ïàÂ%ø‚Õ
Y!7ÜvJ|°wÓw3¿e¹ÅŸ®j¤1÷KcYà—HäÁ•f÷7×Ÿ¶tAÁìO.¥†_¶6ªÒ.ãæ;[Û&ÅŸc_Ğ­8Š³H‘mVİTÄì~öãç©s?­3öi…œn‡¸"NÅc§GĞo'‚ü< ƒ•[Š'n1ôŠl³ú©nÓ[ìA‚”6«Ü´ Çgb7 nàÆúô<ì!NÏxY¶ŞTeÀóDÎTv¬úl[7ó)sv¨”):ïw_bÇî{[Ÿc#tL¯æ¿Üœ>—½‹uTşëéülROÇ8È·‚¶ÁkVú%(»,ÕHY3–$êòM;ªß3)kşâ“<’Ñ¿ÒIê/¥!ñnãá„îâ?v’,Zñ0~RÈ9:ñŠH7®)ãù9?~P&[Ùp»·lôÔC¸ËÂ)Ù²CYÊ¹P>åˆP>ivw´¡b6 wËKüƒ‰ï;j4~%®Xeƒ¦ò»Î«P6J60¸Æ“Fy#Õß)Ækíl
È‰ƒì rÃ
›)éÖ¼ôÔŞÎ£#!õËåàş}<ˆeR+‘¹Ø5l	ágÚÍÌñ¬–“%”ß©"mµæùœ—rZKš>EÒ9ÌyãĞšë ­µ´óÔPbrQÌ$ê{ˆN#l¯`s|’­¬Êm(X™¼|	¢u1vyÜÔÓÍùÒnC*w_-gØ+Z¸/äÀ€OØòg$6	'Æ,¹2
äM‰_ë5!¨Ğ™Ì”òì[Á©~.Hëä.H•óH¯ÜÊœ`kZµ!Å“,ZÉµÿ3¯YW1—-zÛÃ°>©÷ˆ¾„jM±ë[ãFn§DAMŒr‹Z¤¡‡~»A+:P®ÂutŞNfr.¬ìÀ6E“—¼—\`6›ä^Ë[æ\[±fÿu£"…©ŸÚf"6°ÊvC„ö²u^u°qEº¿e¢éqÒˆÁèzy®ÆF¼E?E'6¾cƒ#J·ºô­u ZË¤;ÕŠ® 	ÂÁNdn m?v5N^îr¤‘<;›}°=ƒ+ Ÿ%(t„µ97le´R‡Q…±_5my	\:!Çr`0GTÒJPÖ¶“B6%6 v’šì<ŠÅxÌáäÇP«Øş1öcR-‡só³#Ìªlçº†±V¼Y¼Y,o® _ğºƒD,4$µò…åÉn²/ÍÏZ0„r6ä‘íYÓìQö02ÉêË¾¾‘¡}z§ñjzm›Ş5»ç`±=GåæÌÄIö¬f¤âLÓÍ›ò–—‹Ù_y„«…£CXU‡Ø¯jB² ÖËl£ h>};;Î°ù|z6;Ç^})¿Ä}iËëu!ïßcŸ3ì cÇ 6å s³°û{•añlÖ>ÜšÑ$V×‘¹›e•†´XW”æ…ÌçØ7­ô¬f—¼$5BÈiÛHõj
¢&¾¥tvŠÉ M”câŸK/'¥ÏÆKcö!‚Ãc”pz6ûy«VîğdlyËY)dÂê>“ƒ;p±!ÎœšÖ¼ó/µßR¶3ÁåÖ‚êS»rvO‡y±’ÑSdl¿ÿáé‹'ß>ûíÓïÿøä7cŞL?>zõêEéZPøİIˆ÷ÖİÓa×Ó¤"âçÆ/ó¸x
ú·í‘*İš
vkÍÙ¨,çØYé¤£éA„!J,ˆ&†¢I-,\$aŞëĞÛÃwsóyˆ$ú}8¨†_¨q±Zù
·&ˆ²e•YÀØs|Â;‘·+%±v5~"+ÇÉu¹o£xïœ³EW«¥.ş'}%¹C²Ò€Ù©h^ñ®%htœ¡ßq‰Ğğç.FÃ~–Çòü)î ¸óô©ïpŠlKozå|÷ó¥LÃñRßÁEZâRošt‡vË/Ûıˆ•Ğû8V)<rlQji'È^˜±GßÃtÖ<z‚€œHë²99€‘MÀìÅs@yè{:b.m÷³R¥Şã™(à<Õw„Ø¡&vº§fz9OĞ‚™:1ö !ì~X"û†çwÙ±'G…
Õ¡O¦}.”Èéf6T©|}·»c¬5Pì¢Æ ë4±iA¡nÜ´Â·8Sç¬üuZ Ğh0‘ïøŠÀ=K¹ëÄ¬0üñ¶f‹îò¦wm–-Ú¹Xİ=áÈxßA±œj=‘©|WjóIDŒqÆ@Ş;vÏ–q1Ÿ4³~œ€Òå¤ –O&›õòÛù²y
Ãôz¶îx,MK HÆ*\Í.¯ş®Íê‡ÉêMùê"_¡¶s4Dh{TVmñN`¥•‘Öø’7ö|¹üçşgXëµD³(s]‹’‰%Í’’yZ65‹åM6¶5àT=Ş}/ª`¹‚›ÍÿüO8šóá—_ıSÑú†Í¹Io¡ÿBçc˜S©.øsœ8„Ó›ŞÛ‰Øu³‚CC¦a¤-¢u|ÆÍÇÅ=ñbøÅŠS ³ì˜°tjw|ÀŒØc)aWş6ŞùdEâµZI÷=»Ä–»Óö¤UƒïlÆæ1dD¿¦è„ÉRìnB8.ò_ÔL¢¾\ã£[‡PÒ„í€r1âö¤ $z²ˆK¹Æ¬§¨Ì,Ğ­|`2±<¾P¨í Ê¢8œ$Z¶—‹z;$¼‡°¨õ‹1|âFŠã§†SïİA©>?ø¸&¸ñ£~/+O?ÎûX}ÊBJá°ÁŒD°aº¡,ä7oÛ†qmMÏ(¹ôÊë]³E¢›,øÑøvWÀ ¥r¸³9~!‚Ar„Ÿˆÿ.¢®fV(İû=‹¸fî†i(ºˆñì{…wäíó,-;­Ş¥8q2ƒLDï‹,ŠíëC/(­5Ú.^¾_œYgdø7¤5“–¯mö<¦äˆÛ#(.÷õàéGÕgrëm3™nrAçˆúæqõ9Â)%
4y:1I%4OÌÃ…ÅEÚ«óŠ9´£Iœ$hD‰ÆØšµ@T (‡fˆC¶¬6$¤+C/ÎÍ‚{ MôO~eÈıÛ¡
¦è]Yx1œ¿\ã„îëag}C]ˆ£}Œr4›úfv»·Uª‹ô[º¨VŸQ®á¯¬+.
Á>dn•}˜û®Ğ•Ó“ãÍz6‡¡[ÎpøŞòú¤“ƒHGM­N
•ÑUhF#´¤xšDØÍºˆG!…óx%YÉ
ö÷½€4Ã4¾ÌuÚô¨z‹8PÆn_.yZŠ4,³-\¡‡ÿe–°ÔëHG)Ñ\	ç ƒr@æ8N~óãzª.¯+‡SÍ Éã~•x…ÈĞú‚-VŒáñ!ïcO0À(»^è²÷<ÄĞ‡Ãã7·¡ª¸S_ÔÅæÚ›x÷[ª›#@‰Æ&a#aqˆaÉåjÈ+ÅÌ-õA4y•pzºUĞ¼,˜ó2ÚQübèã™+%“ÁçËÚ¯¤ap İÏ"Eò‡Ìı6Rb‘èêfd/¿óàHë4n'/„I^âÒĞa°„ásî¬I§+·O›üuxÀ?î ø¿,|­qÊ×Æ!a³ÓÒ´åÌà;iH|Çw,	¿EüœGçÕÒ¬öà}DD $v7¢ùŒÎ™l6â?şäDQB4 ˜¥®4ñìÊ†‰M½·Yp‘ÊğXOäd÷ëÙõì¬º™cõÁ"ïŸ%&çÈëñË÷×§ËyRäW“KÎK“¤ËàÆ¬¿ÕS|%ñèÎ+àÚ•>xã8î7Ğ•“[]¼Çš"D°|E–›CüŠĞò-´êb>;CÒ¢D*òíÊ;ÏÇJ1¡l&¢×_ª‰jÉ&Ú±d²%q†+&$ Š^¿R)ÖDe›Ê
‘:?Ë‚M´Q¸ù({8°"”cÜú»š^"Gƒ+(%¸q~H1uõ=Ò°¾LÅıíp ¯á')ÇÇK®»©Œgì«8U:@ø˜jˆe#N›*›·:íÚğ˜‘™àU:^`çú¯I Âvğ è6EVÖ]X;óL+fê[›¸vh\2ÜÙö·y—ÈÕ$¥µ~‡¼•ñµI¶öï1ay‡ödAqU‡‹^;ÔÖ•Ÿ„Õœ\¢¾åÂ¸3Œ^’N‰ÑSc˜K*ôëãJ%Wdè/
Pú!ÂÀ_Ú]Z²:aè“ÉÙU¾â½å`Ò™Ã‚¯§]ğÂxÿ™je"¶é¥ß¥}ÎkS›º›xÏ¼“ ÍŞØ^iˆÙ8W?ªŞ?çÿ'eÓòÁ,\¼°¬Ê— ?ãàç2ø°èX“iˆx¼7œ†pò7¼o5 ú2øX˜\;Ÿ-àfÌÂ¼½&óÚ…TŞ]ÉO×¢¦7b«ÚI|‰Ïå¡~¡`ÃŠ^®–››,3ìXßÁòO]\oÖp¥æïÇ¸ViëšŞN‹Â	KpÇ“z(H¯[öı|
ïÿZ’»ÕØÃ¢ú\İ©Ï«ùrù¦ÆUoÀzâ%Ü0Î%yì©}ÅÖßõ-’K×¸\‘SÃ?¼>ğ«¿ñÏı×#~7ŒöŞ2|Mîå&hÿ!eCQA^#+ƒ)BŞ`Â´mYƒÁ™áô+åš¤tàf&lğvx7\­ƒÿ‰Cšc²‘‚L(™’êÄd$R?ÙL–¹ş¤ğî…ºâ¾ÚéÏ*Ûê¥a5i%uÊR" F’½\š	/†cÀ÷\%ÉŞaèçÉÔâ¼›‚wP;u,>:}7mJˆ1zİ[PKá5˜ÔãÊz8éP’Oq¶Ù”/_7=.@c¹¾¶š¾í=Qö÷KrÛY88Ì¾‡"ã gtoí¥˜à¹ûÆµ§*†hA{Ş1JÅ÷=+´0Ijİ`ó’òŠF‰N¤l[÷(¥_1/9Ë¶Fë3ÿv¶Üäb‹l§”®$)H¸>")SJÇ1ÓˆÕoí"ıİ:o–¡}…±©z˜!it ö9õŸTPä¢EÓóz]†-rD¿Y—Cxœ‹8³Wòÿ\ĞÇ`=(Á9	/Å·±>PÆ„HŸÉvY-±–%š…ZÊfïõcâ Ì Ñ.¾¥ ¦_şúÜrÂn“¶Âyï1<€!µ9	™6ÓûèÂ˜»@÷+¤,iVöcÓU<ÎI³’ÚTËóYxúy°CÁ–ÈĞø§_|ºÓW•¯Thçiéà>a9ñ¥'twŞ<â|ïõ0Å5:¨×ïx){,´T0?¦8u0Ø¢tŒâ!X~¹¾’HäC
ìÑj5y?šÕò—Á½¹º­Å>‡òÙëÄb›ıÃ^ËÔÿ`B õr–OÃm‰º\XïÁ2ıˆ¾DP†!Ä-iÔQxõ>AU:QyXp³ì±ÿ[ÜèJª5”eÈd-¨`^¯êu³Ö¡7š&˜‰{‰òÕ¯Êzº!r¸Ì>F¹«…7LI"'Îëäsø©@†¯q¾œÖ\ÏÈî
œ•x‹)YÎ0÷¤Ø_âlOÏ(ç™A—‰èŒP$î	wL&p‰süI³&"rO`åÕ:‚tÉISÌ `vMËV+Ÿ×grl_êe†®o¹_‚¦:3èŠÀ…3Y¥#'øK5ÚY!éòÄXß!J$«{€••¶[Ì*˜q‹›7(¾b5½£ÂBijÚV_JÑìÀÅÆ^L²H&Ø”‘A³ıÕ-¹å™°1ÌÛ$Ø7Th.²M0¤û‡à²ŒTqËIÙ8ÅIÆ7}eÜN€X„À¤º¹•šÀXZ¹ (>¨—UÂ@ÆÒü4—²¼ã}Lo®~—\'„î6›p
¢²0'‚pÀzÛŞCŸIÇms~5RÙ[W4‘À’•ZG7%©¼YŞØ¤P_¸c˜j’ÃÌäÖ	° zÏ¯k­¸w)–aËÔ7¸";!÷Ã77®Îgõät>=X ^¢va¦~pÖØ©càu§N„èK‚±yæ.ƒäÀcï·u1™’­§Êä+ŒÉ‰ÄÔ41Pß'GüåËlû«3Ìäódà\Õq
	jÁãDŒ·oÄ ƒ¿³´Ö¦2õv¯6;Ií"¤ñF9¤³ğ®BHÓwhõyF‘÷Ï B­i¬wSÒÛ§«ÍÁOfò:caw“9+åÖj±T4-f c·­÷jZèşcì@+\ÂÜÙÛo úÒYHzÎjXá&Ìv´WÓ³728,„e,':Æ\ĞÂhµ]@	ÈõW Rò$ºğï“ùÆ~Â€ş…7Äq|!;˜\›Øá=A	A¢CêÇ Æ\¼K©"¸]XuÑÂº„j`.ò®[o¸ø×è@¡º1fç`ÈühƒÀ¹Eg¶À,—{–ZGcñˆ¥7m†©=iÅ£¿¬ñ±VB€„Ø`?ÆGæYü–ñ8ËõSAe¡f¶MCtº/C¾gQò(
¡«¾ø]älÚk{—ôN§òéVÄé7ia?X¨ğ‰G
w¥°Çúƒ¨íè¢ R´Óz9Gä=×6ã¡¢n\ÊhnêêD0ÀpF`Y»…qÉæMe‚Uìµ\î,ıÍô^š*±IösvYœãÒÍ0BÉ-Ñ†4ßÎ°aw’)HÁ†bR+S\¤_qÛf·m#'áé¢ŒSr\<åÄU©Hl	Zq­È3S‰ş[ &Ôó”Ä£œ6M0&92Ô	IŞ‚ÇQ-(<Z#`PŞ6ÔšœÒ6Ğ=UÅ­QÙ½CÁÏ.n6õÕk€Y\´r´P|Òi¯DÄ×›•î$TWÒ7M\-¢BòÔú1Õë%¢ûÚ³.ùAƒ0¢aêmÅlÅFcn£_
›(ú˜ÄÜE‰wY¨àÇA¨Û-¨jN0L½¯Ö³5î™M˜‹#ÆGj`óÁÎ¢$0j‘0 tĞØ*+²w¥üHšcÈP¾äFš5X‹¸èæÔúôÁ®§«KwÚú¯Ö·K'…³w]BQ"‡`øééGü¾BPÌ‚CÇjYHÉ—ã@µU~¦–KeEü¢šbĞº¦×B6ª$;o\‡C^ı€ÀG–Ó6óSGcğÔi… !v'áBäÑù4ÚdkH”¦OŞKœ¦ÌM 6yâÑ­Uw'!„@%Gˆ…¨ù]¢Ğ%qiò^d°Ã?h{{ÄB€=Rô´ßËPËğƒ±gÏxéğ¨»è/d¼bóyÁW6‚}ò3Uü‰î£åÑJ6xáç+iŞÌ$+*¡T`MéÌªt1[ÊQGdÌHaÖ³Eü³ˆ*îü—ŸR8¨Gùp—„+½ºì©(fs²Ÿ>{õä‘È.B‰^£¹PZa»öªºÄX¾Oe¤.tƒjérW$sB½˜êZ6Ö§ïnP›Ñ>øı§°×‰±‰©Â"ò4Ñ3êE®åˆaC®Ü;í
ŸïR~û¶%ÙÏq	óß	Yé€°úÍßwÉÚ‡SÔVÜDø§’&iHéß]x˜6orKJ­ÏÀ˜­*D‰~ê¡ÓzÔ « cZÓN11í	ŠpZøîã<'¬í(eT6
ÁqÑWÀ•FEƒ^©ĞÎ‹„SÜJ¨w¯d¤E\Po0¼º€yGö˜\ b™ŠÓ¼#¾ª—–ÅdğpÈ«<²‹Ë,Û§ºÚkÄŒ{w¤9õ,R¥ºÆ–Â® 4ZfB‹".Æıék‚º (Cìx/^ÉØvìWyíW|òâÙøÙ‹ñÏ^<9ÉÑwdÊL»å
ÛK‡MË G55‘ı6!É‚Pl‘kC÷v
ßÙfjÄ§éú”g7Ü.W0’6Õ®Õ«ÀÊŠNd|’ª[İr\[çª—ˆ¿Õõé÷ïûÈUK[˜Ì=è¾]±Ê)U@[M˜í¬XŸ`•05
n¦œ¤ª,W-#Se¾Dä¨‡ƒÔ›b–ÈE½MÄ÷¬_f+u*€$ŒÄR¯d^îEşR;â=²HæİÛ‹¤ó%×ÂtÓì¦bÜ,_¾g¹®©EÂ½..se…)êZ´"RÎn?~Ô
JN•ıÏ*ñ[¶-@ñQÖ;¯”-XŠj³Æ¬têï½öoĞäNŒÈ2YüÃ˜—GğÈ±vš©½÷¡S²¤5§)¸ÔÌwŞ³È'¤O:s+m;£3‰q HhöÔÈ˜¢§,®T<Ëf™ÅÙñÅk_ÜşZ×-w–‰‡íoÂïĞ–8å.Ù‚GĞDá xãypp±\œNVƒêàk,â,—cùA-¼Ó§ïòd”2CQ³¹ü•z£<÷­xENiM,&tæX	½¿ÔşŸE¨‹-nj9k°Ù Ğï Å,Zêw,z„‹Ó%¬â—2¢²!b<§øŞ{J<mï^¡? 1<„ÖEwPpÁ	)ÁA ¡T”-eòƒcÁ-%ãıcäòÏ)Ìü"n1‡H})®a˜Ös¢ÎÛÃuâÅGŒËÍ1¹gùsÇA1ŞâUC¶à9Ëñkîä¶Ş¬×ƒdµ-õF]õ&mbJÊ„ÆW«t‡×èÇ§DâàÅƒ·/ßê!™>ÓOYÊj_J¤Ö@Ê
¡§|Ëº®5–‚ãã/˜/è;\Ç's€‚Ìe7Æ· Ã¿ÙºÌœÄûİÚ•æ:Å]÷„©, ™ˆ’(†¾lk`®›ìL·k÷»WĞg	tVà±béê+^‹#ìq1èº¾OUI¥”2Ã,åÂõJ³ÌB³w^`–p<°ÛHkÍh4Ú¨SU€N˜u‡D² Ù:„—ƒı~ƒ9ØC[ÀéV·¯‘)ÍÖ»GªDsØš–¨.t¸@ËûİUj$çv‘Wnš„……ÃRúTm²ŞŠ{œbgŞ¼+ïÊ8èˆÙÖù¼Å+vÏHsº¾)ˆàÖ+æÒAİêAõhÇÒÈµCñT¸`©š0p4´å„HrŞ°!<sTíêıCÛP]ß^W"_6G6§|ÂIFâ¢Dì•MÖ/ìnÅÍÆP7Íî0AK :è`‡$êa*t©FŒE(í†#•LŠßà€Ó¯Î·¢=*[n“aŞP£iŒX¸\(RV7Ö›Æ"¡Ìú6j~€](ªWh'ñÔnEÈ-×I™XiO´_¸K^\G½X-¯Y§		¤Ú2í6q2Ën1‘¥!¸×Iã–õ@+Ÿ€ºß
d¢bÃ~ú"€Ào/³
 Í}Øy3¶87a÷ïoäMT”óX‰u—à(ú¢Eùâcc©éşˆ¢-¨¤™IÙpÀ(,U–ù°˜$¸Ş}=«¹¾íÛreSü¾5mRKİ¶Î$W¤‹7p½õL&(^æ®Tœv`â‹í 0y/vb`š/¨¸–Q6‰®¹XT8ÖDI†ÑLü€Fë¢FÚÊŸ'÷b%¤“9¨r}%US¢árÕ8sŒR	 –X8P
:”¡»³%¦®Ñ9
Õòÿ°™IG-D=îÙßœÈİææ6á³Åä•ÍV›“4ô§6·f6TSiZ@ÀÖj©’’Õ·~Ô@°·˜€óA´½Úf@ÊkpL^Øº4Ò!#İi;6QĞ*wåMÅ‹Ê1³+³U™ô€;~cüCgâèo=%óhsÓÜé@cÀÜğàÒ"kŒnX¹L”$£´ ¾f¨İ9¨ öxn–¤6°h¾K„Ì“ôBíÀ0ÿZ ël^€¸™Á"ì$ôTp&Ñ…œèbS§ÄÍ–óŒsÕ·aéÙ-jÒdÕ LæÙ)&”ì¥ö.9±?IGTÖ…ÿhmi¡óËé{òv®¨Ëö‹5²Úø3¿ƒ“ˆ®u<Šw·ï_»_Ù¡Oº„¨‡íÀ°^_Ë:òSè[N•şÛAı¸—öÉ7wÎ+×ØA´LEâäŸ¾Ÿãz0†peÃÎMÃ|··\ÍP- ®ü ÛÒy î‘}õ#Õrmªxp‰s}WØÕ®^uŞ&¼à|)Ôø êöKf7pšŞÌæ¸Ñ…¤¡7ÀÍù|yë•·ÌH±{M ØE!'‚ÊÖ
¯pflX;ÄØf3ƒéÜp§•ôÏPŒçÂ&&aÎ¥©à¶‰py8ÅwşØÒå95“+¹ˆ+O±@™œB×Â/¬±Ìo±qº‹s+ĞXÕ²u·í£8Ááyvv‘.ÚlÈ²)ƒHà(ı°(çsw¶Ò°›ĞŸ&lxì	_¬-š: »Q8·Dú¥ÌÔ<cziÑËT§…òX„Û€qDO½:¸:<'ÊÁFÛÀky;œb3Û=âïb•‰É-2©ß@ÃNg—lxÛ‰·÷É1ê/P#W—(ñ7í³ Ì(<2~˜ybM]Ç.p$X†u ÜüÀô!,lê£åÙÙfå<è8°ÊÍ´Gs‡r P>
ªU¾PÍ,Ÿ™²•S¾ŒS’òM§@—EšòW¾mÊUù–&å¢ñ4ÈCù¦èØòÕùôts¹ÏÊ–½·R¨<Ø–½bgÕÜQÙJ©` ÖÎş»¸wâ+½İû6t|o•Ş×&rBÂT7DâQiBKîF	ÁzöAcop§˜ôbÔ”˜Ş‚MáAË¢rÖ]Š°pd™ñh[ºŞÕU@D&bx‡”l± è8Mi‹ö6!O]LX‘ÙzˆAØş-¥¼¥ 8œ|.o?OCMrÃxb¨NĞp„ıs&PM;“®V¼O§1bw¤Ûd{ö‘Jÿ;G:l^@I­«ñ®ôZù^ŠíıGĞÌ<ê®¤Ï)ª.şÜ³Ì¼'$@¶>nğì)‚>ºM>q£<7rƒŒàòQly×™Y™A,K©1QÕË7¸{åÛ¦²&AlH®û%šI²‰:iáÆFv¥¸Ò\ìH!Å8Š’F-9ÖW£SÈî!Wz€åÛá<ë
ûáİ+ä2ÿq°Î	Wy¡.8Ú¦+^¾2Oøq¥_Ê—ƒŠ™nãI£x§³ˆJ]ÏËªnñĞ„mC(…ŸeÁÂş¡dñ;İfp¸Æ¡·U…úœg«à}„U§ÎEs®,#Uò,êŠ&
¹X2Duèb…ånúVH^h,7ağÄıg”1<ÀD"3ˆËïæB8SB LÜñÒ÷vwSˆ-Ş¥+%‰CyBèñ6†6{PÁF`ƒŸ­@w•Åf>ß½ô€3L4´+t¤ÀñDÆDõğ]“Pú½X‚ÛÌ™üôTC¡D1šjO_á8“ïëé%&ùZ©s»+#98æ3IÙ³½\À¨æ³]±ëfÄh9høİÖ¬ëm>á	SFTùéæóàb¾œ|^Ìê§“§Ÿœ~Áïå „² sÇÌ®mäQ¥ç{7”¨‡Ãª,A»qÒ¡¶)Ä?Rm}zŸÿÄ=ú[‹à Ã|VM.ˆ©øç?áæÔÛÍ¿a4¦àÃ"%x1åÑb“U¾ƒ%‡8Ñì*ÁÉ¹<1ÆÎÍ€•ü Ëùò4œBâClÆ€dãMÇ¼òXÃ9aVnnø†^zõÈBZ$æÕQİ„Ã>€4U6½tú†‰ª\C–x–ãó \5ú…%ËRÌa›â±¯öpºŞ–[ú¬Rº*|ÂOr”8eìhˆe¬±G•_ÚÎb„ ï
A'½€¶ˆI6ÂÒïd½lšù+÷N~¾MĞq´…š8É^°gŸ„ÿo;Ø²ÿÉåL‘.~îè‚şŠ¬¼c/K¸¶_Û:ìsé0:nˆ§bƒ¡U±]Í©ßJ™åşá¯~+ÜÓp=g'AÚ0òÂx³"×[qÄUmÚİÙ«=›vµJF¨–Ë¸¢“n£¤5òù‚¹®l$Ğ_ºë#İ×Ï1Şá ÷1–VoVãñ'#Jm9İC—“[WtÊé<•Xv`CPa©ál7†IJóUÃµn¾nÎFšïİêe?I*`c¿ /ÉMüÆ;í~KOQewØíäğv'ÇC/8óŸÙõ ‡ÏÓñ`øÅ˜ñq'T’¸ì¼¶z¥ìMù€Œ4Ö¬¶Ÿø$‚.±¡ïı¾š ‰èäŒç–$ò²j†y@˜Ë:Œ8ó¶6 Ûã„Å×Ól0ÆŒ2ç u&x4]€€Ã#CêàfÈ"nX%ùÉš[âdvåˆge4Œ/‡~O¾pÑK)+
®8bK[qFD¢®CZœ>¶ DDÂ#ÛÂ)­¥á¤3í÷dQJmXê¿m“4iB®oõ…¥ŒPg.rì°3íRH$à†]7—ò:&.Æù
œ¥WÓêbRˆë£ßÌnnÒª8 YkO+eÄ5Hû\ >úÜÜ²ÄŠˆv)/—À-ÛBìÏdşĞ›J5céi83€=ÃyêœXŞ<KO¬º£²ä÷äz¾zŞÜ†™ËV6#$¡\]NùŠÑ+™;XQmrÔ˜@
®
\VpVª®Úe×†óŞ´ë°Iwp¸17ÑìAÀ©<tFX¨Ñ [ttÆ÷î}Xk"HHÿ@w¿fà´ùV‚—J^¹q2äy‘—ü4U¤3!É%ğµÑÔO;)¹˜
[Iå­<µ~èØ6Le_ë4òW{r;•W4öNéR g'+zz;ˆè£î9B(V»‰‰<œ^qÍ2ÙÎÜÉ$ßz¸P0”fâG4¹=«6¶	Q¾KÿW©ƒÂßÆ<ŸCŠíädøƒ4(Eöä•{æi’B8L\¶ìŠ£N-Fİ·Šê Çî"ïeEO¤K)¯´7OO®`Ê&ÂËºØnM¨ÿuõel—M±m;Îf³À•ËËnF†ò%ù2ÿUuƒ0`êi5ÒŠŞ„U!D‘QÉsWD0)ö`'U‘SêËú%S‰¯‘£|ß6BGö¥”èÂ@ãà3ì[{±M} a±·zÊ	ƒt ÜÄ¬¹-jn¼LcˆKèñm…br\Jj§wĞà°ÀcÕÉÔ8ºù LgÁ6ç¦›ˆ1I§VÉ†¤ñ‘‘ìŞ`ùà-­Å%ö¸E³¬—¿ç»„I´(§ºvFJ½®Ùg6×É¶5ÇjüÀû•yİ-†æ%”»Xkë¿Y8ıiù$ÿ*Çnï††ìÖÂTt‚M¢q`AmGj¹£×b»¤‹ÅÕ*LR:˜Ã²6!Hsu=·äMÍB+(Œ³z*²8
ñ†gó?¨˜‡R)ÔlÄ$˜¦4µo%-:¿ı‹ˆcº¡Å:Şv`0¤á¸T\
"§\6ÛfKd3—è+2E'™|Â-?]uX/DT÷32Ë¶Y®svÀüèÂê'¤Ï›a¢Ğ?ÕtÎHrQáÓp+ˆ;™Ò¡İã?<}ñäÛg¿}úıŸüf|ôâ·/ÇG¯^½hI£]şñ{a€›šÛ­ S½]+¦z€:8$¥İ-ì’)w`£hÆ‹C*› 9n¦üM·Êzq.²ù !«µè\]İŒ@CUR\Ş*+ùõ˜ Ç’ÈÇÓ÷½`ÉÀ ÏC¼°‹@Æ–üc›‹4.NŒ˜ lpÑ{t™~&{)RñrÄ—Lû9o9Oè¤Ó¨Ò¨å8¶fyMíd{Í "®câ¡©î¥&4©uiÈ<®fûä
Ğ°Ñó„ù³fºŒáuvÃ~¨-u t"æ‘@r@!g¦Œ  S_í1,T!~"ô=iY¤Î</÷«³àœ)˜ ô`†u’‡Z´`$*hÉ[$Ã¦UâìZ±˜İØã|§~/Ÿ|TL&écd` Q6_ëé¼½šÁöÃ”¡f5x†¨—ZHÂ#*a+ •é»ôGuV:jU‚rÉn(ìjÄ…²ºU€Å“ƒÍeÏ3â±Q)À•]Ş¢)Ikü]!´Øß]–¬Ç¸NŠ7^5ä3Z ¿”%'ØÖë‹S»¥ØçZºY4ÿÖv¨o©*Q'“`DPü¼ &Hr¥C°X.”ìlúXCK†*Î;ÙÕTdÍÅJvè®-¨°ŠP#
œ+÷SÂÍO®×ÙèQG£Á®X’Î¬„ÄÂ{79õÈšğá¢ @NÒpv9|.‘G2A!^Ëäµ¨Õë`ÁÓ¶KÊ£¡7Úü$Œ¦Z9ÇØ“&ØÛ¼Çk4,4« „%z‰áËN-:Ñ3Œx´€²nhöYG³­:ÛÅÀ •üÊº}Ê²ô'6ÀˆA
`ëá8S ¯²ÙñKx4•<ãß‹™ÎÄ!Ÿ	Ç¥I˜ tIÃiX4¬@
ˆNŞGºü2n'`Ä¨N>x‚ëÆ_ÂÖg>¤BPŸqÜY;9V8×ºh‰høğûØ£r2Ğ¨XÜ@ğ#B!À)Ä
Z7[Fô	né()ÆymFÎ
¡ıÕ©ÃúÈª¶1
ì'4tÜ{Œ2BpĞ±ÁÃ.”„8Ä^$.¯~&ór}šï& | Š$ëzƒ‹¹±˜C˜t˜mÑtÓæ‹Ä\ƒ$TØiğ qã#De³ ºúÜ¢	åâµî‚/œ·k«˜òëœ;xÈ‚5ş¶wDo°b—ÜÉqi€+Ör8è<éCs›º†B%½èÀMĞC>x–ƒëD`”£1Å«èÉÔÍñ VŠ5õÑ€˜É:ˆ‘ÇG-|Š~Œ°rÚQœ¾&9ÍQ»Ü`‡/GÙyå“`ŞX rIm6ƒl¾…èÍÎ›B€qÊ<')Ä£;
R d8]l™G¹²eaK}"¸-t¤Ì”`K˜È½U}n’²İL~ §4CXr3´ÁiÁı¼H£6“ªÚ&õ ÃÓ´‡Èéwôqş­Ø°&§ îÂmµ}€«é‘< •®,m•:EEJ['ÑRa<İ/=íŸ´  L-D4¶Ÿ’Êg•hMl+w“ÃQÍ¼¯ÌÉ!òBo,	WK˜ƒwïÿJcÊ!K+à<öwÕÁûê Ïån+`DÃ›Ï-»7¨¡82›³î
×ë6ø€1Q¿şuË'æ; §Jp«JŸÎx„@m›Ç‹°ªH¹ğx{h›eùÑáÓ¶±§D]tcI°ÖKWF†şæ¯`3‹¡÷šJ½¹I	2r
İò!îˆkt  r(;»§P¼Ï‘î CzŞXWn¾£<·ê’KŞ¦ˆÜÖ½·t5x¤cë‚!Èà–L&ÔÆhî`ù¦”¿IÅÜJÜcu>©¯Œ.(?Ü*ñ¨Ë	„HŞ.Æsã˜†]¯qKLìBİä|ÇÈ`IÄ¦x2›û_å°q·2åîKşbK"¢™ğ¾”S~×û™Ğ=î9ÓáÚ¨§èG{¹­9Æm”4ÏròÚñ¯ÓÓ4p1é4–ç÷8¶ıcß-”!JØ¶êlŞ0âSšY+ù¸¨ØI^jg‡!BT¤pÀ›]Ã Nhª;×½pØUÊ-à5Úµ""şÑ®H<5¬î:²Íkóoƒ9M~õ’°uRè_æŒÍ.P®RXš³kXëÌ?¯ìwv¢4û¹Ç‹"ÌËÉÇ-ópSÜæ5}&ÃçIß³\Îıg}ÿ N½‘+¤/°«‡ÉõçoĞ¾ş5`2¥c#®à)‡/‡bìmëôÃmÎ/GÃ†¯Ò5vx#ì$CkêÑ’ÒÅğòü»Õ"XC„·Ùìè¼)½o
\LS´	¦D^F8üXÙÃaSªN9%¦¸u¼S˜¶ J!îà$¼:ôÃ³i²úõÜgHm>áÁfü-¦*>Yè‰nù­@æ‹;´£hKùéÊ;=÷x!eÒéë/şØì¿@ïvÇLGvsNêf«İ0£šb<#^âû´ØHm0DÄáµBï»›úTêªªêÚéóŒOr	ğ8ë3Kaö ïk7,%>y`3%Y(XH4–¥pKé¢.onÂ-D1ØÌi›ûbgƒ SD#O¡:X>©Õ u™áKşj´²§JCHSÂ3ğÕ8!üƒ[ù<§HBN.$Maˆ«zşk0sNX´<Ÿq OÀ³YnÎ‹¹”»ğú£Ãmù¹»:7&|}§Ix†b£JP°ñô KDËjİ0Ã)>ïáZ¬gñbYÊ
Ûj*îİÖBCeWšªª2Sa•cåL¦†íÁ9ú“ù0ÓA³‰Aà'‘e’#9ÔSƒâ­	1›JÔ2ÿ•«Ä'ÙHc€8ÿqÍÌ¥Dy¼	%6*jQ=éËä}ùëjVı[”ÏoCºß ”1Ã^ Âƒ]ª#¬³ùuˆ•„¢}’P°ÙzJìg½¥ôû©]I+Š±O°Êe¢ +İö»Ï ” ƒ~z««sYa¼¿l`AUÏ†´``iÈÊíªÒ p`‚£½ŞeJo’‘…á—A­>.‰K-ñ6!è¦î¥ÊBRİêC0ç\IÆñ>ó÷Ü„°ÆtœàÆpôòb¡s.7ôÈØcd¦‚ŸAa5_Ax*Ïw×“wå&+qÀëáÁC9!f”©ÏïËá¶Ì¼'‡t;s˜ª`èÃæìOÌªşíq_»­W`bÓöañàl*Gçr å¥Ş6MRòH$ßm¥r¶hïôDËıyëËÎr8$­±Eœ]ña¼!•R0LXıòu -%°üÅUä/#T}4÷ª cì
LbĞ1bÅ¶&ôƒqMÓ¨œÆ˜]ÄPrİ[+-^kª¼¹ZŸo¸$'/Öb9ğ¼ƒÜ	åu_G«×Å’[ØŠ¨Õ$ë$ön²âC~¶Î>¦µÒÛ
ˆ­ƒÊic1†I¤Q©'´9°ö8B€ãèí7”q"ZĞ@òw¯–Ëc)¯EçL˜I ö–ÑZ±F4ÁëÌn‘b—Ü‹bÄ@|·Qéê5j².kC¥ÍÙâÂGÀ^E(¨#VÉ~êÏu2Ø¥Ê±|ÙW}íÍ´;ÇºEz„ R,NºBÒ±…â5	/q0`i'²8ã@§:l*ŠDSXdØña+‘¤±¼ùk‘äÒï&.8¦ôŒY7d+‹TOÇqo
†ãŠ*QT®¹®(7şQ;ü0Uwá¡h[¬Ö~™×i%.Â±Ø¥çZ[Z˜TçÊí%–'±®.şhC-ÈJo×' åPÜTkDBğasMSSDÉŠL®;kåÎ ,+èëŞãd)öü41Õ0zkQÙK,ÒÚwØ@ôÇ·vŠ‰‘êéû<q?œ^q„œƒÁœì1y+ü`XĞEJf“·KDÛxù_Aú˜½’æxY¶°Ö·È¬†šîw=y_]`dZâ-H•tö~uºeeX*ªZÚ¨Ä­4ĞLµÅ]œL{Z\$n¡ÓœKÅ–K:ë±.O	¡—9Š'Vh¦œêÍ`[mö'ü°ÖíxÁÔ–†S9Iå1o¦_§R=ûH?ûBÕœg©¥Ûÿæ€,Ñç0‡S£	'Ù€FåàË7å“ü+˜]vZK…º¯yä$l<dfÅ€b–M³-J^u–]U½t·Ö|.ìC-·V%±é·¶Göjr.K	æ¦™¡Lõ“á’âº\H»µs²5Ù%u·Ú%ñô—n;±ùª„pE¼LÔ;.a¤rB”~™¶İ´¨^ølMîQ°FÖa,Z˜^`¥«Û†±Nw°’o²„ñ?AÒô»ˆ¡+j8ğ•CyÄÛJnx'%K-uœW&½|ûX#Àm`}K[°½ŸY ¦ßFrˆ.MZJ¾é‡­¦½ÌgÙ}8"ÄÜÖõ¸,&£k¶è5.
bØÑ•§ÚIe8K²«Jc~ÊÌ¿B7BCXÙï·K–W|é?f8¦a(bV¹Øb^Ó‰°ÓÚÂa(wlòiw@
+2yK.ªïCá *;DRg‰d`å:xe}şMòÛØ¡<….Á#ç€UÇÅmæXFOÖp_cI¼®N'go0œ"ÏƒLb¤¹ Cù¾—Ûáºù=éÊÎ3ùÔ©\KöÚÎ¥ç\ÊîÍ‚jäØu‡™§;{Gó%"d°Ì3ãÁÔ;ÅìŞÇ*ì †Í=Š#kÛÉùwøõòıâ,$oÛ$ëá[_üKG¢z èxÙ×,àŸlŒÑïğÆD÷j¬¨¯ùC÷<Vî‚’†së¤l¼†Õ‘BlIĞ¹¯rçu;,u—¿üÓı4@oÔ¹Sû
±uø!´ÆŸÉ†&Û4ütÇşE¶ìFŠ-{<3ı½ÍWs’Ü—Jjæ«A–4b ïîé`¸Ü’”‚Ò–KÙLV‰«²(‚â$qÿ'-Œ'ÑS´É3Ë|íú´61JN* Wv¡àâ”\îo¥Ü…2tÉæÓîa¡hîU/¦—OŞİÂQ½8Ù)4×˜¯&3ìş”t»³©F›a%&¢ßÀdÛ	–œHî Â´'bhPå‰¸ö<‰3²Š’”É—ƒîB¹Õ”…RòOÁ–Ì¸t1g¥qÄë¤ÛèOb%D®ä*¦;+?}’î¯oÔçÑÎˆÎ„Œ™ÒÈRN4¤KäŞå²Ryl><S©ca~„e¬ O'ÑİäªÂ¹@&õV811
:XÂ<±óoZ`²L±©’¤»Ò=€X®Ş«é9	Õv¨ğ„ÕnÓO‘ dóÙ:[Twä©AŞhËDZTb-Â+z\o"7¡®r¦®DLÓp¹ÛR ¾Dl•¹JÉá×Ö)“˜ÓıÀİØn]çœN­ L¤aÃM gdËj²¸œZßÖFú~…Í•ØÙPB4dÇº”êÛ$j¥Qo–{…Ê:ÙÄµeGŸĞÖ1©×üø}–ñ_$ÿÃ‘›ÔÙlHdM£Ã¤ÄTıâÃÈHòV„8k8ıfüËU„ÇO{¾•µ¡W¸=‡Âg0¬¾X·qE´hY'É‘Û,¿±Ó!q`‰ÚFÛ|}ƒ•ô³nŞ»N°»–™·‡„ˆn’Zò4x»<	7åK6(Õ+©4Ä6­9HZS´)WËt"”Ì	¬ #¢¦õšG»fFt9Ù»cKÅ.×‘0.{L×7ÎÙ1g5Û‚ÛŒ‘†èË(/L«š¬Íêš<¾ÎzÇ¹…r0¼Š¼³rá»*Wêè3dÉB»§‘K2æñn"ÔÓcCS!€šÿœîÑ ®äÏÎÉ·õ#ëÍ*ÚêşÉSµÁcD·:¬gë[Ÿrd1ÇÙ]büËŒ$Lƒ0ûyŒÑ3œïCí¡4}ú"B;‹IÑPîtÂà§%-EùæFšÄBVí³uõt²ûÿ/¯d)"ùG¦öˆüXèD[3ó” Ã‚IÄ€{¹%¾š6áˆ\É„>ÁÄœ}ºB·#6ŒÕ³%‹Œš´“&WÅ›Ğeaº­†4­é¨È!KM[!Û¢ıö¥DLèí"¯úrÑ!mŠİEšpôá}Åãşa#á˜WKGÁü€¦Ù›"PğõédkÃ‚„3(8\Oq¶á—{ßk[`,İ?e%h6ißã^\@Xxl0÷ÂõÚ&$Î°„³%BM«Ó0¶ÈQIq?‘ıkPO/¯øÉ u¸\.ÏsĞŒ%º`(D¼°¸" RZ¤¤·#éwve2Òñ­}hYTIµ¡;=cCZ>ºËò×uO×}y\Ö“h§‘ò¦†‡ŠuË	æû—`C™3¤ö®6Mo¸™M¶·!2,'+Ôu ™ˆ$ôÉ9Õ<Gb¬ÅÕEŸ®Fkœ•°©„ á6ÜI_›`´AÄÆİWkèUàoÛgáË,Í£¡„Ï&XSä¶*ÂÖÉ°^?*ƒ³ÅÙ|ƒs°†FyHš ´l ÔáÂyÏcš¥D‡èˆ;bùÈE÷`©?(CQÂ*ºGŒ5„æzvyÅÕR‹¥.¬*sYäûİÙ7´óŒ4N¬Ú.‡Q#÷(ìu9&FîĞ6%ÿ“¢Hˆa§.“¢™dŠy˜&íß.mÈÉg¼ğò°¬ÁÈÈíÉ+´Ó;¶}÷~4ÊçÖıfˆırSÚÖ2{Ò’æÈ~n»0²†ÂËOìÔE.ƒD–îğA¶»A^-Y´®F:\!ë`Ÿ~tyCİ‹æKƒ¡-æaQa¶c8¢B[£XˆŸ¬öú;ìô/0§»óõÔ˜E|M±¥Ö™]YÔ‰¬Öÿ1[_ù¥±AÉ8­Cÿ
¨Ç®{áÃØ”gÀRÂ¼Á	ó¿6±¾ÙÔWC@ÌÂğo›ãå“ÒÖé&Ö¬»î|ğŒ/š(Dtq .¹â…¯¾Mgy’xÀäÑ2&gŠˆaŸ(±°
óÛÉûZÒj93–sÕaH´¬Âr¢Ùô,8	[•ÜÁ½­…:,AKÁ·jKï¤,(a-Ÿv«Y}Uök®ßh®!«º‰_†Ô*
ÿ\ek)šL;;ˆì²£D‹4©oQõ]TŒ°îP/Å¬`ßIÁ&âÄÏ
d°àè‡[š¿3>	ñÏvDnQfjŠ.À‹›mB2Xçø#=Ÿ§!ƒR/¹3–ë1·^3i|˜Òa)KLÂdã÷Eàd–'V´#Øn¥úxÌTÄ$éwCÔ0˜¸@˜[x“‘¯BÔÇq¾—› Í`Ó¬!ØŞı â1ÕàJ)VsGÉ‘¥è*ÑH~¦ŞI<ämšd8ÍsÔ†O±’‚¼9Øf-„¦=biãğ•Ğ~‚MÕ·Æ·-‘Hox†÷îï
T”9®pò†‰°¨“™4.·ûìù«ïŸ==ú}Ó¾t6ûÍíÊÁNèÿñÉ‹g¾4µKãÇG'İT“Zı!?ËËb»´}Ôß8³Œóê"F]Ãz'ÿ_<ùáèû§¿yòân<maó*Â«"!Xéù¹è=?zñrÜ “èáÚR*#´BÜÀ}à‹p=Îw:9“Ò£‚¡àÈÒ%™]r©g	b–•n¥gğ¶³\¨mÂ—,E(İ5[A”ôh€L¹ MŠâ`tævqë…eEÜÇ„9éyiS¡õ2—¥¡3agÎ€”©0uíÄ†æÂlT1^ö…šd¿IÀÁááÁëû‡Hêj^ÙQ”†Õ)~‡ÚÍº%±a ±å°D½*àÊKƒ óŠPUçGŠáın¢´ër VÁäy‚4æöd¢$­¦ÜçúzöÎtBÇCµ¬mÀF ­ƒ]êq÷aØ1MÓÂÑXñqÔfñOp„~¢“@‘ÈCÏ…]­†–²p‰Tä;b³Ô6m¡Îü}]DEããHz]Ú™ô‹€÷¥JÍL¼><_Ãê¡ÏÊ. LZOİ¬S3U1é|NïÆDh³UŞà)3:È[lÃM2/Õ¦î¾åÜ_Áqøÿ›»ÚŞ6’ü=¿bïƒ!9pd\´¨CáÚ¾\€6äÜ+Z÷`(¶â±¥t×/5‚ü÷{r8äì,Ù¸Õ[Ú‡äpHáLŞèÆŒÚ”Š…ZºXò•Æá'Ë—ÔÏé9 ”€ny¾âaé¼¡Œğ…A‰R"Š`—ÒÅ1',yıÁÑZ³—uÛÍ4¶sŒ°ú#ÍÅˆ€QÒœOÂûğ5^°ÕŒÂÀGz®ŒÆÏ‰iP×ç	¨0é/ØÂ`ß].Ï`¦Êe‰ÏÔ/ƒHwéQéB‘Q¦×—È=2á#o†®{)j¯şÜì½¼S÷B•KaN]GwİÍ/nÄJb]PáíFb]É“£áôU©…+DóaÊÚ½æıÏHÉJ ûù!²à³V9 „~Ş%?54>7 Há×Â®£P0¨‰/g×ÇïJKU—zïS_úxœ/6E#åtñGÿ…]A:/™s¼lÂ¢}#ŸñĞLríp¦ZoäÊä>Œ†õBFÒrqW®ÁvÙX;»‚Ó +¥¬rÅëa£¬Dd‹H{bµÈkbmrXl}6ıO·¦¼dê¥t=g	û4ÙÄÚ}m®ª±¾}b¿Ê§¨ÿ\ºŸÌnªù£/“V³D-ŸVè-ĞĞ#qÁ˜«oâo™•{+¶›&ÿs9YÙÓçúr,×+dr³˜B+1±›AIªèuVv3Äp£_Ò™áe6UlõokªÂbƒÙü^†ñäéÇ@pñ³¬GµäT£IZ‘å·J¸’RY§Ä0»Xi:/V­N&ÜoÛé=n[—ÿc6!Î~‰‘,ƒ«¬"ú@k¥€åº[^úª«ò{z?¹›¶]…—’÷KmPrÒd¿\?”¤õzŸ—áÄX•[LBõzC,Ÿ|Ñ(G¨}åÎ}Ø¯"Õ?Œ‹®OİRe\Šßa’,ÊÁ„<”zì9TútC 3ÒqC{ f÷pP4L:Ì*¯­Áë9½¬¨>„¤¾8 ‰ÂĞQ2öi8‘mğ
*ó=PşŸ›92ÖO—¢9(u’gïàÒF$„Ÿp–wPÑ¢«¥ŸÊ¬ä®’îq2 %=¶'µ³<3Vµê§àÊÉ( }ªæd ¨º$¤ÀĞ§ö 
{Yä ŞNa${¹x€‹Áÿ¸ÿ.CŠ1mÈâ\kûñ¾))ŞŠŠù)@çø¿:y€*ô²‡nšM†ZªŞB²UIHÀØÜôóôòFÜ¬v¥ü†TJ7"ì4£y2³‰}ÆBî£¨€8¢T¡wæEü½µÃyècùÄÌÃXth.(®¸áşÍÉ êÊ½aoÁªK_¨ğP	pò‘JT‚ÅI.Œ)f·wJÊ'¦·ÛÔäš@‘>÷“âØ@ğÊòü†÷t ¨Şi §ŒüJ™Ü€5¿¦ªğ
ÎBë…kd•‹‚m¤Â
L¯±8g&TdÎ…Ô\Ê£“Uïk÷jÖVYG+¼” ÕÅXFêr«ŞÚc=ó8=fr”÷CG‹#Şñì£^±ñP…0«˜CÒéw£ç#¸0u®Ç"rL¬OP…RÂ3·"rnáê RRç›}TGŒ–Xº£è5¸scÑĞ_–É!8 B$¿™¶Œ4 Šè?¦fxøNÜB2Ğ‹”R•j7¤äôŸ1Á÷%­ß\Ñs6Š3PÌ~<ÔSaÔT^H+·f£Â¢07ßrJNò†'óè¦’K6>yødÈü£ë§_Ç^µdG!.ÛA3š ¬IThÕ  A…Ï(óq-K•~„š[î“‘Ëáï$pú¶<«$Åœ§awË…	×µcĞ\Ÿp	%•Å(7g¼/~µ‡ßx¸}ÖÌÏÇƒ5«C®œ×ÑC„³-bn’»?ë†Ó_5R{_@DÒHBFr9* ÛÆ´B §ó«ËË“	ÁğÈÿy£sK›©4Ù	‹=€ò’{\•kFğé%ş€§YºËXNEüaj¡²¦9íG`)¸t2¡m$ Ğ\ ÑA{Ïf7ïİ À_ÙºÀ>˜°{›”ï#K€;XÙr›má*Æ&ƒ0×<$ìÅg‹N<Š¼ŸÄ«xJ2¿Ò{,‡rßuÃ9XÙÄ—P%	õf41,›Éˆ&œ!äFàA’ÂÒªQWµq‹ÏAStä±ÉŠ˜{ç;~ ú!Ñ4Ç¿ÿ"v>Ü7wrrâ~y£!LÔ²pmB4¦É³îÍ°u`˜ˆÙ?×šş#€ô”ôÍVó¶c®EºëŞKtûÉÉ&æ\s¡@wËö#(’ì`ò ÖìXüuï§WóË9`'[¼`&®t“ñÅÍ´ÕF Ûh,wt·ÚHi0_ºÜÎ1°«®³Ù£vˆ1¡!³ÏOÍä9“D¢Fç‹Û%ÇCp¹‰ÔF»9ƒ€¾rÊ‚È>:-ú“³Ú´7»{ƒü =¬™éƒ¤½FX¥*Ûø‚u² âAo.hX.›‡èÃ2~Ë(¦G·ÂÇªN„Ò_™œA5$îî’Ë¸”€YÌH›yâ›*¾„(BLE›ø~Â7Ñ92~\°„¹`ÄR¡P–)'a]d»@G@hègî…¥¶cÌí÷jÂê°ªä[ÃÌoŒ—©FV|&êöá;*ãÙ®’XJ”À+rdKö]ÛUß‹8İnKÑÍÚëPÅ7¡ëMèJz¯Óºƒh·ù‚D½­¨«·}a@'½¥ÎH˜" ^$vNcÎ>,yUp3§tˆ•lô¾Ù[Éb“ÄÁ78ë,h^X!zU¶İ)«SÒ§+Ò”‚”XmL]í5ë;e-r§hg·}:VP‘¶Ï‰zxjf¹ÄW;[üE„mwˆÅdöy*M)Dif1g+Â“¤/¼şav‰„Íâø”CD›Y»¤¶Ö2wi ¢?5‰å:Aä§!ö!?ã}”©5Ñ/ÅØ§§'æ8X=‘Ä›ª¥«èe'nñ®õÛ)³ª%Ğ‹cî˜.m—Şõ×u„>³3˜ı“—°àâõkuÊ‡²a¥ÀPÜºƒ½¬™ğ°Dˆ“kÖ¾€¦s¹ğı4cáMÙjVA¿ñ„­úÁC¥şé0Ê¢ÓqäC’ZiräXAg'Ix=âYÆ¦ò'U)ÆÈ
ö)+BšhJ•²CmÄˆÓÅñ˜8Üàõ2¥ü}š_.İè•3ØBÜZ¬œ¿]’Š\ÑúHGãmçÍ©^öX†qœLÿÆª`êP”?¨Æ“Üâ©èÃãÏ´ö^ì)ßòkóEñ³F|ÉˆLx}BÆëE—Ô”IÒ¤¼nÙ‡ÊÅJßcŸJ¤: ‚)e®qi•ÛUi-ì¦È[#Ïtô&/w`É7bMÃÕ:"ƒş÷`©è«@uZ%IB¸¼8Çs©`D(Ùbs¤B‹Ì¤+|MîÚùõ,·ß¯YõŒ`ÔëÀ ìƒÎU2zk¤”¦ƒ‰Â¯oÇ‡„Ai<Or"2aÀQ<pÌüX‰ QÁ%¨¶l3J‚ÜÜ}ñÓ<ÇÑXn/e ğ›²ô²½0¶`£g¸h‹Ä¨ÅœF{38p(;*»°Ñ-;zõ¾á‚ªm±¿a€İz†Ú,rBŸ§ |nh“Xa”»³G˜ÊÌ°Ë…âA|Ñt=LÚaÙ-,q=z¹ğÏf|û-”]‹ÅÖşúYÏgïn.xÁ’TÒ²L®¾£M›‰u·1³çE¤;²)E–¤å3A÷Øæ\1êõ¢f‹2Qvf
İ³)qåTÚúùDèG[ìâbÙ-„,¨ ¦‰Üîş½ IÌ·*_}¡½øÆ~D<ãJÚ™æı´6¾Ñ4AÅ3¾*mV,o1õñ_–
š.~Lş…}YÖõÕ÷`x–Ö_?@7û^U$å)z9TGaW)òvzwè*O½À14Ê›¿!–êvÚ‚ÊÛ×7@	p‡sAúÒ|ú+9jeÙ¬¯¯Ì:¬¿¢sêÖÍôy@/$¶éói÷,ÜV=ìM»ü„,î÷ãrş°}‘*˜kÜ4ˆFiMZËœÏNL©qkçHìğ¹‰ãÍ>œ¡/{'Çcï4qlXõ©MÏ>Œ‘ïe;î’¤ÿÂW
Âú¨D„ıÛ8XÔ>ı1Ùsş?Ç^nFCÏU¹EÑõº—xÉ-Aİ5²½REÍgx	´¡Ú¢·›·ö“ˆòÓöÂÑÈ'Iİé} øôï¯ßüøòõ«î¿}ùÓéşññÛÿ¼£îZàVfìî¯Ş-á;ä5*óËKØk‘©	ıZZÀdsµ‰%|¦Éˆ†e°ÎÜÍZšã÷R„&$‰æ_›|=x+)JMU04´`040031QÈÌKI­ĞËMax6÷ÑìM¯9{wk®+ºqèIOğD¨š¼Ôrİâä¢Ì‚½â|
‹+ó’u!&fcU íW7©xKÊÉOR02aĞs	.É/JÉËËOIÏÍO)ÍI-æ ®g)x+)JMU01e040075UÈÉÌ+ÑMÎHMÎÎÉ,.ÑË*fğğŸØëº8çU%‹m÷'A ÀÇxeQÑJÃ0õ¹_q}J%¡ÅO˜ /""Y—Î¸,©ÉÍfıwoÒ:ÙÌCIsÎ=÷œ{WÚ®àîöşŠ/Á£S²E–í…ƒç¾“Pƒ“_A9™3ÎoX1áïÂ/æÑÙN:ì‰º\}Êyç,ÚHåçªkƒiPYCªŞê½|;ı$1_3 ÕBúƒº®Á­âbpĞI ÑÜVö%ØÔÇòµÖAN(3¡£ê¨{á˜7Bë|)£bñKé#òJÀ\_ºi…ödèô¢±3£ôrJÛXC³şÏ;ÕÄ§&ğAÇa‘‘ĞÎ®ƒ–\~wÖ¡§ÀFÒ~r†bSõ4Enİ¦œÏfóÊKdešåV™ul'ºN™+“Å4÷êb:™¬ş®“ßl ¥ÿ €=µ…x]RKÚ0îÙ¿bÄiWJ·»U+U½™Ä,VC9Ê1C\…ÅNıõØj+E‰<ù^“ª³¼<ûòáAµV\Ajjİ;ıHHlO—ÁZñ#|~~yùˆ¯¯P]`c|Ù] ÿ¦'$×ÃÑ8glÆA«=‡¡ì½n"ØZƒİCİ–ÃAGà-”ıNzp8`+_šŞô(¡FF‚¾Eg÷ş\›(³µ)[GİûÒ¾½é´ƒêgÅmbö8‘4ºìˆéMÃı
ÎÆ·vô0hçSŒL_wc4Ü¯;sD‹CŸbp•mcöá«'[§±êŒk#hL€®F.§@£àã“Àé®#ˆ`P÷äõŸº©'äƒÙ ÿ-"*çÖß;1ìÇ¡GJ;‹‘MŒ¿tíC%(ßÛ®³ç`­¶}c‚#÷…WeeëÉËuË½õ(uŠ{ZÀ$âºÕÛ•kË®ƒJßC^Ü~(İí »±roÊNv˜øş·ù„üK…X¨-•x¹°f´Àó,‚-WK±V€’fjb4ÛÁ%°Ÿ¹dEB¾ÊSÎ°Æ³8]'<{…9Îeÿe4‚*ğÅÎ-`Åd¼Dd:ç)W»ˆ,¸ÊæBH S©x¼N©„|-sQ0¤O6ãÙB"[±L=!+Ö€mğ Å’¦i "têeĞ±Èw’¿.,Eš0,Î*£ó”]©ĞTœR¾Š ¡+úÔIˆ"Ih»ªƒí’…Rà£øÄŠ‹,ØˆE¦$#t)ÕÛè–,*yYH±ŠHˆ'Ap.cW”õĞÛF°%¶FÓw-0š"®'{·¾'òò{Zïx+)JMU0µ4`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2\v¿ìşYÔ!Û+€—ù•İ9Ï!¨*ßÄìÔ´ÌœT†UË*uÏ¹~mÜêµ8rrvş¥šêP5A®.¾®z¹)ùÌ‚§‹…o×°™”°£ô®s¹à¥%%gè–%–æ”0¸ÅÄì½\&¥/¤Ö»è­°|ñû™}PE™y\^šgä©p}=7gF­öËŸ¿ûí175UHÊÏ/).)J,Ğ-ÈIÌÓM2Ò+Î`¨5P¬íöjÛ^4U>¬øôª«ózÛğ¨×ËÏIa°Yü@-Oæè–!ëïˆ—ÈÙmqAJ~r1CIÙÏ¬G2	Á;D’vnÌiş1£õD:/?%5>7?¥4'µ˜áT øÛß¥—|Û÷?îîùÓ×/ú?ªƒ†HAbrvbzªnN~r¶^Vq~Ã÷—çëÕi,I>Ü\Ux1²³	U1Dİîs^¢GÙCüWúuñr}´§"â¸LÔÓ•‰¹9ŠÍò½nÆÔ>nøa±~Ş„°g³ìô Ş.È/.ÑE„U~A1(œ¸?ŞÏõEşQÁÂeëÎvª< ¬,ñTqrQfAI1Ãìƒ‹®“Ò«Ûtq¾§²ë±$Nw G¡ï¡x][Oƒ@„}æWŒˆÄ mã%ĞÄX«¦¥ñ¡iš]X„ˆ,aÛ„òßİ^Ú×93ß™shÆ)nnïÎ.ÎJ”Ms‡å_ D$š`6«8Š´`1I3íq6õzäÚB’R6‚Ù«ïÈÏÂ)2’oèFH^l‰mµ‚n(¿ßGkÇzÁ 5""ì
W—åRİ}ñè2,º>Œv©ôĞ3Ã„…æ~¯˜]z)È;saQ·+÷­©éõ;î·Ä]—•%/]÷¯EÎåi“³æo˜!‘=Ìòğüò¦¤÷)mºœ+ÍT#»ÍXJëÚ>e¤,‚Q+O#tÍ4nõ“ûñpËêŞÕ™»MÆH@«8f%hÆ·ùÑußn‹Pxí}k[G²æ~Ö¯(4gLcAs±lÉè6Á˜1F:ïì<Àà¢»€¶šn¦«[ÀÊŞß¾ï‘‘—êê¦‘|öìsƒ-‰ª¼EÆ=##³N»ıÓìñ“ÕÇkÿc~TY9tZÃùg,]”İNo¸Ôî”ùi·È.ó›¥nÑ[ìõ—Psé´8ëŠ¥vqÖé_/?xğ1d­şåe¿—%?/²Añ¯QgP4æ›ËZa~á™TÿÇÆO»[7­âjØñ­’ê…Z‹ËüC±ßë\]C?HÒ¢ÔB«ÿfk{ãçİƒ“ıÍ¶~ÚĞ&iıÖEq™/cù¨;d3ÉÉE^¾½î½ô¯ŠÁğ6{‘½=ıµh›Wƒş°?¼½*šik¸ùvï`ëœlï¾ıûÉÎ†|‘­êt“¢·?°h--z½ûvóGiö"û¦®ˆÍ^dıh?¼ıéİÎŞ_O6wwŞÅCÙûıƒ÷(ãØû·¶¤>Ñ	¿Û88Øz¿w²÷vïäİû½ƒ×»[—nVV–ğ×Süy?›ø³…«ÛG7O¶ñËÓÇøó~ù~ûh´½½½%oÿvx4zó”Go^oo7^ÍñÍ¦¾AÅã…ß¯Öÿ™VûíŸ•jËŠ‘ÔıÍ“İ½­“×ï·6~ÜÇ\	êÓoFk+kOåïï+-qŞìln¼}¿ï¦É–‹G‡GÇGŸ~¯69ØøëÉ{o"¤m—ÿ	Ğç~›Ãÿ‡ùÒÿ>Z:~4·ğoËT¶şùıÇ§ş‚µõá?Ã¸èïÏ‡+KßçKgÇŸÖ~ÿMGÏzv´|ôjı/_½8ztôo‹'GÍ¹ÿsôõüQãhP/|-ã>xp6êµD¤NZİ¼,ıÓ_²OÃáhĞgäabß;o¶ònW*?Ë~zé”'[ow-ôñ ³^­ìÅ‹ÙÊÍÊÆò×ÙîvöõòBöÛoYxÿï7ßóı³•îşşÃÎÁÖÉş»Í­‰İ~æùéX¿k+(Ø¿Ê[E}×û'oßO…7í3r?òtLª¦N:ëº
S¦Ÿ²_†×µMÌssL °Òo_£ôpb)?Tú„m?M,eÛßQšRílĞ¿ü¡¸Ùì·˜¿Û‚É²ÎYÖh¬Ü|CÚ¬°çç/2ğËW_‘ğ;ŠˆöïQ´ lä©•-±xåº›dÙ˜åÅ9í¯;%íL†!!ã­ì7´ZC«0úw«"w£wİğ¨-ã÷
ÏjÆGğİjö([P8aY‚î™·([ùUÑ&v‹!‚³7Â<yŠqn8N¸5Ê“"ÉWûÕFiµÇãÕ¾eµŸÓjOµšÇğ‘LoŠVç2ïÆ¤ú#é33eçòª[l	~öañ‹^Ës
&Qñ&:½vÑbbÀ‹ëĞ£ĞsÑBö*›‡•Y™ÏÖQO|5On«ö¤¾ÚFW5¢½=­­öä1ª ëíûÚj+±öĞşê+~·…şzQµı=![~Œª½®­¸×¡d³¶ÚÎuõö¦¶Úwä*QŸÚÛjı =ˆÙâ¿B¬qÔ‡aÔµµújÛ¨¶lÕ–kë|K¥wdun¾­Ÿçc"w/T{úm}oñ$TÛ¨g¤Çt×W¿¡¾?ª·wIE?›‡Ãaë"lC)W}8Ñ©¢}·g»¢	¦o¢'¿ª¡—³­^=f?l/­~—•£Á ‹ì*ï ¨q1^•ëËËE¯yİùĞ¦êäÍşà|™OËÚğOìøDà*O~n®½^Y]ÁÏÉ°/O«+-ˆeT"ŒH"5§6_È^¾„ş\€]¹¡··X[é+6ø†S—zğQMš“X‰l^­Põ½â:ÛòÛÆÚ·ß-<ã4Òâ¼,fXƒdgy9ÌòV«(KYUÄ}ü”_÷ğ€­®ƒÂ•gøçy†¾ñË£GJ“¸ã°sŒºñk¯ã:Ô«`1qŒ>µpMğÖö‡ f£Ó»³¾,ŠJgxÑ)›R  ä_±{òú¬ƒUY~YĞûwçíåüqF§¬7êvÉGÒ ”%•iÔ@_²º4H×M¾i¿÷÷|Ğƒ«7õ/Ñ:djüĞiCÍ/dï‹ËşÇâÖŠPY·Ÿ·‹A6ìgÅÍÖU×‚Ùjs5k÷[£KØ†ğ’Ôg`ôÖEx]ä‹¬'»Vg˜ıYÚ¶±Ä„×û±°yv‹ó¼u[™§¾ôó<Ë»epùkiëĞ5|©5®‰Cf·S‹fcÄ^²•ÇˆE3I°°†,Ñ*¢IËã+³½ãêxÄsÁI^ÖŸúFìuÂlÀçÃiâ¸¦©¯|·Wı²ãÖŞë~°“k˜¾°ô®ÖŞQs.¯•n¾ëşYvÖ@D»EŞ&ëáÔwzÂ-¨0ºúôFl¡M¶ «PÅ¬ˆ¿süÑÑ¸´ÖêCäœ€A.#aÕ°ÓÛå^dôß¬ĞsŞËûå¯­ğc1(Ñ‘Ç„¤õ¼ù‡Ò¿æç‚dGÿ¼×ºèâ7¨à+k©ü ˆıÃ (qxÆĞ	lGĞçd'(‚-h÷A£¤NXÌ.¡ÜòóBµ5×e> nüğ³Œâ¿.ä’êM“~UÁ§£³³bÀr-ıÑDpşÙÊ"0´°HÄ÷/!JÃAŞ1Î³#êå,3*®»¶ö¬=“lñ¸|Ö’V¿;ºì…1­†Áªûä%ó»‚3jºğfEz,bdÆ»Š4	Iğ¨áLiİØ/ıëÉè”âl*ÚSó.œ"¬%½m¦×fê+¯uÉMõ¼8LŸË#r
Éï•İy¯İë
/ 
±²ù À…ÿ#¿ì¾1õh“i!VçbcĞ4Ë”±†­¢ñ×>ìëe§×æuù¢à;YÉæ  ì69ÊDÕóíõHi]PQÖŒ¸qhLŒÿsÉ)*auj÷©î?àjXÂªä­a÷6ëC C±(•±.sÌxC†!–ãGGMûíß–›ÅMÑXW•ù<×l–©wºİ%ø—ĞhQ@û—‚=È®òAYìÀ}”1Wéa)Â„2ãuÖ¬G§PrDzô¡® `ìğŒÌdSŸ`S–x!”)”ZXÑ¥€º¡àÃíJPKnSP:Ğ:d²µ
T„o~Ô+GWWıÁ˜tpÜ"Y¹1q9ÈÏg••¯Åìj€8øM$(U&®Î QGó€"ˆô¯ûÊ
ö `”z´+8övUm²ïœEOC@³9,ÊaC{òÑ™ZYf•OÖPûn,¾`<Ìª7½cW]¨£VvÑ0(õ:%B?˜÷ÇNTBğÛbŸğC	ó×¹‘•ÂÃy¬:Ğ²ù‡ğ&l5à%˜BğVÑ¤¨QM²hõ{AÌ„§áàÖyca2PsÃ mÂ_„†ƒ†p`9ešAßB·5ŠÁ "9)ßqş®Wà1#ÕVXÑQi—ªŸcê*&¹.Òª&
R¼DËt.ö‹súôf{ĞÍ kœ¢×^ÌD9ü>¶BJ„Å©ú¥‹Ù‰z¬ø…‹jèt®úNœïD˜œ­…SúœıÙt]À¦ ÇNO=V>8hdèA_p—@xpC˜O $®Ö³èå#ìtì<L(ê‹“äò|cØğã:…Ï6œì\#n©!øï“1kfˆÆ®­0ôÕ†N$¡«ı…ˆŸÙ¸ÆŒë2òô1ïvÚÙßößît$&=lËHgø÷÷¬À
K 7Å“ì0©P9TFPÔ@@³‰ıÉ"¿Ä>co˜wz%V½¥+ì]¨ÕòğTµ¤ò€rMBx†Øõ²œsu¸4nmC=vzâÁ,fe4hÁqÂzv0è´i-,nİ:Ì«øn1ûPÜ.bµÒ.n³òŞ°3¼#!„ÔÍĞf§Ô­Å†¶ôH¨AA+ïõúC¬ %ÄUÁ|&ö%?vÚÔw`†=.«!Ö±aWB‰³àÿ¹ÍMÀ‹YK*"2å~›B{/Zñy˜ªÎ÷¬!’Æ‡Ò(±Pµv!!:ñhÊ =}Q"™ƒ<©JÌª³šÃÁ cXñ°½÷\±Åí¸áblÆ}Æ˜@~ŸË¿{ãEJË¨_1†(].’Â¯ûª
¥è]ß|q2Rß`v 1è†‘¸°y]H‚‘›Keò(9¯„@AÆğTwöÁÓM€NşÅtfÁB²V²áä«œr	XÌN1JÌsöÉî ó±‚à7‰¸IwvQ\aœ(^sFëçÉ‡ïtÙ-şKÕÁã-Vùìš$/‹r@Q"$ÊyĞhŸÈÚ |¡ÑÀh'^Ö²ê>X#çŠMá_Wó^Ì;LÇÇZrT§Ò Æ>Šy¯Pjb!_Pªnq¤£3Üc`^…}N³ÛòuÅ•ìÕÎ:¥ Ò~<›£´Dt¬¶	’*xş-p›6>öa$6ÍUÓHBJ`JùÙÇN®Ò82ùF2*”!Qp–ôÉ:Xµõ¯²š¤rÒb6ì`?Ì/¯J&‚ç™]ƒ¿
ğ.›CïÂ€_æà3ÄãÉ)Á«Èa‡ø!Ã¿üÅº†ˆ.8–»6¦£Ñ“¤wÀ•!÷Bõ-¥Ài+^]û÷Ù'øXûl€0#…İú-–ûú/®­¬¬­‹±ğ¤3¯¡"Ö"6¾ú='S«Uµ­^•ú~Ë)Wï9şSÇâÁŸZÃ=Şù¤^…›ã‰§9pÜ°hJPø«¯Ü@Y6WkŸ*ş€7Ü÷Mk[z(‚X* Œ•ÑfÒRĞz0¦JL,Ã›}VŒè‹¤•¼J›šÓm-aÂHVhMjT›z` œkBf7-æt´…DxÉaŒ|g%¢ÿ³N‹uÍXµr*ç“h†Ù;KÄb“nÿZPê˜_Ì“QæON ^°uâù=«ïÆ„Ì“iÑ¯²2ZÄ³Îùh@ßn!Ñ‘j’ÏŠBIµ%×ƒx¡ÕÂØëÁpÌğ»ãgç ;f wÂiÑ—ñ’¡¸Wöoİ;®óÍXU0îöÖ]·i®t›ü$nõm”õè}´.Ä„J„LYK—PÑ
E_gÆ6º.‰Rƒt‚i“GÎ°D-CöŒ#L]K5ˆ³A7$‹Û<(¢b•PÃò¹ì\d§Ü" 7f‹¤ØÍ""L7˜V€ùj?H*AêÔng€®ÁCÅï~8¡¬N$+ÊœTøYıkd/Í-³wd›&™0èşøÌíØ‚ÿ«Â#×Ø³BÌ…„î°¬´v¯‘=–¤{]Dv†hR+èÈ( U€¯°a	k}5×:Æ(¥Wegú=Ò.­­É©@q‚Y‚ê§°öş$	Š,Nú°Ó0;a\2aÁQÊ1Rì«{¡‰_Ãoù|1%êtó¡§£«YHÒòœeòó½ò!yÎæ¨ºc-Ió‹p¨²í%ô?ĞÉøœˆz¦"MAtŠÀBM%ràëK«Äu˜­Š ßUáDT(jl,,J¥Î¦Éku¸1ÚátŠSêaÔT¯3œûÆí¢;å`;‰Aô}xÉËº1¼îà™wZ ß‰*÷MD8uK9eQ¿%û¢ø 1	kÑÑ+h2N»ğEaaBª&yâ%­Ûf¶×—Å+c?í3İ >Ç:ØV’A«¬Q(– ’ôe‚ 2¨)‚êİ3W¨@;?UDF¡€>£Õš(>a©¨3Éó–—Ó”ƒo ˆVÃg³áÌ¨eCæk*Ù’õ[s`HÇF.¡!6+ôeŠí~ñ¤]š„µú£ŞPyHT7…²^%+öB¤)c”¢((}dÈ2¨6qa±AqUäÃÆüQoÖKFZB#é-İ1§îzÇ(È>ø%÷Qšü'•ÔÅìºg³·-±ÛeHoFøº…L)<„üÒxF/,ŒM¶µJîİ‚Ø®N¼Cí X†úª'U«%" Éªëê„¹^4ùà+;äš‰ÖG+Ahß&íÊP¤f•…¨û˜¿â Bq5où‚ß®Ø˜ñÆÛÀ¤u(fÂãW”Ç¸óPL—ÿM*fŠïÜÄâ'Ìäûmbñ7”ú—‹× x~r±¥9N€œI•Øú1íÙ_&Çâ_PlR‘
'­øKß0»ñ{L4›é;ëÈó²ç¦1İ–r„(8g—ÇøÂ÷‘>«/ÚÀq	í¾ª"vÅ÷æ„2'óÈ-†|‹BÑ/
ÌÀ„År›MÎ«ê§n\ÏÚcÒŠZ!,ø#â\´)È¬ëÑ"Íá‡¼¶•À‰|Q#†êÚìOüÇ[©’¶%œ—fC€lCª¶œyŠª·rşŒ±”×¾ÑÂàN u•ã—Lµîpš+”p°Âv´¶b+@'2‘©%åàL\U´¿Çíy‘?Á.$Åûäæ¤ZŠ¤’¾²ZåäU¡0¸$}yÏ›Qq"4®ó—Èìñö3Ğ¾^j‚oÁyP—;Á½ƒ÷Å˜³	Á`vz¶ãyñ“Ãi“_Œ¤Û¦m•8T|Ö•	F­B‚Ş¸eé'Eğ{r
¢¡•¿ÇTKÀ é¨tCÜŞŠMÎ/3T=¢&9f~ğu`ß$î:A´™!Õp5=j:ÅX™çuU|–+æô@ ±‘hbt4‡´i<S»p“v6µûâL˜^mˆÈ™]ãhF±äŒ8f„]ßzä#lU{†.|¸†ê>ÜÃnñï£>Ö=“V…FÃpŞ³‹Œb}‚óyç"-%rğ÷€sx¿§‚Oóq,ÜiŠÓAunäšÅ<ÁÎËRnF}²F c=6Ëà/LãŸt"Ø‰B88ÈÖUWÃ¶N™İV Ìa*…ÁÄÔXĞÄ7	„xö“=k^	xx¶5ÖDı“ft†ÆÀ¯NÔhwÚ°È>‚DB‚™‡QkĞ Ôˆ¦–bùó<ŠOÄ5±âQÏ¢ÃÌS²9Kªt·ŞE? ‡‚
»šâòªÔ™ÅäÀ Sç­„uöjf@]æúSÀ¬ª»7ı¶QfVwı*Š/^gËéKœm°*ÅÍ{I§·ÃË+ûõVÄACÚÒï¿¶†¬Î2(¢i¢2aE¼ÓÂÀ¡‰­J"½‰hGÇM²fQ6é ˆîéjD:»Î‡¾¢òN·<Ş¾y»0Üu‡9ÌìôÄu=ë‰6ã.Hö€+‡¯‘¾ÂDäØš›£Ã·›<¹rØº86f¥À+Jœ·‚¨ê15T7Ã`•c»2>z"¥Z9Mÿïeæ·€82dsW"áØÒ%'ñ%¼Ğ¢›°à².ŸEíĞaô¸´Ï,úY6˜ Ğ»i$§Ûe€)'¸ ş<{ÌãŒ29?»1]ÍkS‚¼Y@—8'g·1«šÔJêlíÆio}¨Ò–mÓã§X³#l˜J	E3¥²I\-Ğ£Ş‡³u”şYé|ÛnŸ	ìŒ^ŸÇ©S'qÖß4•ì_EøÿÛÛ“0ÁÛh‹yşÿŞÛ˜fÕÛH#ü¶yŠ²‘È…—b{Hƒò¡ÇkŞ‚¬“‡}Y“;Ñà>Œ/E®• ­£ñìËTÓúG=Ès“*uúlÅ>Èg/åÃ/9ÒOíM§djxÚBZ%O‘¦o]v•U«d‡`t—SÓÂìqÔX²Ë¬²Ë8‰‘TfO>Å^|™Wå¬»İabŠ6L›&áæÛ7Ï_å5&‚ıNé¦‡B¿4EØÌ/Áy¦3QŞğ7Lé‰ŒÄKOÆF
Ë¡0Ë¿‹“C&†ëczËê4Né‹1¹Ãø™©?QPAÖà÷·uÂØSœ‘†8øçìÂ´±nsÌÈDëÜ@Y£@ı‰Í…À?æ1ÄÈaQ8\¬™ÒVÁ¥.M.jğv*íÔ³P„pvšx©|¹_s¦AÂŒjS—’š¹§™#{x] #õ›‹xe‘X"İº‡j¢üm@a4ì˜?œĞ\ÆöÈ™‹Ôo›Y†ò®‹Ë«áíCû,3dáêY¹ÕæRÆuO4{Ò|ìTİødzO…	àTª¶å>§$ŠŸa“¶Í/Î?tëqáYIy…*ÉœŠÁo^Ÿàw
„’C•^uÊX¿á…“w•N8^²ı&XÀ‹×¦h§<sG:ŞğªÙŸğı%û“aƒ“ŠFX ¡dòÂ¡FÙ½*ı[ş[å')[	L£Øg²3)Ÿ®o†ûIT‰Íä’€Îwi­Ed£~)‡Æëb–Ün·³ç"×‰ÿú+#(R¼l¾ĞGõ~X’Y~¦‚³™0]’.+ëQ«s¹Øo|Ğ3FÌÓ@ª	
­?‹A¾œH<îÎ¬xFˆ	â„Zİsg‘ƒğı¡Gft'ƒgîŒIñ;xĞÔKĞ“Šô †ÓãÍ«Qyf­?ÆCÅ3–>õÏD€Rˆ>	z×D¡pLn5u±õÿŒ»=ÇÖ3d ÷ò¬36ÿ¨ãÈaó›ûã¹½‰‚¤ÕØcÅêqÑY]¼îö[fØ^©‰7BßÇ¹@¸ß—²à´’ş¼È6íMŞ¹işp»Ó~…Ëû&eÂ¾ÖGWÛ~O1)bâJ8F¼ójˆİŞ…”¼c+É‡?»µ9ÊÀXT=vŸ_c’æpeÃReG.’g:Ÿx3ŞÎ8.aZoZmÃl¹ €c‚ç{OM,’9²8UËUË£;ÓnÔ‘HxEŒˆ±“a‚ô´w@cğlü8¼^Ê÷#÷¶®‡g¹ßU-¥G½‰_màFÓê¸ı‡q/éËáÜöàÏ:Å`,ŠÑ4
˜%÷Íˆ5	2”O·FîOó¶œä’6NzE ¢+ŒÚSŠ´ÛÁU]C:¹<·‹ëqxÜÇ‹ú` æÚ‰&àñ‹EO#zØNw;Õ$TÚ	ÈeÜËÂ„ƒù¢fö{5ó¼›F[—q"ãRè,;lò†<ÑÅq™äû!Îİt’TÓµ[¦òQŸÿyC{1f¦Ë¥¡F1Ñ¼,oO&ˆ=Mõ§œvP÷ÕµTµBÃkg‹FOÓÚÌ<dô%šÂŞ¨°3ôÆÆyì$SüQB1I«$>ğmµ»°²˜õ8ìÈ§«BdW‡B„?†ÜX2¼ƒ`TÛ¨ŠŠÆ	ôs
V.šM’ä:À*Û¶‡ª{¤ºÂ!+VÇÆ6I€£Éœeæ]1ÀI´K].9C¯©şšJ,QÂj[ã¹ 6W¸Úï÷šIsÅAàt9®f}=zpœéUŠÊ—sCh‰=$tAbHX3	¥’[ß,šz¼U¸8T¤ñĞu¨`Ş&NT†)1[iÈRÛ†päTŠd¡kôø‹ˆÁ/Yë¶…ƒA<ª{L}üq™ÓâF=œ–Â]wıóQaã&:Mh:oK:à¹åa<<Càç6Œ ôÙ©»Ï…¬§6äŒ»’Ï¹')Íß˜à gçºÕ€qš®”[¥ıÖK‰kŠxÇ}GaÀ¹â8¡o§¶Ù{Ñ6è‰ú\sÕbë!8ÔûîåŞÁ•Ü›ÇÔ8Xf=jÖh5³­œ„fŸ6WyYªû˜0È‰“¶bmú‘‹Î3fÏ´$ögŸCPiÜ¼ò·ƒğÆ¯À°ßtµ
ÜÉ —p>/ËdĞ£ÎÅãŸM¶®=mwirÀ§ø—'`H'qœ68'^%;4¡8‰elŸ!½¼Í¯¬L°İáeÆ.N¼"1U=>d·d…¤º¸Ş…À'˜¿õy›^.éALïòñEøm¥Æí@¬8OàG\)"ÒÉ:!/€Xú7ŒV±Y7µTGÊı­wicG‡JËØœâT‚éá^´¶‘™„ãÌ¡Hı‰ÉŞW/ŸoõiªŠS.ÎJ´$qr¼Iu)n7‚KO‹ñş‚ß’K÷ŞT0g/lÑëbÿ(·ÂtCÍ¶jX~xl­ ¯ÓS=F0VKVänw\NÃÅ£°i8ê†£ÁÀ)op2ÜFYy„­ÿŸEá)º&™—%	¢ıº^q_vÛ¤=úÕª^Œ„4lwÂêf¼Ãé4£RBTNÅêAÄÛ®p±–¤…âç?t*åõˆ'xãwÎÄUÚ§§v:§ÚõiÙóKj)·f”kpäP­{tÄÒ-$ÌÔuÆ?GLÂ¸¿â9ÌCz­"Eªı9>ß]´ó0>¨çâX¥ˆóÉ‚ø»öpÀ:L2ŠšÖ-‘puXuO]e5‰»ÊN§gz¢N
®77h”¸ÿæy:]\³¢šu¶
ûØNİVE2…NaÛ[ ÑéğišylŞ?q­bÂæCí:òeB‹tqìÍCM,‚1—ˆù5Èb*Hö$Ãå!¢Ç¼o‚›°©“(NË˜ÕL»£®7{õ­ÓY•­^-óa@K<R>ÓB·lACıMË#¥œ”Æk—ÛáPrÄv\k¢¡³aZ‰Y3:vY –ƒbc`¢eNÜó~’w‚—ïjRODêÌÖHÖ°
“Œ¤Öù„Q¥¿ê­"h?=oäÀL5‡’]×‘ÛóĞ^+ea—I‡ÛåCÛŠûQ®‹KŒ³±öúß–[®ÿ¢Ô•óîî´Üs)y|„(µÊb7ã»:ÒQ<S¦­Ì\Ôè«/²å^.ı¸³Yf2Y™™²Ï.¬¿¬‰DpôŒ‘évˆ“Át^ÄbôÒ:‘¸Ş·Ô;\Á ÓXêGVĞZãã'jPô„`ÄémöğÕCD#^q7Ëê¥J…nà¦5×j¤À&††IÒ¬}Er’ø›°·3´1Á1qÂÎ>Ç»4EOD²FÂ;q!×¤õû´N‹Ï²U«[º¦B±[”Q¹ª2•G¨ÑÈ¿¸Gv
gàşêÕPìv± ™!Ø-òÄöÀ:&1chÀM\;0–‡Of}Ü¾’KÎò3¬Ì%ÒQ¸$A&ŞØêx>·\ èü™@3òµ.w©Ñ|£°£ãÖ>ò¡šgXÒ‘%Ë'ÍzÆµ
©òv
½%Èü¨‹TEÄ˜¹$«ıhÇ"¹Õb-q:â}yéw.YOûÒFU<·aÛ—$¶¡€ºØ™D^Ë2¹®3™
Èˆ„X4Å³ Õ0nô:ˆn”i<+VMjÈ›¸XØW0­íf¦B6GTru‚·RÉÕÁ'%S¸Ân{.Ï GÙ‡K€A ­©µÀ_àPn…s©ò¶kfõñßjĞwì(m¤M”¬DRpcàîïY“#Üštz¬vúreÂ6
{4DªMZã	Ü{‡ÄŞÓåbr$Ujå3'p.>u“TP’¥iğû’°µY(ŞÓ ‡“í •7ÂÂjÿ?KñßSõW&5Qıß©`ÇTlEGp© À¯7é'nA“=î×›WokÏ‘1(S¦«q®$aA®Æ>ºöªêFÚ*ngòz›d¯ÌƒÅ™«ë;NÃÊêWyZ#^²Ñå’˜0U­[á!¾üK¤ê~	JÈ3àÈ¸.Œgh@d}pKv‰÷ğS9rW/.¼¤AÓÀ_„<*BPÅê£„ŸŒšÏEL’?¬à¦~·™Ä§Ú–›|éLö‘|á½Ú9Ï¦÷]ü>ò+ë´öãš©N¢IÏü±…§„ïš»—ÔÙçj:H+Ö[Qe<Ï>¢ÃÇiˆ~cªá$±¦tùà¸¹ô"jw*ÄI® Ai4ÆÆ×a1]Õ
¾‘“ÒdféJ.V€/îa
nxøMè¡ Cäcò'Ü,éãÙ‚qŠ‰{ùlâFFøOŠÉ%ºÇìl¤×‚ÀYxV|Ö84Å‰Ô…äDl¡X·¢­x¼¯àå>¯æÅ¬ë¾$/è7°y/î;£³ò¹eŠäCP1èSÔÌ%û`¶{,ü„ œ3n¤G:A0'T}n‚nÕ~*ª«[ßÖkk-³p¥áO5‘–ÕE+F§ä†ñ$WŠİ‹¬¬©Ì8¤¿0ĞbzòƒSD .![I<­SîaG¼M©”`?@éw}l/X×úü²C`îò»Ñmêö1Îú$³©©ÓmWPãv?g³®„–çUr³Ó”@oïx—­4^ÂkæG÷~%ÈëıûIµm-`HU¾,-xR†óss.Wç³ĞÒN¥OAŸg.¦<I’[?Å¤œŒ¹¾8ÿ“–q0”}Bf±óC9x
(¥/ôSBGÊÍ~Ô#ú)bcWnp¶zSuOÜR¼*†»†gËGˆJ2fàí˜4é¿²õJ¬Õ.Ñ?ÄÛd–³èA”E@"Kb>QlÕ¢’¹´Ut¦9<~˜w[ï÷Nª)ó#%ş”À0şåA~á‘¨ —#æ†ÕÒïÊ†İaÃ${óf_ê$NK<Ÿx.2FáÌTÍKwã>[ù	«û^YV$¾ts|šŸ¸ô‡¥sGCN¾øŞÔe  ılj	Y%¢­ÉCF¹ô®Ğ}ıÎ“ë="Ş½ IØ²äç$±:'?ZBHl*d|ƒŠüä?åV…f,d#Ë5ŸÀ:úÁ4ëTR„·,µßnKÚa¤ê§Û¦ÁÅ…xúÙ¶¤7•¸WÇ*§¨R»&¢A#Tûµ
ßî§ü
APó<I}¹g!ÔAİC_õ’1aD_GíüœÿŒCÜ+^ÏŞÃ„.0På3)út†p\¹à¨«}a™†‘/†Yğ#ƒ‘Û¯ÚÇN,mÈ—„göçşßËîâê{9¿ö3Ü¯BãÈ ü.Öö^±Ö:³˜;³©n‚ÙóÜ{oÅ)rN	S0ÂQô›µ¬dQ.<Şâq%+IT2eƒ¯h!÷Ì¥¶z¥ñ•í×ú8«æ®œrÇ„’ì½~£kòêB¿áõ‡.(çĞ5Lyoòxxmde÷_€iH]ŒßgäÛk+³2‹3'õŸ@ŠÙP¬ƒŒáe«†ûG=â	_“©ˆÕ_+ÚS»÷«åÊh‡ÒFn ™54QG!eå||àW>L !ÍÚdZş®>0ßA¿(>Tb~>³Uªh,Ï1ø+d¢÷rÏ_MÁ¦¿&ÂÂBzË’÷áS#š±Šï!õ¥º˜­èó{^rëç1æÃ½âšÓ±µ?.•ò‚ÿ4^ÀO¦7&õ|ñïîë–ñ»İNéSXÇÊ¢H†ì$)rı
RéÛEE»Uó“7æ±Æç‡äµ¬ÑD3k-hühø€Ş™¾ö
“Q…ğZb5ãµ=ãimôQO¨Š¢WJĞä]DËì…Lİ.Mğ±cq|h{!p^Sqgğ1*z¼	ÊfwÄ>İ+ë3ğ…
u&õ>ôe"6*Q^eUb™?‘—9Ö'‹Û”ş\&ıôşÏÚÛ’_¯Ù6‰óãÅƒN„ úïW8#ÂÍ“ƒñ€Nş±d£Î»3»?…¸Íh²k4RÜÆŒ™p\ÌÂ°Â3Ú(¸0ÜQQQÄ9¿It˜LÙé´˜FÛ±>=u§÷9™¾c=
“²:ó$hÂWA†Sì%Û´5RÛÎH\[Håà‰F‘JØ‹ã†%Å;—©‘ù¸¡v§ò°ÁI\«ì|ßªúˆû“*ØÇªÖ±îpE£Ï|ÅbQù® tbí"‘™b‹‚Ùoùª^>¢GAUìëvpºt‚0ûzôûøìŠ©ÚèÊY•ªê7|ø;¼$ÂÜ…¨I’'\iÏæÛÀe`4ë àÌûO2±Ê!Ğìä“cju4m½
£ä
ÈÃ¬ïjGôŸuá \!L»·<‚ÕÌ•6Ó†“o ŞbÓšiú‰E¦ƒ`mDë“Ù;Qü(?Ñ;0ï‚b os`i×õ‰5Á//ú£næß¦âmLyïÖÖÀÑ=_Š$Çú|¨L­æ›Fcaßy‚D'|3¥Ulˆkí´( æ6_ØdxÚÔ)-mŒÊTlÆg¤(~–yK ^ı/s ÂˆN‡
cÊ2º|blWSÉMÿáÛb8PÌ³½¢,9v. Ô^5 ÛÅ1Ì®'UõÇCş`€‹áğj}yùúúºi_â]æWN—qÑšüÒ¼^vÿÔi¯=ùşû'Oí¾µ„ç'é«Hx§()§…’· Õ«ÄH1Af#Œ±s:<xÇä	øò)˜ p¿ûÑåRvŒLEa6¨;AËµD‰¥ÒQĞ“ İHû˜,y¡QÙ–ÎGÃ>#çpÈq^^–óRW?®½¦y,èŸH—æş;é¼V9“Å3 é²ƒ„Tìus{\?Am™2~˜20Á`*8"+Ç·»z„p={8÷üÕËìpåø¡›üHã¦¨Æ¥_Û±µ*jÔË[­â
Yµ8=.&iO  €(7«8ı…s‰;Èr%AdqVè^îÙWÃ/¡(V%ˆx£X&Ñ©é?&ZâÒ†¨Ù3y¢kp“1½7š&jÕwzè;CX@ªŠ¯q9™­PëÇ'äsQeR‚Qõå/Ùèª-)È µk…dØ3Äİ¨—oªèÇ ŒNÁåU£Ö0'h1m¤*UZÖX-ÿ*Ğ$3Äô*µj­ü
¯…¨:YtÚ>P4†0,ì<\éîiŞú0l[I˜vd°ˆ	OS>LíÃtáî0w€rxE»ı>?ñ“Ì=!+w£Y€Ôä+†/ª@4¥±°f:Ïfãx?æL¿©{×Nâ$MV°-p¿R'H–!Â1s¥¿À¥2²ƒCN™ã˜a€Úˆ Ş+`¡’¸)$Úæ¥mÒF&rkHÖ"ñ­Vãã LQ‘ãğp'«ª2e+ÉM9³öôHªÕOaù\UUƒv·ÛìÔÒ[Å80Ó»–
!¿Ó÷$I·¸²LU‡ñ´Œ«ˆíaŠæ‹+¡&95wífæHc«‹´±J¨Ño¢h_Â½à9ª.)óU¦Â’àõ§wÙ7|ÊµÌí²oÆì×ŞaQV¿õa/Ú|ætˆ‹P¸Á?örcpîÌ êUf„9Is:Qd¢”LI¨†VåKÇŒ+¿ÆíC8­Ò-ÎóÖ-‰ìÂ¡yÍÓPKñ6¥"úsQ8Éaqë¦7Ì6'İ0l;@°7Ô~u0Û¶ØŒiûP:1?ˆ³Ÿ“øÚ
y ½	 7kö	Ñ ¡’¤M»Jœ˜UMVÕ»g ÜÁ=ËY€ö3 pŠ<aNÌ¬ÛRœŠïœŒx¼ Œ¨÷…ä}g‘»‘ã[ü¾Q&»´ñåÉ…ƒ!…Ë5±^)*4Œ¹‚é‡‘>­4¾2{uØy=|7€ ß¨¿gÎŸzÉÃÂÅ¶Én_¾4^ñğ0}«niÊø;tâøá´j´¿OFù2lz¦ ›ÙıÂX4gãU—>¹/†7nw×İQèy¸ÖÍöàh¢î ëbÿŠ¼9Õş½U=ôoXóXÍL¥}ôÈ	ø©©‡¢ú{ûBŒY« —.#“ÁáçY¦Œº‚ ™5r­v†7:NRõv—M ƒ˜¨Ø—”ïÙ£Ú_ŞÇÚX&²©¢ærø²™ñ­ìsb#Ôxˆ\8'ˆÀsã3ƒQ6JÍî¹BY>Éµ-	¿ù™Cû?Ã®¥¨ùÀU×Ã3€å î½İ;ÙØßÜÙ9ÙİÙÛ:yı~kãG—Ÿóˆ®¥Œ{÷å6Š\ğÒU+ŒHÉ@Ñ%eaì u`€ïó`3Ò7%à<Ñ3.TQ™µùÂwİ65òô!
–RÛŞ)&ÎšğƒêÍ(Şü:N`NÍDL
 :éšŸA6mHì{n‹5ºL0NI²5ô¦ØæÇ¯G°*÷şttÆ5:ë¨k¼0€¦ºı¼ı¦ß’o,•A"n-¸bÖ.îü„™È;x'ûøâ¶‹äQ”ª«…"û!?4ÃFğ`”"nŞoİ†øÆnŞÃIHØyöËQï6aÀ®¸A ”Z¡“È#Nz%öœ'ºÂ$¬İmŞríåÇßœ¥9Uçæû„1tæà‡p•¨³‚€Ÿè¸Ê^¿ıi2¨ğÓ•é¶·¶·MQ„êLThyõ’±‘ŒÁU“06ĞÛ+®1?$M}Õ¬ÉUXuµS†şoŞ5æVÈèš¸´Z¤E¸æDÅÇ3¨®‹ğ¨ ÕèUY"ŞâöQğ\ô†+)ÃGZˆú±æê„Iìğa^)‚LAF·q‰7ôC„¡å3¼Ó—/òë,Ğ5cs·"tšNNææ<Ò¨8¦x:?#ÉZrI±»tJ«FJ£¸‹´	èz1OÆ÷ˆœ&éô›LêÜZÙ÷ær¼t@¯Oe­ŠíF·k!7[òÛ[&ŠNt)…¼ô’¹ç¤ºº±¤pú2²é|ÿôW¬¶çE÷j¹Éµ3}øëã¶ß	ñÅ¾#å™Ğ­ègGÈ«SuçÚ*¬œÇ¼%|zXÖ"|9,aM,2Qkt:	©í¦ù|DSk=wU'‹ßÛì¾ñ¡T:şYÒ)ŒH]JšÏÃ…Ò„¢_Lµ,]@›ô†KíNéöK–<ÕÜ‡Âük!NØ‰¬À¯9«HÆî×mİˆ¦úÇÆO»[7Ü³iÌc‡É]Ñ`ß	¶1€[9Ê½Pä—ñ™xi/•Q‰‹şqorİôCìºÀ^ñ÷à·gu5¨J•¿=ø¿ÔìNxKj1³Ö)z™`bôiM[Á„Cdß’zìÑÈH²!·Ï$GÈò=ª R-e`‰F&hÌ”È‰hçx²"ç#&KÆ:	Õ›ljAï´M.Gã…‚ñ.yr$œ'f$4:+¾kmÀm‘Î³´\xû[¤éãRxY©–w0„­¶ámµVû»'ù—¬fáñüàû:^Ş€s†ş½%8@Om¹×‹l0j];Ì{İ'÷+|ıÂ;Ö‡õ¬¾X´xZmsÛ6¾Ïüy®’<;¹&õ›q]ûêãä"g:Ç„HHbL,ZV3éo¿g¤^l÷&=µµeX ûòì³‹N23¡×/_íÿíçñğ×£·ç4$ùµîS©*«+Ñ¢J¾LME?«;5«´tÁá_ıÁÕ³«ã³ëŞÜ¹ÒŒF³ÔÍëI›|T˜DÇjôÉ—*ÏFSİN3³°£ã³ÑD%3Ú»Ù›I¥Šx~˜+‹ıô¿FŠ]j
Ûç¥/Ş¿¥;]Y<XOMóYhç©Î¦fT”ùè®İ¯¹±Êb±ñş“M5•*¾U3İíÁÍÍÕ»"KM?êÜø%pJ´pã°í)û77A\ÎSKøW”æe¦s]8Å»&3¥+¶ÆJëFïHÑ¼ÎU1œV©.’lI‰r*€ÁR•¥¿{™*f56ÒØ©Êé„”¥«÷Ë-¡år-–JS¹¥Ê0öã4„WšÀé‚¦•ÉÉÆ•rñ<¤³Àè®eÅ.i
Ã`gEB¶.Y”%v$[ê8ÄIÏ
ëT–ÉŞ‚áÆ'vvv¼ãå&©3-¾ÆŠ?Ù ˆ¢(€â)õó©ÑŸ<÷SÏÏHßë¸vj’i¬4¥¥©qˆÂ‘3<[pü¬òËLÓL[ÌÅ‰·EÓ­.¯>œmo [ß¡jöckşzĞ¡«áü?îøGÌ?Ü5ñêAğŞØ”í¬2RÕ¬f»Ûƒ€ä-­?§L„ŠßybbÚƒSïÊ§çç:+EÊx#9ö2y”kË;3éûÔ…XrxÇ3šà ’eef•Ê½m9h¨¨ó	p€í»šóDvDÑ©-3µ$]U¦‚WÔ¾‚]5/ÿ]¥bÍ{“…àñ-ùgXEæ6¶=zÆ?é
JĞ‡Mâ0šrcuk«§uÖ¥\»¹AScùB³³'wÀ|I´Sif©WŞWÌñ³(È©™E4Y­éJß+vx»F‡ }€P®ÒzähÔÎë‘¹ÁVÓbjàòğ\úÈD¼0dÆ€"x!¢˜R¿Õi¥{İÆ»ı6¦ªÙ0µü.è_ÚQë Âbn^Á¸ú>Öâ	´ÒŸC8~†Âı’˜ç™QIojCh"a×/‹¸×ÍM®Gé½KÛÓ„Ë<ë a7}İíc}/Ëd:ÌÌ¬‰xö…bÆêéşjµv„æ÷1ÊSÏº
ú§+ÂöeË–®áÈï9×XŠüëˆqÊb<_ÒQ{æ>hWW…%€`_àop33ù„ gTôø›w×EEek+ª‹DOĞI´ÖVå5NZbdã„!ı XÕSUgmƒÂ¸Û`À™¾/í€¦uáÓŒ„ÆjØ¿9"PdHG}¡rÑM¯‘z€MfYÿi·QĞj¢	n-X­<”
ÑŸ0Çh¡ª‚µØ„²Y¼)~ñŸ–ßn’ñ0´ñ)Ë!:‡™ ØEŠ!2Nc5[€ˆS&‚‹“ÔCıqh·häËöl<×¹ÚÚ[ôãÉéÑÇóË›ññO'o"¯ u:Má°¥ÌáC!‚SNOÚIP)¡¼ş`UUjÉé4¡Mßh%bî¤Ì¹|•ö89Œ¨F’¨æ.ÏvÒdÿõóı/¿eÌ¢èçñ»‹Y}ühØ¤9Ë-Kı,ñbÿÅ_âøİ‡Í3Y8
GÁÖÒœşÚ^~·ÿÂË kœŠO±>€Ä™œBÌõÉšbËXS•Y-Hwé$ÍR·ô™‰•
_„÷ÎÕ]ŠD+XìªZ¯Jê2Kšn5ìƒ U”«²dGoch¯ÒDÓÊjØƒCÜÍán‚s<ß%\ï.OHèÓÊ=ww9L	aº»K‰»iB9B8¶0Bû‹5œLGDÛ`C‘LØáš%Zn¼%¼Ñ\ã£Cv¸mÌ	È`MV‡ÃW ‡‡0Q†8OëİÈËŒ*Œx2’©œ)Ö§:1M»€°§08ÃŒŒrs^¡Å’eÉÇE‚}¬‚èâãù¹ «ÄiZv‰bNYM°ÁÌ†æØMaàâ­ĞzİIZ($™v=¡liá Š Éó2Æü#¸Ù
öYã†5¨Ğv
·/ª„ÔnÃ†öOŒÒQ	Ï8G­ìˆ!Cheñt*4”‘%ì¯šD"pÁ(ÖåÍÿÕ¼¬R+NÛc&¾Î
$¹òQzÄrœ ñÓ[¯®¤ÎKêù\ö(EjÏiÒcª‡ò£$Òá†ZX<iàHjsA=L˜™5@u²&½qŞlÃüê'³ĞˆÓU$©eÎ½–ei4Öy–¸odoÓò¬@T§	’«'*X%bpˆ í­,™"h·=û;ş…ø6‘ #ú¼@=„‰ÿÔ¶/ĞU˜#Ng­1lÁˆäÁI°G"0AÎåÌÆğëd8kÆëx/Ñ¾:³œn·µ‘Ğ×k$FÛkÙ6õ*ğ©‚zYz‹:§¡Àè&Ø­š¶±ØÇvPJA{¨ÅSğiùj…ºŒ”t,aº†n.œÏyã[Jî=H¯şlpü¡òJAØC*Ÿ+=ìk’¦ç†X.0j‰Õ9ÃÇ&ËÀ¹PÀ-†{ #
¼Ìö£ØQ ³Ò¢/h#ä ²C‡ßSG†u8„tÂ„Á3Gı€fz?âØ”æ|hĞò)Á¶Ciúo$¡-Eb9OBŞ;9n*ç3–¨‡Cƒ›1Y2œ‚ŠZ+zÌeÈnŸ°ŞD?ä¼'ÊM‚_Ø…·7ğúyCpè\İ“ôÄÕQÀãY4Ü‹Dõ5Ú9À.ñĞxı=ıª%¦è:.`”«´ìA…	6]é)‚'Î^˜c.ñÜ[TqÛ{~Ji€R^¡ĞÙ–1ÀsÄaM†Ä½I%„]pu	':®+,éPu7~«èBg©mg@Ât|0>ğ<0_B%¢É’{á;‡ ¶ú.ûûõar`Ifá­NP÷
Ğl0À-4P$ÖO"8ğ,¤¨{¥“ë.’Çêÿšg8ğQÇX>k‹˜x×ÊûÜQƒÉ—nDÇÀ&_ âõ±ZsäµÈY"§‘}üpiÜ#S9`ÔBğ0¦éïCœvLÄmše/A_YQ‚¤¨ƒ¬j<ôØ!µ›]éGÌ“€gø}ƒÈ´‡x]ã>‘0. ÓÀ½Ssâğz¡ "°JoÕÂÃ%£4v(ãD1„#:Öÿa'ù*ÇgÂËò Ş¶\xx@€zÊy‹©M•cø˜ø³ôÊz8X¥Q[Äºb<ã*iÂ-Œhõ=,1ğÖíG2 ±Z¡?W0/¹ø~‚q#r†ÏJ›Zœ	=‰…@Ğ±bãÛöõN:]FÈzÂâ¦ d³[HF¶Ü÷Aó*õ£Vá©änS€gAĞñ\®†!rÏ	¼˜ì’a¹Ê¼gÏ¸bĞ³g°	ñ„~EC#0µ+Á×à¼.*rÏ]«t6GÉÌ´^M¹‹~ùªºå	}qºá÷‘ï·±•tà—LlìåÏ‰ã?Æiu+«;xÌù„·&oĞ}\¿á	Ì}åM–™µsäÌÁb8mT‰øğ€ç“=FüzÎÿ4ß÷ö?¾‡?ây&Fo“7Â™gü<ó}™cö¾İ{µ/cÑëNáY~4o\F¾”q¯ö¿óçh+­ŠÀ{/ğ~ÿHŞï¿:êØúÄ˜ìI…0Ãá±‚ÒOkæòÃÇrzt>>yZE—”S.eA ¦m=2AX¨âº!:`]ŞÓ#S„G2âìâTF<2Ix¡š,Cèñ‰oÍ5î±ÑRã|Ü0æpì®ç
İù‹¨ëİwW.ß%ôÒ„ä²Ç0>ş­~àG·å˜ÀÚóö$ y¼!çˆ[»&ïcßíFŒ¯«è­wÛëöš¥è
«ğ«ª…N¤dTc¨¹J¤0åõ‹'LK¨Ò¹Î×v}³ÇF[‘Ş¦#ŞÙ¥š¡CÛŒvÙÊàî ªä–´©–o˜^iØ^¥Ôí¶ÚÙø½#-­Æ)©‹ÜıhÔ‰Ãzé¾ ˆ<1Äwï G|0lïåƒ‘¼w¤y1_Œv1b@øv=‹ÕSpr)f=^êşŠÏp-n‡oOq¸(*/¼¡ëCáëNSÀn0şĞƒ¶ĞrLóôü©y«ièUrUâ™<¦0³ı,}Ù^hs¥–’	kš!uŠ2a×õe ‹s‚î	MBœO²æoO®]cX¶/¿‘»»kÏÜê~Øİİ `½jÛCü–êä+úê«±}NuhÊàZ ñ{ÔÈÇ(”#õôgú¹£¢änG:¢eËù¤UÂãÛ4rB|AN÷}"ßFi˜×HğÓ¸¡ÈE˜Pß—ì¡¾åœÏÑ93–W=äy	Ñgò¶„ßA¾:%¼F%Ïü²é00ı•ë7°ÊÔ 74Q] õ{ğ†ÀãyüeõéE^0âÇæÃg`=ANç€®:Ò¹¸_5°õNÚä×«wx%C¨iÔVÀ%[Å¦q	„Lê¸Ë,®GÒm_åµİ;CNü\D¯ŠK«¥¶áµæ&‚m¯z,xw}˜“²w	¥¾áË^ØƒU dn5¯»şÊ„Uñ‚=àÃÚâÔô'cDiAã™	†ƒUŠiQ¦>ù	‚£%‚S€T‹=aHº¯ÉÒ©£q=ñw<¨d<Èç¸–À­S®ÊÖoWdgBw—„E"/ä€ºûÛd$ ¾çÂí7;—Dıj	e¼Ê%®§rğÜô¶ú'•%qÅÀmy>ïæ[ËDãÔE1›“Û=Ü!„ØIf‰¿E?Vš´¾ sÎ¨É>‘Ô5İúˆ€/TèØb/ vs­2‡[ÇÅœ/+KµŠåhwZƒ«Â§öÒÕ¹Æ†\¡…k´p–åÿ°š•·3¾²gÔà`zS»üÆ³èÃÇßğã\'iJ][©Ly ¹gÅáÚä9‚G–¦ümÖ6x¥WërÓFîo=Å‰I±4d¥$-Ğ*(Ã%@3-…!ĞşnXI+{ÉJ«î®œ¸gèŸ>@§3¾OÒ³ºÙ¹ ÍÔ3qä½œëwÎwÃWw¿½ıÅ ×ú87 –Òh£hIJAoûz‚Ë×CÍVI(yÉ2Ê…“§\)!•‰(^1/Às3©âàDªãLÈİ¯ĞÄpYèÀğä˜$–®“P»µœ ³±ßôóîİ<~şd€V¿@àá‡ßÿö·áÃû¿ Tr¬˜Ö€&ÇL9÷Ö•‘¤*SjX
ñ¬Wß4›KüY.0$»ÎÔAj×CÁ‹-Ğ,QÌh2eŠg3HdscEÓ"TÏ
@¯íw7¶á‰°ÇDJ´¡ÊÀ¸¢*…œ©1K­†=Å…è<µH&èR»nå—‚Yùî[?h¨ª µ®ú(æğ­×êûOÉ¸b ¤1Æ›0ª4]Vëe/¸MÈödÁZç=,©ÖL‹¥™ÔŞÜ„Ÿ˜J˜ w¶6=â´‰ëLÔF–'6xhİ2gkA¥U€¸X1…˜"ú.ƒéÑ³½h}¾6[ìÀ«g/¢Àäeˆ£ø¨—íÂ`Ï Š ‰ïh7oÂlÂTpëKx¬£Á°d"apĞ×Üa©o·N¹ÙÅy™5ô e¡ÌæökMÇ,„õM˜×*ÏêC‹VlµBHÖj½p=™RR…áÒŠBš‹–4b^=xù*ZwmQ4.x;ğãóŸqiÅ?\Û{ı×\Ü"õ×kZjÄÏúÏ,ôÀq]{crw{s<¯	Ws¸·mw&WYÆÄX¶Å9ïl¾“I.S¸uÚU{ĞgÅö”h¸ØkB¢,ÊPè\³0Ãfâ\X£¹œ9I¥°t3}€õ›ÓSbxÎà6LŒ)u)Ë¥•‹ØõiY´äAÉ‹ñçîÉ’)j¤ò31óS6°¢„™üVÿR .9ÛEÃâ^ğÂ¬´šwºD€æ¶Ú!­JÁ1åjda'»q¾p
™2'Áæi Óa‰ÿZaÍ»ÃL½v{e„Û¾b4}Â;˜‰‹=2ÁéS5nÎÎ†¶c_Ùi‡ÃÊdß=_£9Æ¾)–ÂÑD†âóÔÏ¸0L¹"Ú~!oô›Cü¾aÚ¸Âóüœ–vSø}bîÏ7Šç®ç9 İewºÁ7¨íRŸ);}¹So-Š8:Ã3×*ó+ÆfâÍ±%Z
æ×Uä÷º`ép¸aO"ò;/mI»[¸°¨cbo	9v‡:¶çßo@U4aNQÀñ¨µdç|ö¯Ln—ùK,$Ü¶7Séšm:R+håÑ>Ô{,B8,+=Ù€²âÈ&;rŞÉX‡Áóì3 Ï°-ÍçĞp®+¬E0lHK¹‡ØÉGCX,êKWM¬¢*®
SÀC¶ò´aX7õ# 
‰ „·ë ÉÊÜŸ~ı‘ØÚ«’X°.Ï œà@ÂÜ.[ÕÈ@!lo6ÆX5hP¶à91Ø2ïå×[ŸàÁş`cªtïŒ¾0lX'í§¶©½l×¾Ùq„”ÔZûÑ"Y¹ÃË1<g+Kp­‰Á*î>ÿchDtÙ*qxP„M)NZ8¹`n‰Ei‘tz§·÷bbE±2Âca¬À“qÄÓFÚ”Ùi…tWªX/Àp#ß$aìVv=ÄÔrH[Æ~°r³™³H½«&ßˆ°é…:ƒf(éÓÏ ¡™:?}(h@tEÁ¾²jû¦âğ¢¬L]7q4o;uâZ1‹ù6—vlYÚÒ«4Ö–Ëö&şÎ)Çò¨Û¤ÿN¯^Ÿ±¾»ÒÎG	¤n±¿qŒ\!—û]Ù%Ø
ÁcvÑ3³ow‡ç=ÇÓ­Pœñ%­ê8œ'›JìÜ´è™9'Ò+È-¹’´ A	ø†bfQF…f;N-ÂÇ9â1M&®+68²Ok[¿l¢İ9öTW´”Eo›÷€õ¹Y¼õæµC>Š’,¾¬ ½ëHøÿtdİnÔÚlï,`s™S¯Ø©ÉùD¡ßKv¶4¦½“¼h(oØy«Ğü½ƒ#œ{SXDáV	¦8ÎÙôóq{>!Bğ•Øgš¦àw?šR’Ã Ã~â G³_PÎ½P	ji¹´ª_²Râ¤AÓ|øãOä#ì„§Ü|WÅp2Á7Ÿ™¬>¼ÿQƒß·¯h×|±tşpuÄx+)JMU041c01 ½¤Ì<†MÛ‚Ew[ê]ª«Ë“·hYvÑáÂ2C3½‚ÄäìÄôTİœüäl½¬âü<ÁÙü·ü×lpš³ÿbE÷´øX?7ˆa‰Eé‰EÅ©—lvÉX™‹xZ~{“Ÿ³]xƒJ6DIV±nebnÃö;ÛÚ»ï}¼XÉí¼:}›s¨u…¸ Ç:x}R]kÜ0ìóıŠÉQH•İ†£C!Ğ‡Ò·BCHd[g«‘%UZ])×ü÷®ü•KKû&­vF³³SWãz·{eå *|üŒ¯$)Å³n}ŠıødÌ}Pß“Št·ùæêXm \TÏ€ŞWx}<¢ÓÔ§º¹€³8Ÿ
‚ÚÙx[;º;ÇÓ !Ù(òG©N–’0’ø‹ñ)’ò35 ¢Šf’²éUóèİvcóßQQòÂºV=÷ ?X\…c.‹ƒ
‘U¸z;‰É$,¨‚õ4DÏ§•|*ÊØí)–|<¾²bodWÄ~mœ¤e1M^.¢I7bTnô<dö`Ô4ƒó}í^fµ­kbé´¢¾*ÖÇbhO0šÔÀöü:)_Ş!ª&(ŠyV½ÿ‰Æƒ&R-¤m1ª‡¶¼ó¸OëThƒ6&Ã¼Qvñğ.gše[1A¨ƒ´±d¼[‘“$æ$İŞ¯ÿşiB¤mxø%c‚cSÄ‹İ¿×í£lĞª,R,P
I­ü i2œïmÓ» .ŞKÎT"'’oYŞ³÷Ûääš8ê²û7E^/ÆEl7¿{Ò"x+)JMU013`040031QHÊÌK,ªÔË*fxd*|_00ÚUÎkÙÌL?ÓèUìú0Eùù9 %§Ë]'såÕ¿5}Íñz…Ôúì9§@•¤åä'–€Ô”\¯;ô,oò'•&İÀ$\$2n‚ªÉÌ«°¼Ä¹º¿’K±ºõÄ­İŞN-ÿ>CUä&€Ìø¬¾ïõUëÛï1düŠ–OaµœS‘Z”
R³cEŠËy&­yÛ•K³6î™ 3%¯4ì\Ã˜%Ìî;)Æ
‰Y²8«³‹GAÉ‡Ú´i«‘õÅ³óD­&ò›-Rù °£åTIAbfQ1ØG[U˜ÿÅ2H¶«íà+Î˜XÌ"ìUSœZR±¯¿üS‹÷]\ÉÙÌ+Î	®èìš;®ìç­‹5âòÛ¥ÎÔüD60ñ½¥©'LEIÈõ5ÙN­/ÕæH˜`ËËÿ+Áb™FTEIfnjqIb.8lúWm›şöÂÂ¥‡Ê#·½Ø-yî‹ È
®—x+)JMU0µ4`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|¡ª|³SÓ2sRV-«Ô=çøµq«×âÈÉÙù—j¨CÕ¹:ºøºêå¦0Xô»k[è.Z³á çùÊq»çÍK€8()±8C·,±4§„Á-&fïå2)}!µæØEo…å‹ßÏìƒ*ÊÌcàòzĞ<#O…ëë¹93jµ_şü]xÜh¹©©BR~~IqIQbnANbn’‘^qC­bm·WÛö¢©òaÅ§W…\×Û†G½^~N
ƒÍâjly2G·<X·xG¼DÎnsˆRò“‹JÊ~f=’IŞ!’´scN³ğ­× Òyù)©ñ¹ù)¥9©Å§Åßş.½tàÛ¾ÿqwÏŸ¾~ÑÿQ4D
“³ÓSusò“³õ²Šóó¾¿<_—¨~Hc©HŠğáæªÂ‹‘M¨Š!êvŸó=Êâ¿Ò¯‹ÿë£=Ç-`ê ®LÌÍaPl–ïu3¾ öqÃ‹õó&„=›e§õvA~q‰."¬òŠAáÄıñ~ş«/ò
.[wt¶Såaeˆ§Š“‹2JŠfÔX|p”^İ¦‹ó}8•]%qº Rğ1x+)JMU0±`040031Q(ÈIÌÓM2ÒKÎHMÎÎÉ,.ÑËMa¨”›»¯³4Íöd²¶XÈñÈûnô5 øê¨x¥VıoÛ6İÏù+®ÀIMËF»a.² HÍCfg·!K]—–Ï6WYT%*¨ó¿ï‘’?ê$[‡ˆd‰Ç»wïî4õ˜Z/¾ıî+¯È™r“©Èx¯öö®eF‘^,tB‡”ñÇBeì{B4Ê—^ğÊAw)í@^Z€C\ÿr6:=ëFçÇƒAçMè„oèÏ:·©¿GÔhPK¼ä5{#™LH%†gœåXôŞùGí«úÁğÈŞÃú÷C{Ÿx~ûV¬Ü2w†êpÁ‘G¥}Ñ²æE«|ÊS”Œ)’9×(g^ä”hCÓL/È.Ús—kãöä§M«dêğîdl¯–]ûß;6>$2YOËì-{Ç½ øÚñ5-’È(Pq®ãk¾”‹ø4ÖÒøid@Ÿ°]MÉ=Ñá!x,â8 ÚYBSçÖKÌ³‡ÄÃùÊÔr	œıù¿*ú@s‰‹ÑÇúfb¤äF™9½½ßl;ÏôXã;Êçºˆ'T¤ğ’áÍŒoSÚ§hÎ°:yRm²Q\Ù‹ˆ9™Á^šCˆ7òÊğh'¢{Q¢É
Dˆ7k¦"@´EdãÊŠøZÆ…M²š%÷lëüÈ8eÄ~cÔ˜ÕÈóaô™¾áìÒğ¡ar;ÁÓaié*¬®{tDõ&µ©¹æÜ;¨{B%¾íO}wàıpHá*ºòøÊ˜Èc…Ã›î§ÍnAz­±é.1¾Å‘ÖàB¯XŒ9çı‹î û{gÉu{İÁ%«–z?[rşŞC.NNÛB•»B¤–‡ûMœÏ)•YÎ¥>‰5C„‚@\å_œt;½A÷´{2ú£;ø©ÿÛ`ôº? ‘w[EÊ¸³N'òís²•N=ş‹#ƒš»˜Km^[ó®røè—À`ÅtÅFsò·öY½Ûš'òæÌşôÚ+myÂÆn#İÀŠ4}CÁîÀ"¹àx×\ª`–¹-ºŸÌ˜­è*WêĞŞÁ
æb€Jv`Æ€ö1<–ÓåÿŒ¡îTÿïAÔÅ—EÜSa”ÃL@?<“F]óŸœé]!U½Ç«‡"tlT)‡”ËPÑ4.09“™ï
 éFWıùÂÓd¦¦Š1LeBãB¡Oæ‘‚Àñ6¢©ÎÒ¸ŞªCmò6½äz3k¥•›¹Š™l/‡N?P½E$JĞ©º%Uš@«Z¤@ÛN¾Õ4¯ÃrÀm"¸‰U+ôØC'˜àh!®Ê¶û­ÊË‚ßÎqEßw•*ÒLm¿Ö´ˆeEkÙï¯JUâ°ııªôP~–¾¡&=CU„´\VŸ#O%Ëõ…1Ì›û¡a¿Q|ÏÈYûóTèlVk…a«=µ“±~Â¹ĞµÛäåpTfå‘Ûì(ølÛÅõÔio~® ‹MT„qØ¦Š±ÒfÕİ¬ÕİFgÊ"6¶ÕÁM—Ú»GcıOè˜xİS±NÃ0eÎW“S™´b@)ø‚"Á‚¢
¹©[B]»8vi…úïÜÙih$ñdŸŸß½{ç›)3ƒa~{sÁ|+¡u¶©'ÉVXxÚo$”`å»o¬Lç×ClĞİ¿8óˆôA“Ù›¬ßXãøñ±¯k×L­Q[ù,ÖêA4¶MçÂ‰|& ÍÂ	Ê²í• Úy«ÁY/‘€$5z.w(©—î5ƒ²d°’û6#r¯\†@Z&èAa”"<÷Ñòî­û4‚xd£ª ÆB² 2?fÂıv…À]§äx¾*aë ­WÊiH‹íÍãµP*¥Jp‰Å³ªÓ>	%LYïÄB¨6Z¡fdNDŠ“ìjÄ¨¬³ô”(ÚÒéCÆ*PWù4º[¦€âäÑYc0Ò÷·6¯İï:\E_şOÉ³šówËãËq‚¦¯ÍÜ+Éånc¬£lô­ibSæÄ²ØãŒqc—Ù(ÏGı®–eaÒVø`-NµÔµd41ÈKƒY7}ÿè²ïjñ½íÉçæÊT^x+)JMU04´d040031QÈ*Ö­LÌÍÑË*fğ9p÷Û¥Ä,ó‡ÓÎË/Záê t#çšªÜÌ<Ê½7Ş}uÚlôPâôËê]·¸ÙÈ «*ÛWxêbïJ^µg9Olg4¬eèU  p©4xKÊÉOR05e¨æRPPJI-sI-HÍKIÍKÎL-V²R 	%²Šu+ss€Jq&z†zJ@ñZ®Z. DiŞx}ÁJÄ0†=÷)æÖ-h{AV<ˆ'e=éEDØi:İ4™˜Lañİº.zp½%™ù¾ÿO;Jç—'M÷gÏ7«2CG=N£Bvy„^¬3ö´ìÖĞOÁ)K¨ƒî8C5(»Ä-uÀt ˜e#9îÙá˜¡§Á˜o¹ZÌFI€¬:Lİj=n%ÑaÏ&&vãd9à%+H?»h«	AwÑ* îã7(Jf•´«a1¨ÆeÓìĞµ¤M3ƒMUE9eËÒÄNË+»{é¦‘jÚFIšáÚ4o'Z”uã¬WYÙL)t‹÷€}Ù±.áÅnğk¹ŞG({²ïùXV§oxJ³ÚğuŞ°àÿ-L»£:ñx<+"§|Í¤ûÅGuU|‹m­¾x­XKsÇÎyEbi&waR²¤‚DZR2ª$K¡ä¤R $.vÀˆûòÌ,…ªäà›ov•qÊ9å‡éø'äëÙ] |$•CÒ‚³==ıøúë%ùˆîŞ¿óà·¶:#™uF¡:ZòE™S!1eâ8"šæÔúı·¿ÿ“æ¹ÑF…E!³	½IÂŒR4ÑY"µ!½ĞF¤A´ç}Ğ‰ø¾”J¤"3º’sNÿø]ïäøèÃ³WGo¼V–Ç¢E­¬HñÿDšVÛçŠ¢4&™QkûâÒ†şãá²õâÜ!’cÚ¢(OÓ0‹ÉŸA›Ztû°‹Y'+“ä!™©È JT9ñù?66Å«­.ïsIjÊrƒCµ	“DÄü¡Í
IC|’¾*3¸hÕÎ±º‡ŸcéÄy&ØïãL—JP’GaBßÂ=Jó¸L„¦qÄB‘˜#XÚIÏb©È/pl,>Ô2¬`/ ^e}Ôş"Lö•+”Ğˆ¥c]çmÈµTeÏ­¥İöÍQhùÓ¿ıœÅÕ®ÊâdaóG„Œ¬\oÌğ}Î„øÒ!­ÂìˆDÄ ñ¯?¬ÍÖ&J„ñ¢Q%â–ƒXÁËı€á•D•‘AÌÖ!‰óH“”, €“@cZ:ç¹:'ù¹^­„‘‘y¦;FFgş
‹|Â€şòäÕKÒy©"Aù˜p™:Qh`~ôú£ıÀÆ÷Ñ£ã×Ï"4P »ğåÍ^—´ˆ”0ÚŸ	%Ç‹iŒˆ-&Jˆ^Ñ³‹ïwéyÂ2Iì@ÊĞ¤UL©P³Ä.!ujQä23’ŒEZä‹”Ê‰
­,y·Kx•Ó9ãĞ&İ—™UòU—T$£0:£|¤…š…#™H³à}÷ºT¤ûHãBÆê£2i9's.Â3ÍB÷!„ÔÂÈ …ÇS”z–U6>èÂšpR¦°Şg ™Š¼4N¬d’Øğøô‚ı÷ÇI8!»Ìá)`®UäÓK	œŒQûk{•˜ŠPiÅZ”k†Ãí_vjŠÉ3ÖÛô'&g	™½ì¬Xg"2èåªN,sÖÖX>jzôÈÅ^××•ZY¾ÙÌ–>†ÆšPÜ–°<w¬İöÃúEÈÆ»U™5ZEØËbA’‡±7Öƒş¹LÄÛEyî&ÖÜ]rK3~à¶q çLw@î­šN?ÿí—`Ÿ>ÿõg{iÔ"İB²Aæ>´ìèU&÷PFÍ.òx1d„¿}ÄZÀH“B{œòÕ3ƒâ»X?ª²Iv½J-/»Gb,3ÉzYá2ä¢°×Ü²İ&Ö
«wèôÖ-Ú¾¨ÍX²Ó‡xvò(.©íÓcóê}dmÀñÇa4õ$6º|êÓê$+Bpˆ–ÄÔbÏ£«®Y+=^ÿlw6lß íl	•³µÊ•í®çÒA¶Î•4b.fŸN“³¥è»°–1£)(›væLO×ğæXr¾ñàûÕ&|ĞØÄ./üÿÀk+|¼ü÷ÚÏ{/>^>‚˜¼Ğ”²0@i0V9ü¼1«Qá9ô\>«_Á=Ğ˜Êã°¯¶òùÉ;ï}ô½>Í‡í!yÁN{»ÓTR“rmö‡U½ŒÂø¥ÌVlwpôL—ñÜBZ•J
q~¤\ $Îµc°¦¤Y#æâi ŒRÏ
×lHP”zê]Ùƒº|xv–V®Æ,ëµÚn ÿŒöå¹@8Ê¾ÆóÚZE¼ÃZxsıÒÖ…<P*WŞé«0Aù¤hD›ğ…ĞÑø0 ½Ş¶D1ƒD  ‡ñö°°¬-.håĞX&  çÍàÎ.…JÙĞá€â^‹¹‡äÒyPEæà€fög›¶ğ[Ö³Ò ÙÄL¯í•È>:¯Ø˜íù]€ËnMÃÂR\)¿êÀş†–ÆzñÚ	Şl¹DÚÍuš;ï½7ƒx§İi·áŒu#,Æº¬‰Â*À>ı½aíB£víÆ
@:WÜúCÌGÜ0àeÏÁÀ6jœèeÆw¢ŞFs[-ÖË,œèFYU€UL«Óê•0Œä5Ü7Œä*‡„îÌd+Ì—ĞË:¹|¹ÛğÄz	wìâÒ©pÁº1<xîº·T†>ÿú3Wì5Òã——ˆŠ[ó½€^HóM9¢'¶7u1=\Ìªé«™çnŞ:Õr°Àè[fLI]zU¿‡‚tbQÍ‰èW]zª3
í#ÎÏ³+X£Pãê€29G5RXÆŞÑ\e8éí`SjÌÄ]r™¿÷î¹Ü,B	Å.JAÌ1I¸ÌŠÒXaÆ/O/„ymÃ÷xû-C #TfòûSn9Â Ë7¢ÓÍ:àÒå£¨™?bDM•<S#‘Ó›8	¼Y=Á™|ÃS ½ÖãW&ÖÿçVTÿSRš¬†©ŠZ#$7:Ìã&§übMõ˜¯hSlsÂb/7ßñß¼ÓñBŠ¼›c€®é³:œS€|T0¦Ç¹ñ\^è/®Ä³fè†ç9P×÷6gs:ª3®5É¦†¢óØkïâî—ˆººx3¶{ü×VX•b¥=Ë¹sfâœÀ^;0yïíë·*ø«¢‘/w÷îµ1T¢	ƒTÜwî®‹’ŞT B;¾ëôƒ/v¾~¿}±ôÚŸúƒá`0ìL@ƒÁöíË›ÕœSÃ6œˆÉñ¼ğN¹úø7¤à‹íh_âyŠİi³•¹kKÍÁ·ÚxpLg¦
Ş°ãªUõ8=|sç¸Áty¸Ã
7'÷*Tøe³šcÄ+Û×(¾Õî4d&ÃùĞm×Dâüz§ôhË÷mû£=Ş¾hò„I?xÑ{÷ÍwO?<yöîõ	}úD®½Ÿ»KnÛHÂ’|ÿğ´R[›wm2¬æöuú†5OA“–ëÄU?—ó@ÕX39àŠO-ÏÁ="ö0• M‡“
E ã6õ]ç>†E|äÆÁ˜Â8¦ÀşÂ%
‹ä§ÔãíUóY£zùKÃ%TfviuUÚåq]Oû™¢*Y|¶©îğ­úùwùõ7´?]F<QŒñqe±ÕHışÛO?Ò·˜‡p93‰ìów“,Ñv9»`_äJNpyfrÅ©ÿP”ù<x%Á‚0D=÷+ÖS!!9i	ñ'üR*i,-¶[•şİUófwfzz8Î;“„Ñjä-cOáºÌ:ˆæ‘m4â€„xIş†ìŒ0ï9DLtåÍë÷PpT£\ÔäDˆcÕÔu#)–W°2€»õƒ´rŠ<ÙY£„[ömğP
U	+Uc¾ö•dçàò×Ã[ØØFs>t­>x}“É£VE³æ+”¥ÕÍã1K¨ŒÁÆãÃc3™Ù|}Ü¤WQjytï¢Ju’¦ªŠP” ş6tƒˆã¢˜¡(.áiÇÊba™LLc&A<…h,¦ÑF® “$ØB¦‚@³Ç‹N"„E'dY>N…$ş7.æc$
TÂp1èŒÂqˆç"‘JcZ ¢q¸7º—@Ã]ZE5øF!AàÀŠ›
QŞECñ}ìq×­›·åûk^÷1şš4ÕŸ€â–A!Ø@BâC?ë¸z1ìÆ|û§öıky›÷E¾üYÕpux†~Î—“ú“€ s¯%²$ÉŠ$å£Ù(G¹RN
ùqd/÷R’¤›’í>é35Ÿ¬’ï“;İcøÖ’Îû¾ U=”çw¶R´ü¨n;Ädå;|Ô­[s·_FZNù¢U¬â©:läÖì… ~?lÚ¤9eñf_ïÇíı|'ÛÛÈ™øNU‘S$Ô:µ`vb¶bNµ^âµ¬­Qï—æ}	 ‡®íô>Ğ§Y&Ej<S‡ùÔIKë³ªT\òHËıG¦Îm4e3ÿší2mjX»Ğ y"@£Ù–9-MNÁbÜ·K‡œ[­†şŒhÕbcRuÚgúRõµÆ¼”Bc«ó8ÚìüˆşÜ!’İÈZıÙ¼>t»}\ë:]OiæÇE6°%È—±[R†Ouiææß÷T%]qÈ¶®L—9İñ**›Íãîpâ³çïS`TİW¦iŞª©z¾vôëf,Ô³ùtnüjp¬r~9†y9 ¯<OİÕô67¯v†hÌı«+Vğ¼‹vXgZØø[”·ôs´ùva™0¨‚[Hã´÷Š Å&("§F»—sÓƒØT¼èÉAg¾ƒÅ-”\8vìeœè‰ÓÉªĞ³äo»¯WËo%KŸbÚãñZÈ¦å«‘5t°iÇŞ5aùÆ­?Dwoú†¥R;/R»¢‹ öı¸í ;4ÅNiabÔOZÃ2ÕWf´U7íeu¬0ì>F¸ÔóìÉÜ¶+>ïkOôĞ¬eû& ûê›}¬R²R†•NÊ0Tøã‘Ì$ñ·êaûßF6îrÚ±,A‡_#îğ;²®©À/Éä#:&ã¨¿™¢±¾u1„òƒŸüÀüz¼x+)JMU0µ4`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2Ìt¾xa:cûÜi¯9òÍ²lÕ|¡ª|³SÓ2sRV-«Ô=çøµq«×âÈÉÙù—j¨CÕ¹:ºøºêå¦0ä3.¾y\ÃfRÂÒ»Îå‚—~@””Xœ¡[–XšSÂà³÷r™”¾Zsì¢·ÂòÅïgöAeæ1py=h‘§ÂõõÜœµÚ/ş.<î´ÇÜÔT!)?¿¤¸¤(±@· '1O7ÉH¯8ƒ¡Ö@±¶Û«m{ÑTù°âÓ«B®ÎëmÃ£^/?'…Áfñ5¶<™£[„¬[¼#^"g·9Ä)ùÉÅ%e?³É$ïIÚ¹1§YøÇŒÖké¼ü”ÔøÜü”ÒœÔb†Sâo—^:ğmßÿ¸»çO_¿èÿ¨"‰ÉÙ‰é©º9ùÉÙzYÅùyß_¯KT?¤±T$EøpsUáÅÈÎ&TÅu»Ïy‰eñ_é×ÅÈõÑŠˆã0uPOW&ææ0(6Ë÷º_Pû¸á‡ÅúyÂÍ²Óƒz» ¿¸DVùÅ pâşx?ÿÕùG—­;:Û©ò€°²ÄSÅÉE™%Å³j,>¸NJ¯nÓÅù>œÊ®Ç’8İc`ï­xí][s[GrÎ³ÅPö H€É¶L/¥@$h³–"µµCqéCğÄ
¸8"I)¿¥òšÊKª’—T~™I¾¯{®À%í:›MUè]
8§§§§§§oÓ3<éOÌƒ•G_?ø›Ú¸ÈMQzİ²öÍ'Ÿ,İÏ‹~oP6N{EvÒÏÍ`Ø Dã$?òÆi~Öä÷—>ùäu62İáååp`’Ÿu3Êÿ8îòz­¹¤ µùoü‡Ö³öM7¿*{¾U»—®Åf{«õbçà¸³ñ]ûYKûIZİ‹ü2[YÙ¸_²™ôt\;ÒàÜ’¶nöNşwËæÕhXËÛ«¼é ”´ã‹¬Ø»<¯òQyk*¤¶£ïZûÇO÷%,/ëfùf«½µ¥øî õ´nùëoÌÒ}s°–œøíİöñV»½·"Şå–Àïl%à­ııíÖ·íãıöÁ‹ı]m$à›¾±Ÿ€w·6Ú1f~&øê²€w®²n´hÿİÆNëYë`{Ï"÷-V¤Å\½¹÷âéNûø·/öB7‚U ï%Ğ0òy%5úÓúy{£½{Âî/úW	tëà;­İ)>®~)ĞŸ'Ğíİo«éşJ k	t«sĞŞßîü&!E(Ñ9ºŸ@oì=sbô†à^L Ÿmï¾è8ı$Ğ:¡zco'— ı@)YK Û¿}ÑÚ™DNÜ÷zıí~»…q|×
S/Ğm¡ûqıÛíN*$ F ·úIM`:·[;Ç-?£„~¨rø·	ôN{ê Äï·Ÿî·6~ÓFBñTp&ĞûÛß~7.Ğ:Ê£úÛıÖïÚÇ­D´ı¥Ròc-”l¼Øßù!"”|¥”¼I ×Ş?ØŞÀ¹¨İœ÷W:óoh¥{¹@+İï-Š¢İÙh=ow0Ÿíİv¼yå4ùüZcùHæ¡öòå2T}ÄW"›ñÈCœÌ€øÚCĞ TõÒòƒO=ÄëâlÄ¦‡UC¬„^òjˆÕUã^5Ä—/«A}á‘ìVC´ÂÄWC¬.¯‚ñëS·3Œˆç€ÙØl?ßoo`ánÂDíí´[»ãÎ»­¿àá'ÆÔnk‹¦öİæ…|¶ÿ´;ü6ğ÷şŞ­-²‰|Ág|ò÷®şŞø³3i`ÿÙÚª}rTAK«Óşr9P²ôûÃÆÂÑ“ÃåÆ×ÇGõ'kköã<¿¼lê·ûóO>[²³ñ +ş|‹«^?ï”·ıüYvUWW`Ñ\fWóæH¥åü‚Eó*¿-Mopšß,š~>8//M™/ÂõA{|†O ìÆôÎL(ÌúúºŒûıyà(Ç£.+c1‚\fFã‹u/Ø[Ó1“©KŸ€Xvıâ3ÁšJÅ7J”ùµ¥Ê}_X7+:C:m£CÁRƒåx¡»=ä‘ö­Á÷&Ü¹n^G÷«ó2¨ÚÜ\Íav¸k \»Í.ûÍáè|quyyu­fØ±m¾
¬ìóü&³Ğ±r¼i'âô OŸˆÚYÖïŸdİWµ#!HxaéaÃÏ?7îV³‹uqËdP­~/+rL˜|›Ôº!OÊË˜wd¾›)!Är9ykçTÅã›OğÌËU>èOóïò›z÷"eİ2y¢£<€Ô\dƒSŠDv¨¯Ğ“oæ}ÌúÊ—óøòâ
ÎåFV×9¢¨y`ókê÷­-7Xíèj7XÏö…'«2“÷á¹Wâ¨Â2ÄòğıX¶ğ3MÏ‹IL"Lo„Ôòb4¼6ƒüÚ$>½FÖš«!sİ+/z“9Æ]f·6Js’›óQí¦„)$ÚD„0?èCÊ©åÕ‚Hš£ü
êµeh#Ëµ†íÆ.»y´Ò	“ÉuIO¾ßñÁ4¨â‚Ù+ÔzÆ$/ÕµÕ™‚Ó)At}(ÑM¡lÃ‹¦."áÏº±‡5}Q;2oßš4Ò!C¥-×;xeÖÍ³¬¼h^f7õ•Eãº:¬)”"Z.IëÁ°5e·ÛŠ$ê9y¡í°hYJó«ŞÕöàuÖïNĞ^Tµ;ë¯wò×y_(^‡|KˆØì»C œ¢=híhŞ<1³X¿ôÌ%£ÜÀB›° J¹D„‹•´*”XQèßpTşªØác_TÁqş}ï´¼°#ôümõhÙ÷3îçg¶—D ôEU/ƒá—•Ï¸^b™‰_T5ì9ÙE¾…‰HÆ/ªşq<,1?TâY$+Ñ´£Y¬İ«aÂªVÄZúT‘çìa7ÿ-úÉÉŒ¨‹èEiXÎ}Ä¢#7OÔşÃ³0Ãî½#Ï©rRé§'ZÃ.fID¦wyÙ+9ötEräÛ¶…ñƒÉoŞß¨maBW°¨è€bè©ÂÓı6»îOÇÄ}BzÅ®	UHÅœnÆïtâÒ’Ñu^¬¿Ñ­¡<Â¹ğ
¶iÚ—WHmğyaê/f8èßÎ›lÄ$O)~È ÌO›A£©^±ş…3}óV¿ÑÅh´ëÜi^ÍkUhı¢'}!Ñ©â¦Dã†U²Îf3éõŸÅsÃk%ÆùPdÛõœAS÷½8‡ÊÙ/Û•mÈ‘İìÕk/éÏºFÖÉ¡MUp{Ã»a°Àd©ï\«‰¶É8w@Á}§öúù]¨•/ğ )%üq½ w¡ïô•XCu®ˆÒr„>–ô0ÇåŠ1Ò‹¥'làWbìÖ%ÏL„±q­rÎóA>‚XîbâvĞ¦^ĞèÑÊBç+«­kÅ^ad«ä‚Mš*[æ¾mšú`ûÒ­¸ı¼ö_ÓtØ¾0…Ú“•¾Ä¥Ç–ÁÍô½I3YòNŒd	ÜÜíŠS=Rd±Şğ®¹ÌEHœT0Ô“O£Èµ<*GcáºúÕ1ï­5Öu}øàÁ‘)ğ27kkè¾!kË¼Å§2;‰lñ=äm½›ÌGWT·ä5ó§#z†Ü¤LÔÈ¾Ä;…!uô/Ë‹<ø´¦—.Úü`(ñâ†ãÒäE7»Â$5©ˆ¶FÃKñüÌJsuÍÜË·şğ¼Ã[˜WƒáõÀ”CâÁÉ¤3qÃqÿÍ
y/ø¡œÌáw@·xdà]™^1øù§+öN³r8º½ÇÖ›ù¨÷½‘’ÁIƒ½š†yYâ×§7¾ZËòƒk÷áëXûÏ9H4ÁKSg6eyu™N{—‹­«î;.Õ·‹®+dkeró+:×Ò–«”yWĞ‘~ÿzUL£‚o¼¡rIé¨1)^!u“W–éYCÏ8Q{xd…ò‹¢xgÜ=\E¢È½!T7Ì8éÙİmœÜ–yc8:ÍGËlôJyä@DšOÔ>³óõ–o²Ñ¨—ç]%l³=èöÇ§/¿ê\àÅğ2‡bËŠá`Ñä7Ö#LÛé0/5JDÙ½€Ê»È¥%ã×r8ãQNÒ’Ñ¤a„Ós>äq·Ø€´íf.Å^"X",~ÚİÜÉSPé¸Y5‘ï¯€ğ~zW8s:<ªŞ Qdg"Û2‡Ğkt»\Îæçú—ŒÉ¶»~ OØ]…¢7ø'ıa÷U9’?“b¨@¡D®0£–0B.2¯òOZ†´ÚF‰8ã`Òè³GÚòÓz¾j ª¶4õğÜMAÃüüÓ¿¯ıüÓ >}ÊO"§w0ú…ûF­Ñ‰Š»åİ\Êı¥Bã:º­¡UÕ'ĞÚ‚:`MÎsŠRG$	®Ô(ÍD›Lb0ÓİíŠei™±ZèŠĞºûf õŸã•E}9×K­[[—E¡‹=BZ"àu$¸òÒT÷fß­İùÖ!UÄ„L¸yL—ºìY¼&hİÿ›Şë˜YµÏ1tzÛb`Å Õ¦Ä¥Ü	Št`º¡@qek˜Ú§57W§œD÷®8—~–çÉÆĞvÍhcÚÔJ¡!B±©8øÇ‘¯#¤	~Ğ>8Ïé‚ˆ³C"o,¡ìkLì:A~¦ñ¬QÍšÕø›g=X8º¶’Frekåü¢­³ŞïÉSÉ<Òp‰àÂåDş2õNÜºÛbç¢€šÈ2ìŸyi);í@©JJõú"gügÕG…½obÎ€sw|WWHŒaÿAc<¡’zë—|jˆâ¢Zz™Ç–™7WÙ¨DvÁ¦¦qb=`ŸİĞÄš×5ç\.5ĞÜ@ú)Œ—šWšãh:…âªQ,ú‘úOGşÓÿé>9šº†~œ¬\Ù¹­xîvF+^É¨|-ãŠç¡P3CºXg(…¨Z!§…b²äÓç?÷ı§9ÿé­ÿ´î?=öŸjşÓ=|ª’¬ŞŠç~—¿êİ¥¯x5T¼M¶m+Şë6zÅ‹xÇ¼âu\dPñ:®×Yáì¯<wşÖúŸT-§óe‹$*Ğ'[îïãpç:~¸
ëg­ÁvĞ$R`sRòj¬w¿;ìÓÑïqï ßgÔˆ\o÷•ªÄˆª(ƒîì#H§i²º%5pÅRvÉô£ÍY@%×4_TCğ4Î}‹VÉÓü¢9›|=½’àbØGˆcN°ëQä£"RÓq;Å%é¦à©Â÷I%R¿¾|7EÎÌ-}æú1ÃÅÍGˆæ0}$»G›O·¶ø"õ‚˜3Í“i§Ø©”p©” fÚ'[F‰0¬]nh—ö™öÉğQö[­Ö½(Ë«bmi	á×¶ñNnÈG7Oò%Lh^,ı!{İQïªlÈN‚ºO‹ñh4<Çl5Õ]ûY.BégÎ»aGËOA6qt,òŠÔ-àºä˜Ë«xDÂ+7Ç›9Äã¡g9Ëa|1=$„¸_’•Ş\ÂU… Ie[œ" jİ–ıüVïŸ¹Œ*Lq?Ïè’w˜8İgúhé÷/÷v³=a)H“N‚C#äÒîü€º¤ç;­mÖàø)}l÷«ğxU“¥úxge;­<~?ŞÚÛÙdYÙºy?¶ûZxü’hĞ9	‹zŒ¦±SRtOERÇµ¢ÇBAä_ìJSOÓY>auZ×øWëæ	«fı1V9^öJÉ=G…!¥]òÄÅåÓ%4›eecÊ˜7Ğ	O´ä»™é–D€<Údx9Á+KƒMŠqO’@âµa¥3QG/a4ä‰…@Îò½gš‹}5 ³l&Á¤:Œs’yÉÅpXäá‡¾ •äÙAO?ßk÷Ğ×*‡Aù<ÉFr³éœjJVëò¤w>nx,šhƒg‘ct{4I‡¦’n¥ÌJd=9‘M.~§Ÿ¼¡ÏÜî£h’„=E’æÀı&£}ñ”ù5Âø×tİ¸5áµ;Ÿfà¿ù±TL>?ZñÆ’&wö0æ˜¼egİá{¬Áû&
<„ìvËş­íJ#Öç~wdœ†_w¹7ˆ5rÔJm]E#«ı†õ
wrÑ;õ~:ÇÜ0&Ê©_…ÕØŞ‚9M¦ë”.¼¸i4—"Æ¬îNÈÂŒÆXÊÌ éx)”Ú·"aÖ­Ş“‰7½IûòÄ-FL…&Ÿ ;«ØÚí-,8:]«¤TÇßóà¸a³£$,ZEIt¯<uùªòRµ¯ŠŸ£vÓ¦ÿ¦3!Åš² èywH"¡&Åú˜%0Éfg{ÌsƒR¨5ÙO#iÆ)‡]<âa
ÌäÚ›¤—ƒiÁ,0}¯kBsÿª±T +*éú°@ã¤«‰¥Å<yûV„”èøƒîİkí»²C˜Š!‹o(”ô/Y‘
	n[jKımˆNJ—|NQ¬†?ÿ<ie¢CÎ{Ú>Ñ‘(”šÑ*×Ù4(T„“Ÿ †V`şŠEZxëØ…]˜ƒË°k—=Øw¼Ì¼³&gn‚ä&‹Ú•Ú©>¥™=«?zjT/¾oRDmpmBtZıâx~awÂEŠ¹Åö46äXQw€HñÖ•h¸,‰îT„\½ğKË—X\”ÆÃ`ÜÖàPáùdbÉD8ùÛÜ„ÈNOMöİ)¥B vµ@
{;³6PÊ¸È<aE`#
67Áp·Ö€¸#®'Cø¶è@2=\nJbÂ^KÒ.á…–7Ï›2ûÊtS£V¨™×…>=á©b/OuÁ‘@¯[ç"£D«77åm8§Ö‘<¡ÃÅ¹jÖ¿\IVÕ<±nœub×'8­p´O‘ñ£”¯İéîÓ;/D˜5„XŸöÎé§ê¤¨ÚqN”Ê×ğÑ€±F'm–“\ú!Xu¶D.—=ÒD Å%•Â,+KÏUŒúØ÷e}u¶Íx€0Ä5¹¹ÎèÛEÌññ<MĞ5!ZH+¥Ö›u\µq…c«Ô/0Mº¹¡\SÅB×
hÉ­p‡ÙÔüRÔ¾V™'ñßÔ—ÇîÓ¦ùS‡s="Ö’›(Gò9¦ëZìZR#7ÏÔffƒ¸äÖ‹Ë-q¡®{s:¾ÄZåê5ea¸‘m±5u_:ë_g(-“ÁšR~şé?™H…f{G„0dggğ6±‘¦.¹5cQ»\‡Wæ^ã|&–»… …ÈÚ)&% å—Cî}ƒ!|)°!Eóí`PS.$‚q‚Ú«<¿ÒxíŞ‚íƒñ¯F²º}~íÒ‹ª‘F3Qdr=‚èi`‚å(
Ò–ÉJYüª{qÁ½’l–Pğ&ë~û´îä‘ŠEÑ¸¥gËîµWŠçÃ$¯v•k¨G¨ÕîÅJF”¬â‰ËëBW˜]L/¥,,&Rrçmà¡U¡¿U½'~èçOTåx®šğ»Œ¦~¯v/~Œ¯Ş³¦²¡>”©6ÃD(ì×ûI¹©–øHÀ„øbÙ:^6#P*Z6Úzdš>9Ï±8N!c(Ø@¥FY×R>yšw!èp6p„‡ò¹¾D[bˆ¸%ƒíÖŒÀ #@;…'2PùjrÑJ¸h.#ìæhĞ7µZeV‡ÊKî)³cómÍÏÿü_h.<‚ĞÚ‚¤5¸,î„–9ëİ`	¶„ßßÆÇ³ñ¹ÑXëp#&çqPûŸä4:ü„-ƒÎ‘0=Ğæ`Dïr|i)E‰Ğf€jáš-}ÔØKØÎ-*´søh¨°Ñöİ¥…ª”˜€b|Š™D µ'S¥TR`ÌDO°N+2)öC
{}İ²~˜1“TœŠ€«aé…èºYşŞºm¬¢ZÂâ„vÑTL9*9—\u&‚…¢#—ëŞˆ½à{yF£î¤Š,QXv"XÎ0ñB	—2Hî©uƒŒ:½B=÷}%õ¯ ƒ‡[ K‡q±ÏØé•_p—zå­W'o,!ÖÈz\*V÷+jãÀ‹×.ğ.$Ñî‡fb-0‘?âRKÈtsi`÷hÒœ0Ô{vht¨£!.àš})D¦TUi#}@µ¡àš÷œ‚•°~¸¾T[BôHíÏò€Tà³ÍÂÚ[*Yñ¾ƒyÎGvzÜXuYÅYŸñ:ÔBïª£!‡eG¬£G`›zíN½®ibÿâÄĞ»š Ë¯BlvÜA£úÛÓ4ŠUÒ²½™ˆÁR˜+7öw@5ó	V³K;#Å<!½d+Ä	j©ÓÜ½«3›¦Ş%<æ8…ŒUIá¢Ê×Œö2·âÅû[äf
Ô‚X6ïôãI\/X%iµôÁàn{Gïwl$À	W‘™D‡ª-‡’‚ÕÀ%n=DãĞŠÚJI®$;¡-ñ?sÏyÂ÷¢•j‘$vûp<Q«ä~	Z‘YÎ'CBÅ	@¹/ç‘-éS¢¥ €ö³‚>Õ‡+å4…‘2°DºG²„ú½@'XŸ˜Ú]¸º Ç7~©58ÓèÜjHåR`.ª„M¨T)¨wrå—0s9²Í¨Â‰ÁCºŒ•TMÛçû¹ShyçOä±¶\v9D·)YtbÖ07>àóLØ	Š\È½PŞœ .¿õ
foªèé ÉÂ$¾Ï±RÅ{.‹l¿x;U¡,ÄiP@·a £PlÑ|öê3ñ_òî¸Da®‹•8Ë+d›!Ÿ½ZXùÌ¿øù§Å„•d!Æ’lÑ{(Ä—9£o”¥Y@qLpø/Ô×äQEt’Ÿ÷Èà-B0*5ïüÀDœ¡„4äg.tÀú‚Tª ,Ï`K»ãÁ+mc¾:ÎC`ÀZáÌ²9¶d‰JÔ­(~Ş—ı?œ¾X˜¯bğèşüìšv¦[¹“ƒÜW“¼@¢á¢€óÆjşÊÈ‰ïyH ×Cø-^.	wŞÁb?°xîÊ×Ö	¦]êª¤uM†ÑX_ùzĞæúÚ.ÎıFaW~8‚ª°°'*.l¤ŠYx½}Æ„]_fÎàqb{_ÂXWñÔÜæ8Örl>8}9pìFúëõ3Ì	e†Øsã…™NÍÍãŸ¯È˜Ùs­İ1 f@¢Œ‘ñ9íîîšQp—^—nHíçÍü&ïZ~ÌûM6™ˆ4 (WÔãòVí©Ö˜¼¬s*"ší¬ZÁÀ¦‹âAüYÀVÊ?˜¡K°ÒU¥ğÉ©­·cc¨Yêhçà,Èú–9f‹xB±ç2Íø¸™õH]+ÉÎ8;‚"³û.÷£;¿½.j-„íÈr„VD†"!Dã>²®Ï²w‰3CX¾’ô¼îaİ¢®¤ïNEO$~Ftd&ú8èM¦A üƒ@æ>2ƒ0÷Y¢JApBã\ë™ä|yLçÓ$ÂƒŒGS"¿ÆìÌŸ;iìHFªJ	jnŠY{”ª`-w ëJÉT•Ô×¸E# ª¤+¡œ¨i#×„o*Ö¢O°Šazl¢háéæecÕ¡ó«8U z^–D¡(è/h	SSru v{‡Ã¸ùÃ¦€£bA&ÿTâlƒå€¯T.üDùJtdğ‘x¤g%Šä(„b„¯°Ğjôµ Ç[AyòÖäo¬Î7µ{.æØ !ŠÍ"Ù=ßT‘^Ñ¯Ô-]ê“B$í/âÃUØß¡â”M.Ç…@ pvRÅØISCñÆ2EæAUdr‰¼^‰ÿ‹ï,\Aa3¹99i@dîíc«ÄE|‰ÓA½$(+Gx°W¾cOcQÂrå¼:–ôAÎR³çÇ8k?„Ç2ëV×É(
HÖ-÷é2Äz…İ·â	}NÒºtÍt$zòd	ôSjeZ3š:“1©Xxm†–Oo…Æ"*eª`8,2Ã	È6–O° ‹è£ŸŸÁ®@9á‘¥’#Ùa5Ó5²5Ş•§ƒ#¥³:("Ğ£N8Fé€b#7ˆ*å(©¡L\s"9L¡PH‘8†8P‚2·İŠÕ*6Xéu-PÄÕë³rƒ]8İ‚å•f@R¡x#³(›dÂ3HŸ–ÁäJÔ’}øÙøD^$bµr…j7òDö ¤Hpcsğ¨õCñ úämD•<œÁácĞ&;àPX>†¨wCÌgéÓƒ¾ª¢t—>¨,Û>ÿ£èwšª:5ÙŸ[pa»¹«ÜÂ÷Œõ1ugÛÃ‘YãdÏhÌm>HE…÷nbáSVö¬3£B#t…r‘øªƒ‡¬Ø6ÉdÇ¸5#Óë;¬¦@µËám³D[°‹TùKz¶1…Ü ¦ó8šOÍ±sÌóİøq™>|u¯ÄÎ¹/ªÜ79	f\m«˜4kpT^¯¯ÓïîwÄÙ}ïŒœ CNNÅ
E¢ÕŠ×Q‘r×.}¯´(®Å8q_^šxF‹`9}Ï]!İA ®‘ÈuË·º0àc‘OQ"™FwÚåoõŠ
‰ÌË.2­ğesÉn*I·(Xã½öŸyxóÒmåü-0Û!º©ÑWäı…§5è$¨qE¤q¢‘mÛ’+Á	zÌóÆ}ÇTÔ™¤«Ï)'YÖèïe€CÿÄŸVkÉ	ÚKpgL_záÕz… %¯0&»vÈ.=*S;B(–ÊøS–†İ)äğªxûJŠq§
rH©½œÜş¿´«JüŸ—vjA»Ğ°o‹â÷ÛJ?ı¢Â¯ê˜ÕßäZ˜³BÃÚ‰‹[jñ¹,İ¬»/p+Cì6[r½EâË£§äü-™@\ÖzLï¦&$ uèûI/h˜ Ó¤ ÉğôD#	½*¶_²	xV;Är¥'¢÷tÖqÜØpU%*Êç¦5®ÆaÀ„œe·8ZªéõìŞè¨"¦¨~“ßîô8§·Ùnœn¸ÃÜy,VüçáÜ£«¬7z:FMŠ.¡åÄšm-E.S¥1åÌ{D}‡„:mU=¥NAAcİÎmt–¾Êö†Àûa£Cÿ™ŒôÆ™|xáá=xì„éìL[ğC
•ÚqÖ972©%ç(çf™àAb†Ãbc´7À-”ë†j.È#$"dÓ9¶şØÈuh‚Ç4‡.¾xlV–WNqVÕNM:aqÒë·xÊ˜ß’º¤· Q“«ïfÀ‰Õ–POß{¸£bº)2dù«kdÕĞ¬¡ZN€ëO‘ã¹r‚ -!K]@Çy>”awyo&¼w3½»4ÔN‡SH•ªÊ•<‡LÏP_˜…7îxÉ–, Óc‹U¤â^ñSÇX§öh´C¯‹‰º† îp-Œšı7"ŠècSoÁv½Èc¿D©išlÍË1µáú@–„ÂOÖyNğ×œãˆ…á{ÙÀá<\ªB@ãŞÏê*Å9ÙñÄÛĞEÇgEÀ‹ëÒ½ÒÁÌí`Oô%"‰4…­T•D‰#S7„EªQ‹Bù+Ç!YÔçøEQëtŒìú÷óë­…5†ÿW­Šz~XÎÑNhäÊ}¼uItg¼rÁ>«ò©éè¶J„
'3è?qfŸ`-DQ¦ª&ùmÛKI£oWa·"ÿ!¦À-±xµ;\¢£›JUíÉl_w2vw9¸³6”öê!¥ø?Äñ·=ŞáÄ’b­¬JIBB`ëGJË´­ZøÏš—”p7¨½FV=›èº‘HX0õ>S$*£¤ê/h÷ãĞål~]°Î@$‰\HğDàB+×•[ué87”w9i}›N^”€:€µ¢-Óš¤ø6g9Ì(¥ßÂˆ•íĞÁÓSN¹hSH	†T€Úª:y*8fZ	‡üCÎ/›€×Òëgo'ôÂ8æÄ2d÷Î¤¦àø«¸Ó‡·AòÌºÀa}N^FDÖ]ÚK5¨îsëg(.¨¥º}ášÁòO áæÑt7†
²,Nİu²ôÅº ¬AUnÒ¡œ§!EòÍŸÌÙÅÉûŞ¥¸Ô†u}ëê _&òÄ|t¸N@Ø¢–ä©†q³X{êŒÆâ©)×cG.%!ßàÿÊĞ¿\û+_lİ[Go¨öóKú?d]‘u&›Å6<4[öfô#ï­qèÁ½·C÷Í-ç¸G…ªVö±AäÎ¾¨Û£qíã¡ÏîÔ^Ôı¾¾$93İ¾¹_3ğpüdèöXîJG*•w.b‹¬Ë?6ƒ*´Eò)ïé ]… ŒÚÍªQòë.aåÄÅÚ%î?Èµğ49úÎ'}\ŒŞ¨ŒŒ}±ë‰4ø?@İü¨+ğG	È$´æ–ãÏò pïGÍÿ(eûñmŒ¸ ¨cP²èğl%èæÕJ.{®˜Ùn"ç[‘İVX0ìƒ/¨U{X£ÈBéÄÆk®Ç¬Ï,ŸŸ¨M1Ú³µ»íİ¸ÙpŞ°á9­ ç:tbU2DˆeÇL/ ¬Œ‚H¤}vŞ)5¥Då“[ù‚ÖóEÚÈ#-k•mDxŒs¤réiB 2ao$÷n[m¯:Ø­Ò=ÙÉ9’
w&Ü[iwä3ìşàmìÜ¸èÒ?õÌNºuò`ÒÄ8>¹«…ıÁmn5€o†ş³¢ ¬'êeFÈÂqš:òÓ¶dVurD½Jk`kåqÒÇÃ…OÑõ¾{O ›êøÒ+’=„W¿ëx!¥¥µû¨Á:¦2I¡ejã´0Gœğšİú6üb·{>Œ·‚î†¦%J&jÑrcT8•kVWÑk"TXæséÎ»´§ p*Q”ÓSê‡êÄM`¢×‘!³<oMDbpµÏ«¹épœ
ı¡šåÏ”µjgçÁ®_–Fnå½‡R¡8²ª3×}à’WOªh¶fO[è“ÛıE({^™ókXbÑ¦H<Û•›ƒ(ÂTàbÕ”OÍÉ{±¾£Ÿ÷ÿ5qªäFL÷_¡<ÁÊ! ‹=Á .Á6È›¨Écœ4yT<¼‡¾ƒw`/øtËRå"şÂm¾ÇT¥®RÅ²d³Ğ‹õ{¨%ğ“G<	GÃL?§kÅd½’ÁYb)8@¢jr:^âÂ8gÒN§ØU¡*ôow$†ŞXi…Ã·+õø<ìË²^ó(·È­¸¢_şÒ!\[Üéã¯€Dá8Ë°x~Ã#'Ê±õáü%)ÜÔˆ£„øëŒ8‹Î7rìá§7–ø…»j—p7VãkÜ­7ÄËhx‘ßL4Œ±xíqú÷[ƒ® £‡@ˆZşBÜL‡ç_òù—ú<kœMÀû¢‹.şêõ8ÊÊ}G¹ ü¢eş}Šğ+}5şa¡^Ş‹ÓÕ§zñ­cE<"6Ù©\¢Ç«ÃhÉ5ÀG=J‰Ã-‘rß^Ö%_¤ƒ@„¿1`Ÿæ¢>Ğoü~KşSÕm”á®¿p³b¸;qÁ·ıÌâı•HÄ±oÔôŸÂeÿèŸİ÷ŸÂuÿlŞJ/ÌôDøØ
ÁÎ;qåÙåQ›«ùı@6n!eÀcL—¸p‚É¤:+F™­@~ÉÔÌÛ“¿¬h´Øñš>…¢}±¿­7 “ç~ûšjôéBhè«}>-ŞyW)U_šãÂÚ¯VWì™#¢J
M"ô±zõ¤q¨ò§µ$asïËÂ…#+ìŸíÂ‹É?Ñ5ÔÔ#o£¦LtD˜ÆÓÊCFÓ!_ìbã`şé•zÈJˆ6A”h)ã‰ÛAH¹éş˜É>/CaÙ]å$åE¥ÊàMÕµşA”©P¨÷Ñ5ÿ\Š{ËØÂGM¶v#Aî‹×ÀKP¬X]êqµwYJ°mf¦§à?"'èØé#²«qqaÇ_„ĞÅQbs†üod­“é4| p*ÉH$Y×A>fûG_œÄ0vé½<†,[ËÀÂMº¾XÄöä¯ô³÷EdÒ0}\T©\)
¨1iX	|3=%‹+ä_]Pñv1Ó³Ş”©Pxçaå~±:[ïèŒ¦N%†°¤FfKgDÁ}pK ™¢¥°!OÄV%ŞVpŞ#åÚZ%‹Ÿ§T…Òc S´§U©PÚqÉZQDï–EóKŒ.¡Ë-’¬Î­,¬x±Ğ5„Ø`wã¿íf¿PRõ1“ò·WU]ÉÚ¶‹±ÃÊU÷§ÏT:(6Y l~–:´>mËÅ¨•<“Ò|"H
r³ò³Üªp°é[M)¿AØšÅö–IÀÑ%¿HéTNÁX¼?¡¶ª^;¯vDİ‘}Éã8@ŒËp× Î¬ğJšB¢p‹m¾ùä¿^Ü¯x%A‚0E]sŠïª˜Dv–/áJ©¤±´X¦*!ÜİQ—ÿı™¼ß¹Ğát®v"Í3E«I4YöT×e2hÍ#ÙhrQ–Gb$Ü¡OÎ”æ=…H3_yóú=ä‚Ô 5º2Ä¡¨«ª–£šD5îÖ÷‚Ádı 
F:xÖ&M·ä5Ùà‘÷ŠÔ+»)EoÄ¾eKr—–X·[¶ñ´Ò? xUÍnÜ6îµ|ŠénØ€%ÁëC %-°uÖi€nã¸v"²\Š’Ø¥H…Å6’ 99¥—&× ïĞGè£ø	úJ–´MKoÒŠüfæû™]k»†ıÛ·¿˜~•4Ş%keiÃšû’M¡¶£µµèÑñ:²µ}	W¯?€4%7Bz8v6Wx¤U<GéàXsßıõ'xÁóÜêL™‚ Î</dÚßË˜—‘l,Ôª–9WšÑ½¹÷Ò¡²Æ3Ş>>Í•–Oå…òèwváxü¢&_ïOàÉxù^€¥…ÉÕÇw°TŞSàä³F9™A¸Ÿ¾„‚°^±W¬‡Ö W¦Ç.œ¬!zFè³IWâü#‚#4È,±a,Â5 ×R DyTpöiÁ®Ç¿ÿøğ–Rlº.k9Ê8'€Ÿ¹V½8²â&J &ş£õ,¾ä•îgÚ¢Œú>é‰PW•q•İt8.–Í:9·n“k{î¡¢Ğ^ããKÂ§ş~B"h?…S§Š‚ôw\È¥G¨¸i¸Ö—°Ct¢kBCbîµ,ñmEce»¬çáı;˜>xø#œ,=8YÜKÉM2L[X@÷~ß¬áêíï0­'Úg×XeC_«É5(Ài)¹Õ7NÂÚb	ÃÈ PVvg{p|°œN ™í7u¤ÌµèÁ
Ñ8riÒµÛjÓÎ>Kae°äxÇy‡Nr²ö;QGøvøîŞ½µxxt‹¥ìKc3ê—ÒXHâ_=]ü¼‚L+ƒÛ·Ãû¿®SÊ*»‘t&Dœ2êT>!
#r:ÕÊ5/(äŒ*z¨Ş¼c=	ßFØD™L^„Ş¢(púÍäş ™SZYÃ!Ì8Ş¢Ş‰T’HøO
G–&é¤·jŸÕ­S-£8),.ê çÉb~o¹Õùg5å*¨Ó}¢lË3ü8è3İ^vW¯ßw©é‰hÊçä³CÚ(¸„ygpÚ\Œm-IlœñÀá—ùòÚ†”>[ÀÎª§!¤vµ$›¥Cá£’Ö0í‘%w›Ì›ÑÂ{€ÁŞ”ª )O™êSÒ%$Ä&¨umv›ç×kÚ7‚Ö·Ï­#hKÑB)ÑSxÔ„s‡Œ­V«öß€6m„±öi’t»!¶J*‰¼pÄf2LÃjSW4aiÍ>£{EÉg˜‚u)Åï%àn¼X‘x+)JMU01d01 …’ÌälİäŒÔäìœÌâIÕ‚|‘OføNÏåÑŞçVº
 y±´x+)JMU062e040031QHÎÏÍÍÏÓË*fP}_ÛçeÀ0ç¨G¿ÕÆ¬OŞRüÒÁPE)¥¹©E EŸÃ—­{Ù¼~šı+¿I¶Ïï*)t|„*J­HN-(É„VŸtkİ=·›<nñ_‹«ÖhXzğü$¨ºœüÄˆa–íÃØBo\K¾[Út.bæ¬6¨¢âäŒÔÜD©[ä„ï­8ºÍÙëóÔ­‡K³–2› DƒGèö&Ïš4D‹e2ç?[}Òvı˜)y™©% c	Ûpç½~Ù)ï‘[PzróRŞùPU%•© %qáíõ¯.Íèšğ¬@óã1½Œ¦» 6T0<wR)ı%,bóıë‰4O÷5/f¹× óŠ…Ïx+)JMU0µ4`01 ½ôÌ’ŒÒ$†–2§7U§eBçM~3ygçÑ?*J/˜™˜€•d¦çå¥2<{Sç$åï³la¤ÂÂ’5×öæ-‚ªòMÌNMËÌIeXµ¬R÷œkà×Æ­^‹#'gç_ªY Uäêèâëª—›ÂÏ,xºXøæq›I	;Jï:—^úqPRbq†nYbiN	ƒ[LÌŞËeRúBjÍ±‹Ş
Ë¿ŸÙU”™ÇÀåõ yF
××ssfÔj¿üù»ğ¸ĞsSS…¤üü’â’¢Äİ‚œÄ<İ$#½â†ZÅÚn¯¶íESåÃŠO¯
¹:¯·z½üœ›ÅÔØòdny"°nñx‰œİæ¤ä'3””ıÌz$“¼C$içÆœfá3Z¯A¤óòSRãsóSJsR‹NŠ¿ı]zéÀ·}ÿãî?}ı¢ÿ£:hˆ$&g'¦§êæä'gëeçç1|y¾.QıÆR‘áÃÍU…#;›PCÔí>ç%z”=Ä¥_ÿ!×G{*"[ÀÔA=]™˜›Ã Ø,ßëf|Aíã†ëçM{6ËNêí‚üâ]DXåƒÂ‰ûãıüW_ä,\¶îèl§ÊÂÊ2O'e”3Ì>¨±øà:)½ºMçûp*»Kât ¸–ñÌxM1O1…™ó+,1$šÀÁp´êPU,ÚáXÓKÚJâkœèàß“ 1ùY¶¿÷|px€¦m/¤„.© UÔğ¾y}á[Œ¨ŒW‚•ùÒ¸”rš&ñ¥¼O’FÓË;ÑÌBÉ»K«›ööá±¹/7õl·{ZÂs·¨XĞh& <Kd¶‡¤N¡ËÉb¨2EÛWMsŠoş'ƒAUhKÉ†Ÿ=8FôÅq¿û¥ƒ¥¿ ‚1Æ3•Çf,_•Ş£ÎÎóY¬‹é9Ûh®¸„_¯Ø7w/`Ixm»NÄ@E©ó·KEm‘QPĞ ~À™qˆÙ‰';ãaóùL"´Z$*KWÇÇWBğøt¸Qš¹Ç‡¸#'vÇ Ùğj<7³K²˜DíñFéÚ‡g…»°RYP†Ê8‹M âÅ`‰$tM*šû(Yô³G«Ñóı¡­ÉLRÅ­¨çµûÊm#ºÛáÍ¹-J´/+¹jæÕŠÊ©0r²¥jGa_u¢¼ŸŠ$ö}íU¸FÙôß‰wdòÍ; ‹W¶QÂ¯ÍóH%Xmï£ËwK ½ºËSºÙ·Í9õwx+)JMU01d040031QHÎÔ-.I,)-Ö«ÌÍax´gÑ{f«ÍBfÓ6Ù~x´ZVÈ ””xÍ}ëvÛÆ²æü›µÎ+Ì“Ğ„	R¤n¶AÁ<cg;qì$¶÷ŞÙãQ„„´­ˆ:ÿf``å<Ê<É|_õ	²”}Î¬5Y±ˆK_«ªëÖÕ…Ãy~ØÚz´½5ü/÷Û­_—ıóølŞÚŒÃÖiY.–áÆÆIZ®³ül#Ë’Y¼aÊıë<%Ù2i}ÿâmëşÆ¿´WÙ¬Ló¬›¥áå‡¿&³Ò‹¢ò|‘äÇ­äÓ"/Êe§ã­²£ä8Í’#¯m^åG«y2)»º”z¦¹ªU«ÓQ¿ƒøìh¢.»û®çMÑwXv»IÔÔÍ	¦Ïß¦ËIu&ëõ2™ûƒ_—„@tqé_vK
ºfİ3Za²Ë²H1«±yÑÂı‹")WEÖÊVóy%—â¢•EéòUf²“°ÒåkGh*VÕ®CªÓaKm6”ù“¢ˆÏêµäÅ ]Ê/Ú›$˜9~ö§á~2½Šd‘Ä¥S“x‘±iäayÑÍ¢á8Û+ÇY/ùi/JÆz.é%Æü*9‰ËôCò¤Èvì„‡ÆØé¼Z&ÅàÕ³o¼}ñ×gï_¼zşâÕ‹·?ãíhsH>•Ivä4à$(‚|œwK_cëæ‘‚Öà·ä|‰Wş`d'å)†šª¡&ûE”ïgÓiTîS3èäò²ÂLªQ!ÃóĞn2(’x™gëµ×]e¿eùÇ¬¥ømbp¿Mº‰ü²øì<÷Ò¬åİë9Ï{÷¼Ö=?À;¯ëõL9(»7ò{^X=›åóÕY&O}/h—nf™¥‹E‚{öàd™gzĞ¯ü íy-¯—ùaziˆ§U¨¹=+Š¼Ìâù\èÕHµ2æÈûùÉ÷/Ÿ}š%®IO½Q“°@YJ},—ñI¥ŠğÛ#?0/@ÛÉ›2ıö¶ˆgÉä†çª¢4<Ë3¬“Õ¬Ì,Fvµdõ¨›%[RİWO€ï²,Š¼ÌÉ&Úgh™tUOö­8EÁ’l'QQ{Sæo°J³“È€«Zk- àPÕÓMüË1é$ŠŠ~bÂ8È‚4(Ô²É±h‚˜æÑ÷qy:8çXBÅÆ¦ßúIûåã9ğYFiŞ%{­Á`Ğò	ƒ^ú©”È¢´7ïwÑ K8. ¼0,Éb»ƒÂ]ÌüîÆA¹qxÿçş/ÏïÅÁ"_†è±—ërY‘È\‘ˆaMl@í‚–‚²Ÿèò~Oq«™+.N.È+È(×kr%?h'ƒÃÕñqRø¦m<— §O/e•®×]ç.zğÈ¼LXDÅğËA
)‘òÍ%PS9®§åW	¸b9pî£­›k<9.“¢ª ·Ñ¦/L¨V£ƒbr­ŠõÁPÍ£ıá4˜EûÓ`£iT’OÉ+[OxìÏ‹Õò´›Êğ?ùA^»ï¥hÁ€6H@OÊå·é
ÎroˆQ-#ƒ±>ÆtíÙÈr\‹à˜ôv¤èí,…p ô4dZÁÌt90¤ß5äœF.úØ½£Ş–Æ*W{(å ¶Óiw—ıÕŞĞ¯z=a-hù>Ş Lê§šc¿‹7Ó¾zí§>†Õ¨N£ÜïÍ!Ÿ¥»ş
<Ñtp¾ÙZca.À Š8¢×;œ]ƒŒ`êÀXzìİÚåíÇn+},=pÂR1Ê_0´ ;Mr ]oõ8²HiaO?M ÄsBw(\¹×aØ»s:vøHöÅFàyş%h}ßû«Ñ¼³Õ¼Lñ[$Ë|ş!Á•å²¸NÁpãl–¼>ÆÍ¢HÒ¸´Çİ«Ù½~É‰{hh1Z}SÏy»äï“y/“%”µú^B~Åß%¿¯´Ë³x± ÷¦²MÜ	üèâ2¨ë	p‰gñì´[)nŠ™õGĞE–jÑ¾oóıò´È?¶(òî½wZÈEXRÌ—îé²u–”-~Ñ3e)· ÊRà{ŠØåÖàéké«ÚXÁZÆ'FŞÈXgüQ¼Ôe6Şh°¯×VpM«=„&HAjñâöÚ©P)£ÔY£ÂªT7î,.QÂ^» ;‚eúº± ±îâ½[Ğ%”soİbBˆx/¿ëu{¤æâRCJ<—PÜ¡ı¹Óq	$ñ$ó/(’o Ër_©Ğ ¦Qša€=U„¬FîBe«ŠÊ~bûjã+¡5SNÓÜr‘ÌÒã49jœ›‰­ÒR]-w¿Ò„÷Ë¦DáW‚MºaâĞyü‹l@Ò…~Ï_X$2¹ç¸ù@!‰%äŠÂ6JBz‡ñ‚%‘U
ÉÑU5L™xzyT©€¸4°±œA6ÓXH°&/Âj\ø™Â‰?Næ°ÑPàªiäg˜1Öú“bÔqÚ Íö•²ƒôl½+-}HÁ«ï`fªw5şá½™&g±z+.NVgà†­åi¾šµ“VÜz6´öå·5ZÀlÜZJ=—»t/Z¦ÿ°µ½EM§úAëÒ÷0;N»p™}è'’0
¹ °ÏAÑe€ô	«€¾2kK§ótY’1Z†¸luÕÁÄç‰št.°ßÊøÃü³<ë0-õJ°`w0Ïã£ï„ÊŒt 1l×‡ñö4)€tÓ'Â–É¹ËS¼Óm™qÈZ/Ì+Å{1\Îc¹šJK¶›å@åjA÷ErdÇ(4ãHäí]ñ=ÅnËlÙšÅY+Ïæç$L ^Z
@ç²¨şÂ$B:½b/8kÚ7lZ°†w$æ¢½]¯÷§¾Y %l^K º ¡ãZÁŒášZ¤óäÈ`2:î¦ĞUt?[ä™^ªˆi²V„Ôø}ì(J¶ˆ%](Ú
¡w]…×ZYáå1LñC˜ºò˜XMZ¿	qmêàÒÖÙŸ^q_@2)Ö:éjn»Ÿ†èçÓˆyá‡™)‹_Ä—-d$—ô¹$Ñ0(#Ã´–F0$ğ
%ô
Ù7p*YÂK-N³KXCW‘ààÅ ˆPFöitœDÔ¼]#étäÅI°9n†Ğû½à‚2&4‹?°šãC2ª‘xİÈàş‚7áÒÎ>Óxò{Õ¸U7ïÚ<äç77¬Úæ5†½;şâ’­Jë§İCáşIpœO/Õ2{rsïTzl÷F«Ö:ep`í,Ka®møöPÖpI&«<mÚ¶§Ş#İû7¸a#HËmuß…AÎÔ3ï•{ıîåKyË¢®5¬]VÛ¬Ïñ+°ñd*ı3¼ ƒÌ3óª†iƒ¼æùÇ¤˜Á¼hx/c¾ÀÊo,òŠÃÇÈ¡¶ÎohEf§æÙ¢tÜ²v ÁÀUkCÏÉÓ8üp3óüŸÆáèZœÁ'—œ½u¯z÷Lál½Ş1GYÚÒÏk7O^¾ÑåqlmïÖ?OŞ¾ÒZ_*IœM9H­Ğ[¯ u(?(´I:¾¹XØWä`‡×J&j„Ølù5’F­ø[B*ôÉ¤^œ@FqÕúgéÂ˜|­š¼ıpşõd/ÚÙ©éßšK<}‡§7ÓVJı
g½#{Ğ¤Eo¨ep á3kÃQU15œDn½>\}İüôS(Ò^÷0ÙåQ¯‡‡7$:•}^ôÈhlC6éò}UÁ¿ ´*z½q] üú,ôŞíH´V´Ë¾ĞéH.ªa°ÃKÍ\r¼—ºå%›ù¤Çr·.Ú]bu2˜ÆÅSìŒ=)»…™Â×·ó`½ŞİÙ‹2¹{0\¯=0w£á¦§ån@ š+C¹µ™÷{Õ
PÉùßß6èï.}µ»í~İÃMœBÌQv	(KH§?ö2kD£> *Æ‹õ¿§Üƒ}cÉ,ƒßµFfxCâBÍ®\¸fˆ­L{ÔG¾Ïòš3©–¢:‡*fû£©)’Ş_ÄÅ2y‘•ĞÈ”{~ÓàÂµ4t{éÑ®*.¾½øCß¬Ûy0‚Ñ}N|Zæ©vçîÆ;Ák¾ÄJ„‹ºÔöÿh§»œõ0ÍâÂ€ã{'Şğ[YÖ!½‰-İşµg!—A>+]¡~­¹¼ÖÜCiîê3§9ìU§g74XJ xš|Š?W\MçS­ ­¼£&ñÊFW†sK‘jtW%îİ\¯Rx¡A¼¿x¸„»TÁhÿaàá
÷fÔû£!=­3<r'³?Ú<<ğDoı$’á§äy×û¥;	÷û½é„¿Ãş£)ÿ¼ŸŞ÷qp00wò:y6•¢R®çOÖ¶@µ¯½–Â(ƒ—iv¼~Á¯û¬†GYœ­_Å¯Ö¯¼òı/`ò“¼ˆ6~qúH6äé››…öŞâ»‰3G›g8cú4(“%]A†A%°‰”æÛÇj¿…Ys6‹›¡Œª<ëš;<^RUäA†3éÂQàõúån%ùèKûpG{
XäXXØ„’1›è=ö^¿yQÛcoÚ|=lgª	€;ÌëzN¸aOñÿÿè‚´#È¼şQc Fá©ü—)¹(˜Nü
ˆñ—Ó|èÔÃ%:TUÓËK«Ñ{ö%¨ËS/­.ï¼Œ_y—ÆWxdöä£ nÈşæQ`]\ESÅFÑr¹iıÁçÆ·î@šğ¦!Ş†6P‚Š åî ¦à…ZS©?Iíbğ¸™3H</|Æ*
^G‡Ú{Ú½0®›pÿIğ!x¼éü½Ş^a`–m	ïRü~·z\¿«	^ıÙ&&µ6&äûoËéz¿upPN{¾ÓÛÄ»úª‘ùÉĞîû¾pUiá~÷ë._½%”¯5æOPÉğÊç7sÅ2=_‹Ï*7Äçü ×8£¸À$ßÜ÷{¤ÍŒ'¯Ì“Ûx#Ã%‚<ˆƒy0ÃÖâ[|l‚K›¿J£·íSµ+Æ]¦t«Òõ¾Æ^#¢ud¯¬•0ğEy‹³¨WBCƒúˆßÍi»W[SÄÙìo[Íş&6ÑåŸÁ»·O»*²Ct±œ5¶§îÀïÎñøİE,Ùşƒ©2;°Ÿ‡k-Á‡öÎ£lokì/¼ƒ•±ŒzK£¬•û¦˜Ü*ÚM¶ïww‡÷Ñâh8íµz]\Œ¦ëõP)°TSMÙş
Ïf‚Ş†±j°.QfÕéÌË¤||wgƒ}å£`†È-»S²Gm«¸®qX´¸Œ_¼y­7º|8¡Dö>»™ÊÎ’âû¦¤f{{”Cz#Wôt}yO¾zúõ³çßüåÅ·ß½üşÕë~üéÍÛwıÛßşG|8ƒåä4ıõ·ùY–/~/–åêÃÇOçG›[Û;»>êmDˆ˜*<îË›‡«Ô¨;·¢RësMß!hËè	0}¿sI…ĞˆK‹´İEçVÂ+S	Öaæûşãİm_× ´BÁ†æs/Ú5d“~ùê÷-ú‡eÓAûÅAM•M„¦Z‘á AÑCP3vÍhØ•ö+÷Šq‰‘–_Â-½ƒ&Ò\yãÇG»Í?¨<¬=ÀËNú‹£xoow]M.`Â˜&¶ÖzÄè@X]Å—Û÷wÁòª6ïØK8, ú¸5‡µá`Ä›òÀG›,ÛéT½l«¢\øïàúx¨Â$ç``w2›ª:w3\ãÈ]eÚÀÎÈ£\&–„bMB
1¹FÌ–E(#Ş/€–‡]04{»Y»İ­îv·:t­Q·ØÛ{ˆè.lÄ^AGşåa›ús-‡e§ú°êãÜvîööœQî‚‡¢È‚ÜLßÎ{ŒÖ©‹Òj®¬†m0‹÷×ı~§ñòõÇì‡"‡V__/aÔaïnf¹ë·7»4@–65ÏaƒĞ®s)HÍ ²9"iõ’ƒscn¼êå^$cSå‚ªn4zÄ…Xk]¹7§ô\}­<š©ã0÷·5S:¿ŞëP”óŠ§ˆ«EÚÎ3ÜŠs%¶Ì	õ,Š(Œ»!'üÊ.×š÷]ÔÆÈï·`àç›1°ˆÓbYqh»3óO£@A?—ÕÂ5è'æ±†“˜8iBÇï×ÑˆÒ[Õ-ÌÌ%^3}YèæŒˆØ/`î©üL§šåßg´®Õ!#ŒÀÇ-;Qj–&³?7Ñ\“¼:j„ö]¤a9áOfš•ó½¾et_İŒfh,ÉvìÏâØ¬,.ƒŒËà'…˜«ğ¸*}•(mk4ü	ŠV›qßE¿6˜%ÏƒgˆÚÓ{ÉáşËà]ğsğÕ úá6 ‹6ö>‡}üyˆ_áßSü{†£çŸ<ÇÅÃmüÛÅÅ£ç«çÏŸ?“¿Ïau¬¾~ÈÊ«¯¿zş|Ú´ùä©z‚‚SMå—z±õ/ş•bÁ_dwV›ÃÍ‡ò÷Ñt#øƒƒıƒéÁÅÁ%î¿[-¶×mü¿÷ÿ8èO{mÿ‹4ø«yµÿKUƒöÑ—´râşñôbór­®Qí¿6&á¿v¢ƒŞÁÁûƒAûßîß;èøìoêßG£UXÓ?`|\(´µnßñ1ò¶õ­Sm$§Öëä)4N[æG§Ì#¾Z¯·(Öœ"ÜT­İĞêß*ÛÜqC³(ñø+#@İM{Ám6§Ã$auYÛfÅ9{?&IûaÈ]èp[›ë„^îEØL˜”ıGz£aØU3„•SAo›Jvº†ZP×ÿ—æñ¡F»z ºhÉg2QÔËxcJÀÍP …7Ç|#sÅMÁ72á‰÷ß¼Pt‚pópK¹çİ·õ 60 ÓÊ>ĞÍÿûÿÀsÍÄû÷ÿç2.4.Tê…Í˜xÿ;k^5éÌ4vÌvwv¶v&ÊªùÙS½SØ„Mwv6íâGŸ5w¡tÁ§±³»µ9´Ï:˜ú–ïKÔq•&|ÙÜÙ…âuíIğŠqìá5~h"$ûy2€£guF!l
÷IµbLˆ±ø:Šs±‚—Q…A#Ş…S i.•¡®£$%ª/UxÙzızg‹‹Œ#Ê½v+ÎqÜgv·ê¢Š»ü‡fğ˜?ÕC	OÊ’‚å©„K·1ãÆaD¬gÆ8ªñ\‘—¥¼i*©£rÔ4”›¶²Ã¤‚‰´‡h—{³»×oÊ¸ Ü·/_ÈñóäêGù6>|‘½dE8¤àQ>“H>„HO+J›kÄpÌ‹˜‹‰@À“4Î¬Ë€»Pf”xi.÷ü¾ÅsBÎ[ÔÀ}Ü:Ğgƒ¢¬Ê@Å0ó”H5DœÑ´Ã(g=àê56,äuRÑ$Y¢Ğ¢4Ğu}Ù\^%Ñcü•˜GdçÇÏØh…ƒI±ÄÑ8*Ø™w´b "N“åp;n})¡‚Gi3‚8`×œÚöSÈ5•ê…ZñŒÇ™ÏJÄÈå"+u°%ZĞÊôj-qµõ|ãtëAf)–l‚ªa¥óyJõãìLØ&†Ç¨Ázçh¿ˆìæ_JDî>ÛTÏ8=Q¬25êøqÒ¤¡Àn¡ƒÄ -â q‹…<ûùDı†C#{›'l^o¢ü&qÔÑÆ'ŞÒÇeğöÉ77¡oÌFMd°™ Ê·,®¡ ü˜[À-1…T½À ôq	¯××ÀÈ¯Öiœ,]Y~¶ß€¦Ö5ÿAÑ¥Ä³}/¥¬y€41 0î?¤ùj	úÀN µKœWJ?™pê”qÖU÷8Â÷W5ÎşÎÆq¢MÖï.XD¥Ü4ĞqYœ_ºG`À»Ÿ^<Eˆ"h›Æ°®°ô¶†¬C7Ïãñ\Q#§¡°™ê~:
7:p!+˜6§Z|ÚçJ7+ì±a‚ÖX*Š‹		¾—WVi±—#V)Õ!H›_ÙŞ§‚´ÅNÿ  cÄâyzÔúöÍëW-z‚°@:he“åo
¼sƒ.t8¿$>«¢ÖÕ_àØ^)+Å¶¢ssm‰hÊ^4w¸+€í(h§³òÉaóZ©İÔ"¡cåï% -'L–cY„0h>¤G¤”|UÌL<2ƒİõœr³«T+ƒo<ß›ç5‰ã©ó©!Ù2ˆ1x~ãi”âOPğª=|«–YŒVt5±e°"^ë±è0İ‰Iåa‡ªŞV†™l%ªõ‚¢Æÿ°Ü[á¬ùWÃÉ-‹·“°c;FP5ÖU- š¡÷ U‹¦. ríô28ß5ëdõn¡:‘ßèZqåĞøÍa¸˜õõfÀ¥µ'»°>NÁh¯Ç›*g6F(.•:\rÈæÄëi j
ä¹7¬-Eëæ™}hµI3¯ä
Jß•r§OÃEñz­GìGsóT´ ç¸X4ã«H(Îeä,hY“81%Á2ïßy¼—ˆœb¢Í*¸Ù!`~Ğn4ìÁ¸Üqz²*¸Ãö0H2¨Aöîc‘Ê"å,ûUæ—8ç‹H¯(Ç&ß<ÁFMæœÊ.+"?‘+¢.Çb` /†KqÉëHªjVØöªnz½PŒ¹’Ç³Í¼{=bÚ-šÙ57Cõ¦ªá‡
X1bì¡CRºr±nºVÀRÑWJ¬ÁãkJc5Ï½˜Õæ‘Ø
`Ü<PJaó ÇCjcUiü#¤ÅXX2V-ºÚ%Èúê#ô`¦I…¥¡¿¢rl‘Îm®Â?Ê!µn«rùñæGw$cítF[JÛ‘[YÄío	'0^,8o‹38|{ÔF5‹	x(\¨Ç(u‡1*Ï
%ët8¶”@l«fö ˜*İ‰ô?Ky\'“@TT€sÚ{l†j©fÁ§MuDî ‡fRÆ¶O§³½‹÷ˆ~,ñÓ _føÌËMŠ¬mœÈgºiÿÁíG¦œú4ËK,$#Fi•—GB?æYuV—'[K˜+NC‡º!1y¸Å‹i€•B‰H8zšÆí­ÂAòWi³òÇQrYCAÕ—±¨K¨vˆÆQ×Ó(¦RÙ ´
¾¬ X¹·¯v+-ŠGKõe(N †Vé-ĞÃV8ĞD±‡c8Hûq$.w—<ü`›k†(œEŸ[ÕÀ-–1ä÷ònFB.‡€õêDX¬öÇLw€€	f!y’ÊƒŠm8;	=#ĞÍğİÎop`$Ì#Ô:zLŸ«¬/_ò0&°x´ßÚz8m¥ú-<. Œ”¨LjK²ÔLC{kÛL£ d†ü† aÔ˜È9.l&ÅœjÅ…Ÿ¸ëV& \”ªˆt‹¬JÄgÑ‡õ¤Ç#Ñ©–jAıÆB2"W›¶±Øµ²/N²KñÔÜOc[Û6wào~¸EOb1²
ˆCk·¹¹Ø0“z!‹bu£¤¡Ã ÷/şãFßéìÒV„€ªÚ2åì¶íHL
‹ªØ]Ä’‘Ï«ÌHdPÎ‘1µå€ø0$×Á)BÔ‡ ¶3Âä¸.Èa”8E¼ß"IÈ@SñÄ¬ùcjÓ z&B€áx¦˜YR è†ííºtÀ"İå÷Î7ÊÎÉÀ¯Ut9¦&÷‘«˜~äœ¡kê6y«ÙÇ0‹dùM ÿÂâ†fªæÀÊ\ÁtÖà§;ºKğØ¶¶•­íM•ºÅ‰Ş29I·â‹iœ6™Æi£i,_5ŒQToäjè?JÃ«¾ŒŠ#_É_Š”lÚKCP?N¦ßáNÕ¢Ö•3i,%½ÇÜUÚ©Àykdp*À“€İ<kÑ}pÙ5­­‡d8dÑŸÓ†Ó('i]e:X"‡áL°Œ§±§C¨‘š¬èEX/¸zûïøãätÃpk˜‹ŠhbØ\ÕàÊÅÁV=B&SÖ¬ƒ¸„2æbhã–âDWuìšˆÛ…¹{ĞPÈ×¨®èH´@’©GÁ)pF‚à\ËÔ[IcåÓîz€'4¢„6	Š¥+y¤ïx^Ñ¼Q•ºƒ3%šEÜ IáEáO m¾&ø»ƒJ9}\N0FíVr–ÅÃaíáÛo€û%NÄ%0±·^ù}§¯‰êj9ùì.œiĞÍ0‚Yt¶^çÊƒ¡¸"Çd»GÇ„+nô¤“2,{#¤£©¨Äun«ñOØœèš§à¡f!ÑWsZ°)ˆ5Ñ…ˆ-”ü*BAÒÃ=2û°:‘‘„|*
%ƒ8%JD’pèò?]m=öıØ°rªé+µu	s¬á|½n4ñ ÇªÚûOR^+iÑh‰Bèˆj/šä.Õ$äíÛ!÷ZÂwñ|j2è’"t5òBy(f¸³ÚE[VdljETëxV÷m`¡*WÖ-àú±»?j„j¡ñî(.ı?à khµV”¦8UÜ‚i‹s$Úª¸ëhÅÌ*%C8Uúâü€r‹m‘•V#9œç³ßŒÿlìd-ş½cÅ€d«BQ1Éò$RÄÈÓ¿`B’é’«,Ë¨¸¢9“`Ú‡Z/eü&¸ÒªbIH¡±šô1càà€ÛaC&İñ1ğf
;OØ˜¡ M—°w F)=êŸì©Uƒ€RûÙ¤E ¥Ğ) #Ë›ø«Tÿ­]òÌå¤û§!H5Æ@xº¥ºSPI3W?•	ã0Èj€p|"¨,LÆÌÙqœÏy¤I=Îuş
X«9‚lZr"X<J"¹Ì iÉá†ÊŒÂÉ¸:†À•IŞaMùÆ¸Û¢á@dMÈC"á™½å‘Ó4”wÖDvŒ¸•kù1Ø4ÚËÏƒ†ôîb=è¯ÍBX·Hv¬Ì¿a3Qw®İXóá%@rŠtcWÄŒ2™²+1Ã<l\¹\Z£„aeÎy“¸¡Â' „,¨b‘°0ãèÑ 2Eº©]ãˆ0*4F›;,Èí„(5ê‡ †’…TzÍ5\³>ÄbÃ@j¼PTÀ#%’Q ÇíSÀ*+†dIŸ.=r§“Š;áR´¥åÄ¦ùB¦ògÑ”“N$˜ù†ÔÒµö ·d}R‡)­ÃU‰å	½u/¸ƒMUPüüíì,†7§ü˜$YKl°¼9wŸÁ÷HŠ)’IÎ:jTÚ€á>èû.¡TºÁÅ¿œ¸E\RúVâ’f»˜YÙğÙ(·5J j:J¯´à¥¡Uk0G P©¾@HpİˆGö1åŒj¬^£·3­ZÛ¡Û!AÕA&^¬¨<8ÇRYa±ÈòÃùD'H”×Jáª•ğC] ‚¤ßNu“®,ÉÛçá‡(8ºT$q7¯ÂDÄü	¤É0ìÂ7åª§×”SáùÀáŠd´@2¸cøÿpC¶0Ú¤A ßMÃrt°CÄŸZâq1‹Ï)ÑTµl¶C)8—õ‹ûq›’´¹ÏÊÁÅµûTßgX/¬O¶ÂM½¦T*Q1ê '1ÿÒ&!…32-ÑñÇÜefïWT•.üZr`~&}‘ŸÌÒÓ§Ínıd¹vÎĞh…³ëPü˜•§ªo¥d¨NãV
¿Šr¯0wòÙBOƒZ“Ì`¥›u†uÇñSªfİñ‡]à­—ÃË$Â­üØÅázËQW£Ş&‘Ä¹l±ÄÜb¹s]l¤\¨1¼šÆ£tŠ¾¬öU\-$ÖØ¸CSãn{UW=öèCvZĞ°ÛÔ­Õ¦É©µqÉ­øxfHÆE§ÌW?à\üc$o0äì¾Æ.Hd3g¢¾±œŒzÇá±:D ¦{rÎì]0HÑË–“À©˜î0HÊªXs“~x$%éÍ3ÖKÓ	’:'W:Fb_˜ä7T»ù•™’å¤/aFŒ]ô¡"40‹:*$&$Å,L"Ğãµûz¨øWİ¬vô!ÒG µ?ë 2Š–9ihÀÁó.ÕX@MÈ§ëÎt}{_Â»¶˜¢¢Z&‰İ­›^ƒ‘õ­!×ƒ3–ú8İQªSÂßÂ6éê®è%P¬)ï”ÄB° ¤{}vD½AÆ®ˆ]ÌãNG¶5?j–E&&¬e-Ê¥J¤÷û*§¥¡A§tÕ‹Ş5úÚlîàª½¹ù[(ÆóÊ¡×ZE‘VCt÷RÈÎîL9H•í`K„Úí})-V‚çF5fº—ÕD(ài</Gso›p…Ú*¾ÇÔ”s†w:OÁoë@0Â…Ü‘ØÚ£MÙCšEs²‰ k†QÏ&ÛáCnBÎ&Ã¡ÿx¨ÄBï^˜ãâ1şõû>E~r§Á2ÏEØ&œÅBnq-ë­Âí$–¨œ#µà,D`ÃÈp§ VÑºTÂıÄ‹ŒVá÷Çuìš‡™ªGU²qÅÕëıg¯¸£|ÅÍÏ¯8—,±A€`L³ÏlZ57ïê˜Î5›†47Â6÷ŞœM¶FŞÕÅÆ¡^Ûv¨‘ëõÍ€T6¸ÕƒÍ ¤üóooäî›L­L8Ùm¿u/ ÚˆhÚ°û?Ööì>vm¬b7˜t\mÙ˜5øØºØ,²ætTĞ0ãO\•Í7y¤ÅMûİ´L†ò‚7  Z-tEü½»Â_Q¡¥mÑ‡‰ßm:ĞyO	¿Ê|ÀÅ®yAñÈ4+øKöÀ÷úşQ¬*7†ÓÓeD×_Ãa#v«RB„§CZ°’TåŒú+Ç—:0u#˜Ôö;…ÿJqhqÕ®„ÕşÉ!(…Ï„>(°év>jn˜(?´0›À£@u]Zëiãx¾ŠkBo+éÌ8¿êT?Z¥ [UÔäª¾™Mv}o£1WHš­’Kg°‡`/·¤¬O!šÕúˆ–Z7¾D¯bªŒæG>DQ5ûØ"i@•ü(T	®ê—ã­1ã½	jzlãûJèÉŞ†¸‚®z‹ÒJS[¶„È{èÀEü2‚¸CDù§_É› ²1l*`‹«5m}ü×ÑÙ™¹ÀI‚ìÜlŠ/H…‚N_^+aOQ@^	Şy#EïdÑõãŞçÍŸjÖj˜®ö¶)5 „ŞjÕPÚ'lµã,Ğ9‡ 3¾•øöŞä1ƒÄ„®rV›¦ñÑ3ç½øÔ>·Š;Æ*Ó
rÊçZ”1Ù`­Ã€	0~aÀÚpXJŠÑ1N!? S½…áÇâ³ÓVØ¸1†ş¯ÀÆ¿@MÊ¶ÒCŸB‚ß”àAv(d†”Œ¾H­%#€‹	}¦ª¢UåÄ%x ü€¹PÄ.ÖµUnß¦®®Çk‹B»ö8Ñ`dGæ>èÂ<iÈµ1ˆí›O¡V«½'éÌâ“÷nOPCGÇ2ÿ«Tİæ3TdZ¼×HM÷zªMĞO#EñÛušĞ g°¯V#eèRÕîJÆC¬FºwÙÕ'‹–WJ•7
ğƒ7PG XÈ5ÇÌæ9’W1xÀDuuNÎáëõy7ò–…£ñ1”$W—ŸÊ|ÒG‰]?.¾.'úˆ°Ğ´O—–§5½WÖVclY5(ŸlÚøo)ân+ ·¼ãzŒ„a[ Dk÷–ÈÄÆfj2æºÒŠø
ñu{m	PN™°ÁñD4¨—fAî!fViùÕ‘(	QrFk¾ÇÊVb©
ƒÕDıçJ¤÷F. Cµÿ™=˜­¹‚h0µ8m7êLïÏ 2Õ™ÇµÑÃK™t§£—šå®(Ò“?Á¡Ç%.KÙ‹ÖRAÜêî—.ÉÑBvi
‘(r”øºÕãĞí]
AÙ¹S±MX¬UÓŒ×v†ç‡Ğ½®@3ÀĞ2 ;–­w.pBc³Wm	9bí^9"ØéüE…úX!‚j¢a \«*ôG®¼yúâ…sBøÁ1¬¤À±49„¯¨=6ÙÖ6øX„+Şìş5‡×¶æ¾Ÿ`5jÚ·ëñº©- 0£u¢4jç<*®û”Æ;[3P1DâLÌa"$$Ô’ŒNÎ>¨ÄNöÀŠZÙ`}úHÄÍ¯»Èª/ë`wgód  íÙ—!YiJV˜£©2V'yĞW
×ÛGÉ'|ÍˆGûÕ·¼$ì>E}|%WŸCÀ¨.ã—ÕæsD-àl @¥ŠD2€-‰_€g„ü‡–9@ä3“]ıÈbÕ:ã6ÎP‡ê%î„¿«G{(-1Âø¼š9‡ C#GUK9jü	Gù's'Ó»Ó¢Ño×NŸáÙ‡É`©‚«ã‡"ÓHğŒ~Á «oŒÚ‘–ÆSˆ\Ğİx•³)ÕGrd}X²ì"“s…r˜µ#µÚ«®º*¥+R“™»hœÜ\³pêwì~˜ŠŸ5UÇ+C¯<ÀJ”&Õ1Jw÷û_ÊcüÎeğÂ~PQ~Qí´)ƒ7/ëÙ\‚×	²(€Dƒ_Œaè€(‚ü½à!½à‘Ö9(p@ÉÑˆp±É|,l´Å|ÖaS*CÚÚïx÷‚GR—($¥^ájWšz>6·äıK¹”÷? ;ÿÛŸ;GfÉŸñïûö¸RŸ½Á5?wé½–?hÍã…üæ¼?¯q•ó3f¯ÕßçÏ¡ß¿JÜ$´ï§Ln+¹qqéóÆI‹ûÅF•¨á¹£¯!>‘”EYj²Ou¯å
‚iÖìÃö7­gòVğÕŠ¯¶å=P˜ö¢íÍGÛvl>Ú©S
ßiƒÎºÈÁ·=ù
¦eu‚80À†Ñá'dŒ‘ÿÀ=Ğß;ö÷PëµÀ‚{Õ>0_ô™‚ßaõ{Î™¾g2}É— <wA,á8£Î<S
ûÂú#†ñ§.·ÚÔ3D‡š¯–ªİ¾PE“AæŞWY'–¿¥‹™œ6f?Õ]U„;÷/“ÉÌ~ƒ‚Å>÷™‰×¹WÉ$÷2•d×Ë§—²Dü’an‘[ ²ÀÁÎƒİ~dµOØZşã$pÁLaú¼*ã„*Nr åØz›”øH(Ì†kQé¦Ô&X7Âp!sôÇpŞªdÕ_Ğt§óÀõ‘0ÒÍ3ğ\66êO¹;d<¥<·,úR}´G!(”VJhh,.ñ‘¤ï0câF_Vˆ¡êoÜ¾Ç[{½^?Ôi9²ü§ä˜5ÕEU/Ëy‚>.¿‘Ëëê¶*D¶Lû(äŞV…èÍ%x"ÄëĞÉÀyÆ½E@ç,ù‘»msWµ¥ÓÑã²! <Áî´X%=c!;Úê2$œTó5‡È’£˜H¼9™Ê3JµbQF¡,Km=c?Ve5Ñ©8ĞyÄ3n_W9ĞJ3ú^kFF ‚Çae©H
õ=YF3ö jêœÛ¾â	N1Îq ŸÇ¤uì‰ÑYÀ–q¼ZÒJ*›™ÁG?´Ñ[cºóH~Œ†Ü‡ D¥ªƒÓö8é¿ø&„ú·3ô—zèêk9,ßÓ4lè~é{/M7¦ò!‡i¥‚É×õ2æ3£Í]øçwGæ9…v:Ê1¹ÇqÅ˜>$…Úy°µ½mÊ1åĞ¢(ğê5ŞI"óNg\¨ú~çö-15î‰_*Îx@Ø=‹HÚ Á¶ÌW¯›MÒ·¹Ÿ‹ñ>b2şÊ¨Ñ®„$âù¬cK.Ğ
º†Öæwô ŸĞCëü»•Óæ¦ÊÕ|~–±YNËÅ[©ÃPŸ4&ÒÇø

R4aïD»[£GH‚ÕY[@´½z]îX “8é/slmoMÅ	)yÓ¾´æ÷²¾Êò$@w?²ı“ç|ïõ~kCÛV±|¥[I5$?†»oˆí YõÇŒcü‚H•–@R,—³\FÄAÁ2T_¾ÄÊ÷r´A'õ(| <ñ—Â¯B\/¸üğWâ÷Q“¤È{[ƒ¸Æƒ]âš¿¦ ƒ*XP¿ßëûG<ÕŒ{ÃşèµR¸R$¥$—]™x¾VıaÑPGZ¯c9°2ÃnõÌ¢qŒoç
*&³^„ˆ3¤ÌõpZ)8ÍìæSkg|u: nïZD+µ§Cfu§†U§i jœ‚š"8€gı“şèq
–Ó—ñşI‰mNÀ§¬ÒÖæĞÌ~Xó¤)´ÙØšq%¯×G“ì1ÈZ(o²Æîğå¸ÚDÒv¸¶qÔzb'`ß9¹ß¾sè‘>õ£Õ™£Ñ(iYMN/.¶U…÷<äkóîİóˆ+ìÙ¸BÀ"~«ø'ĞKş”^~V‡Ğ?Ó®úº.÷ğ]üûV8QO¼/WÇçÄ¡'fL¹¢OÆX•ê›-£.ì—±E¿¶¡ãè}"Ÿñ(’£ô=¦ï {LénôÅ±şæ Öt‰ìåF8ó ö=a=µŠìé6Ğ'ãµ8TzÓæH†á0ÿˆGÂÑƒ[>0zºec0Ôk	a"×¿*
¤1©a
w~ÎùŒí~¡5ÒßCh•òm€Ö¦ù>Aot”îÆ=&ª}Á†ÔÜ2%×^ïÂÃ@Ãïı-éB%`J±—mSöñeAé³Ñ=È˜CÌ_‘O°ëH•JKP N3ŸÌyúMxHPæ8/Hcá¶>ÿ¢·
3UQèÃP™!îIÖ°ª±‘Ó2×Bmså™@Ğ–Ê
†Âj¾­6L¡)ªŞmy/šõºX}¤öØ"Ø‘ƒ½ø=Œ`‰nÑkf–su™,É‚iGƒ	Šg¯‚ˆÚÈ#ù ¾ƒÊS
©#3Û1DŸb‰ÈÒ2‹ b…Ğ|Ú06M 
ÂŒ(…Jòâw·S’Qua×à½°ZS+[ñÇÒçÎŞXº.¬¹!@¥ùr™2F2ï‡ğ>¨„Oj»Éœøyo8ºhÙˆGMy¯O3¶¾—Ã™Z™©âë+FŞg½.Ø.¼[‹¶È&Ñ©Ÿú|Z,L}Ò/Wš(ÕÊ$SûmFM¡œ+=Sr0„¾DŠâ²Æ"TCs©(È07•dX¯|’skÿ—±+m˜™×™-
aØÈ‚^ÑH<ó÷“ßÏC‚Â?Î'qˆo&(ß öZœRıM©ã,©.†E©ç"í°¼©êÆ
 ¶5jÑ¨U	°Eİ"EM¶¾É_K.f4{²z”¥kœX•ck€ÔWÙ@˜!¹»1‰tvÁ@ÓhK$èşUzÅQfqÿÅßƒ¬Æ¡º-$Z•[äOzl!eí­ı“_RR+1ÇWÇú”Æ·|Bù]€_U‡	hLQˆ(EÓŞşÔ¡±o4°û ï5Ç†F*ÿ>’?ğÈyÍŠ/«1ã_Ç{óq¬D:S…ù —e‰}ºä5´„Yõ•vÎº=«½mò‰2¹ªãÔ-®ëÃÕ/şAæNã"È¹²ÉÌ|ã{F4BHAN¿Â¡ÌJÀSŠŠ˜z¿úÑ 7[]—8
È<xXiÆ*XÜ³æBoø¦JÆı|•ÉyIÈÿÂ:3ªÁÀ~q`ÔÄ›·+ï‡­€÷Î‡Fò®ÇmqEOmb›à¹Î=IÏ9ø÷ÌRq½{t9½b_^:¾Ô“jy€2+ÇíJSä¬NËn¨±lBİº,Ë³^›ë¡ògó+šbav¤c¬1£­n³‡VGÕAŞ‘ƒr°íz5
7z.ùØZ’M ¾¤6ˆ D5ˆ(ñ&A²Tlê ÒaIsÜ2',Í‰º@:<òJùaÊ!€íòÈañDAİ)±¿`¸¬¬Aï>ò1¾÷z‹\ŒU ¥^«ƒ&BÅ‡«ÍLOeBSóó9ÚÎ:;šxï4`5¯tÈLLÇ¥¨vå3× ™¥DŠàğ–=.­©½‡¶bEÆIæ‰¿¬[Y^¥«ÅÁêµ—­ªè<«	qSR¥^Òók³ø®ªú½!J½—DîGGzÒàî±Ê¹E3ÚíÊa´øvÍş<:û¿ÂÿéÂ²›ãhuaø?¤ˆÄrô¹aûB0Š?C=
#$áåJ"cóæ6iÈ¼½™İcÌ ÆP~p„#À…ªÀ­ÍÈoÆáÑ"¿có¡jiO‚E/²@gVKüØHÀĞ»¸ôD¹×Ï Às	è"¯£é‚œóeÈÛ¬¤NƒI,‘¹‚›€!¸Ôú£q¬ÔÌ•ÁoŠïÂ¤”:âÀó¸R™Œ1 „êUõF2PÚçÑ

è”7‰|Î¢\"ÉÔìDõXºï	û¶Ò™¸kİ	F EZNè]{Gİœµ5…VÁ£‹ìmÒâciğá]@ô¼:FnÀ:°8±ş ËW¶iØJ`.PÛæ ÃÁBpÂ‰RÁà ÒdYø¡ÖÊìƒÿ…:·
êpˆÁªr–ğ]	 ƒ0kĞc0’¹5KY«r)tUò}r†˜ä
‡”Åú¥Ràä=q"ÇğT¨>Ø—»	›ĞÍR5in·ïõâåŒº»~zWÄ‰¦o‚š|„e©l óæ,NæË<ÒÒÂˆtŠE0Şj;ÊXï£ú†n-€N"0Uj-hË¼ÅªZú—¼ìtÄ¯£qÓ;Xù—7òG’x”d:û0´1}‰l˜±Jc³Z¿ÒÍ)Ì¹»Ñ¦/àËÍVL—zUæKš…M[QPŒ%1Fa–aª”²bğ ™—¨[1ÜĞà7Õò1Ê‘“?éÚ«,lWÈyò¯où–Y~`5ÓİbÓ³ZK	f©’C1Y¬–§H=›ÃÇ2Eª+Š‚“ÇÉ¥Œ$lIõÜ3D´<„ Âàk6~èÖQšãS¹¡wá#jD~xÄ¼ŒaUÂ»ÔQ5~PÏD‹8ier«¯2¹8PÚ\«âCUipz—ıW‘,Wªs7RµPàGEæ-˜.¿JÀÌòIÑßç{®•óÖy|6€-»ˆ4)’³ü¬!\á×eŸïZÛƒÖ;xt9x Å8A†’€	Xf§*@åck#7+ÓxÇÈş< ´ğG-‚¿'Ñi”ÑaP–ø6$v—Ò2ú.@šÿO b2‚Ü^"Š$ˆ‘˜‹«1TC&§–
şÁ™$»	)T¨²glL\6ÀDÁjCÖs³€´vséƒO^ÒÉ¡^€H•†ãO2ãâ¬à7,.å6˜ã»qÁ£Ôßı}@{ËğMp/Âs‰ Ÿò­¤ğç Ó	¿
ìÃçÕ¹ğC€ €ği yÃg?n¾CéßÃ3|_¸O.ñ³ü€¿%¼°âñ	÷À¦ßñ
Şõêõ×€$Ş xqŒQso2ü#	ŞÈŞø÷$xşäÅË7O?{ÿæé_}ÿ$LÊ€	ÂÍmYO_ÿdß"‡Ã×Ï?y÷ò­)ÂÆØšBıba^‚Ã¸˜LÿÙ'~ )Â9â|¸9Î`õéy…Ëêš•Wê–Cå%1§ÿı'ƒú"Œ \™F„i$g"&’Ô´#L;@‘jƒŒ0H°pEÎÑ±Ü`,&£(6ÂLÕ†a®)˜-Ì1afêïXsƒ8—ía@@/x%«lng˜Òïß'Kl£¯à­`´0y3SÿjĞ¿ü_©#Üx%Á‚0D=óã©˜o–Â›ñPËjˆ¥Å²U‰áß]õ8ovóæìÂõ¶^¨4FeÕdÙÃD¦°C¤{ê"åª,×,H­¤ïC›•ôBäQ®<=¹bsÕ“é]âµØTÕFtWŞpë|«¡$ò–T!Ì/ŞdYã’¼å.xä­a³Â[äœ¢Ç7b¹MrûÖ8ÌÙ,ƒ>ÿX?9xì½[S\I–.8¯'Å–*«"\tM2%BI'B*ªº(26(JAE)©•y¬Ÿfl^ÍË˜Í¼ŒÍ/«_2ß·.~Ù±# evWŸ±¦»”±÷öËòu÷åËİÎúGÅÒâÃûwïş/_,Ü¹Uüu8ÿ±}~VÜk-µ‹·£ÑÅpeaá´;z{yÔêôÏzıã²Ó^ğr¿?ëvÊŞ°,^lîw¾8¹ìuFİ~¯è·û£·İŞisxyô×²3š)>}Qƒrt9èÍÑÇ‹²RØ·âñãÇEã²w\t{åqc¦øé§Â+ÊÇŞåÙÙÌ×_üüÅi/¥e/xu})æ÷»Øü-ô]×ü¨¿:´?6‡åß.Ë^§Ôæ»'ESŞ·ºÃÊ÷×ø.Ï€VJâ†
{_‘³WxŞgC.?ŒÊŞqsÔœ–£¹bØ¿8`?¶Eü0Wœ•½ÓÑÛ¹â]ùÑË|_~J%­VX#,P<.£-Ôz1©V'ıÁPlÑ;Áomõ[Úñ×
GñâÏ³‹%Eb?t‘UŞ“¶1`~,
âJ„bò¤~F1`&0”¯`kP^”íQs8€çŠNÿ²glHdÊáåÙ7øö±sVÊHeœòˆO‹_ëŒEjûc:k¯´#˜‚¦ß+ ÊÓö¨ûcù/å ßì]•ƒœõpÿ¢rì¶”jm¯»º»ùÇõÃÍíÍíÍİ?K™¥bl,Íh_Â.…‡KŠÖÇQ0¿şBK(É½ İê+-`b¾£€½ÒïŠäøßõ•·ŸÅ‚dìZL;kE_&ªçZå1”È’´s¸4Ç
8ßû¨ğÚÀ]q¸¥¬Â¸b°ZõTi<SŠ(L+…ƒûÅÏ€oa¡øóê‹­¢ #³öpØÕ	Í9µ;ïú?–ƒ“³ş{Q P&CjÈáÂ£{÷}õè^ªÒÀ|çíÑ:j–:åK’sÏ/Ú®B‰÷oËA	luÏËá°}Ê§P£5(ÛC Z´Ñ¼ì½ëõß÷0R¾›i—SÜŠåÏÛƒwAYƒ¡\^¬ÕkŸ›.,°~£Û+n7ŠÙ¶)…ñ¶q»@¿&
<+5Y#´%UÎ`ğªõVêJtúg—ç½P&’aŠ
¾ö°×½¸(MşSÈ÷{û½È­|€Ú,—c°áÿfá&7¬;õ¾\j*æA)Áò'à,³syQ’¯{Ğ—Q€×BøV§}vÖ„íÂàá%)±¬iA©|6zSôHd-ïÙ#ƒÿ‰ï¿¤ÜÆâsÅIæJ»ˆ›½ÎÙåq	½&.Fƒv¦¬g|Ş[ŠÈJø¬{¹Ãâ»,íÚm­½ôÏË¢İ;.¶áBüÓjÆWêÉèçt	† XHM*±(xÜØ˜+6×áÄÌJã;í“ö [<˜mÀã!§J‡3R†RI0£cz\4{å{Å{sf¦¥o)6Æ®´¾‚	ÔîŠBK‘QâË¥ÖÅ ?êÓ­¾Uù´: Æ¨4ä„ïÅÄºĞĞN¥ØaJÕQGê/Ìß53b¬,x 4‹ 	7s„W‹³{*Ÿ Xµ[ğM
Á}»Â Ÿ•E{<:¼€CˆW`Ì[â¬D¯•·P¬ytyrRàgà5€»ÃŸë½ã¹â¢?ìªfdx«(»Ä·eûĞ)ùbÔîe/Pñ»öÙ‰VÄ—íÑÛ”4oÖ&¬êòL1_,uèãe€­xÂ¡Äñ¢Õj©,’JÃ@ĞVVaUw¨ÈöT5Cj@&tîcfçÂÎÚ70ˆñ†Ê³•çWÕeTê ±VÅ³…’©5ä<@`Ëi5StqUĞ\Ø-À	küııpÀg¥—9‘G€²áI±šaJsP‰ÓŠ3í{Ñ>‚ßÌfX¾£w5NÍüUÿÍ†NõE¥ıóö»rG	Xeğn®è‹™j'ö çZÀßC¹ØlÃz‹´Á³Hà¸[VöÑÄeÆûŒ¯ĞáÃ¯¨ É$6½òzt­{#*Ì¢àt§¡"èPWnú„vÈ{Ãg%´D9¡´Äãâî´vVOF0€ÓÚ±‹eAåX¼…ıÁÓıŞOûƒŸöNÙ?aä<f¯Xää)~×Ëûğ~Vç­—8ÁÔàx£Ûî£ò¼
ûû·]è¬&ˆŒ’x=([å‡²#DwzÍ¸¤³wöÑº¸¾Õ*-™ÑˆÑJ¤~¼MºØ[<pŞ“ñ*)…;‚´~Ccp´mº9)èß˜)|Â¨ù—~xœ`Çú ¿­,æRäœ´–4—¾¨oF±¥ÔI¦T]UØb"h»ŸëÛónO±É@ƒs#‡Bı ô}r9Ó
6mÆFâ=P:P1tá­©Á›şÒDbVàš-îª÷C—¡ÙÑ—0{-€u¯' ©àËì¬ã»Š»yV#9àˆó¥<€&İÂñW}˜2Ë^Š~´y!¿M,óFNÈE1fu€”ú/øĞ=˜ñş2ä
äÆØa]£ViŠljÔ œºUô÷Ê*Ù,¨h¸jpÍP˜ÃYàgC½wŸe›¥dÕ)'÷ ²ZŠS¼Î0)¶b+°™ ÁP€ÍgãàZãŸ0zòÿDæaİr2ú¹x¼ë…š!‘!‰XÑCÓeAÄtª(Ì‚¾OTuˆ†<ïW•t1]2Ò=©êùŠd°µkKÆ/c‹_*dñhTâ•õ¾\€WÖ #s®C-î®;MMpuÀ	ü¶ûçWë‡k/·wv_¿YÛ}ùúğå«İM<BÖöĞSãD½AÑ8Gp­«?Áœı³K}3}ìb¾ÓFtõå‰>_ÊãnÓ&¯ŠC8/•ÇmL[ôbÆmtµ3úxfo†ü¹zÖmËaã|œs©Ãí—Ï×¿ßÜ~ b¶İhSvÕ§óöÅæ(ÚB˜Qq>·@º³> Ê.Ôd6ğS ‚†ÄÏÇÏ´y‡ie-ˆÙz»ó¶º‚‹¸)@‹=yuPS¶ÍñÆ²®övdNØÔÏJe£ä
1ı¦Ä–ÿó‰0E h³[„3Fmøñ¦S´G{ ø/x¹6ştœ^©ş4ªD”Mb4u|^4µæ“¨òa†÷çôa–Úl¼±˜v¯q*Ÿ÷ŞF¬!´²ü ËkÎÂX©
ok„nu‹¢"¸Ã¿Äşƒ™ÉîËç/WŠÕãcLlN9ë…›VtŞ–w-©¶ãFQpõ5«¿+Ë‹¢?èv{í³€EÀÔ—CxÊïÛ½Ñ1LŒŒ‹ Òf!Ì‰J†¤vÿ¬m‹‡,ß(é7ƒhOÅö ~²I
*M‚­@ }¯á¢íuQ1°KÌÃ$>ˆq•_sªf- M&†m2kğ¸=j'ò1m4ê¶š4?h«Õá¥S…&|ˆĞèÌ,àÅÔSµ"&—¦·Â0ê+R‘¥ †Šü€^« ¦ê.cúĞV+Š>0ùO‚UÔN@©(aÀ@«TŸ²f
œ”à«˜P®+j8ˆsàÏYÍˆ2=U¢…¡UP%•GW5ƒLİ“ny,1¨éÒü3µ·ÈÓãB5d{áN‰ĞFo4Ü¶0„<Kò˜İ²ÕbÁ	rŞ+TE}Ïg†ÁVû´ÔÕ)ôÎå` »GH\­³¨¶M[„ƒÁğ…Iºq­_£_Á?vû—C¶‡ š=ISŞ¼Ú*ÿÄ‚-*ªØy÷»ßIoì±I!AµŠ¼œ\GY³ZIŞ¶ĞU2v‡R@Nå'²A';.ö¼_2V2õm:JñY‰ö]_´/šw0u†ŒåİYP¬e„%¥õO½ŠØ@Ÿ?aÕ–}ó·0êô2ò—?‰\ço!xzA›â½¬{Áûeÿ±§ü}è+{Û;m+.¢¹|UYì]Âõggå’òsrV¢¤È@ˆŠcYy»'È4á³ÙV'Ößk8ˆñ¢Ùz€×KÚÖŸ`dÒ_ûOÛË>e¦ÑÉI\ºì%øËs¨&|•{Úªw¨c‹İAN±¢åx°ûi\¹#¾XtYõnn©ÕOH‹(o{å¸daE @ÙñÊÂxä÷îù¢½XÏÂiå‡ì%à'DğÀEêèÃ³BÃ÷Qx\ù(lèM*wÄ¦Ô˜İÙK‘tvëdO`XÂ(¾<'áùƒ™¬WŒ.  §S’d4c ÄN%·dD-Çd¸L,åÏ„ğâØ>è ıu£Ü&€ö“çtJ ôúÀ„ÿäúT‰X^§ÒZI w*^ÁÊF‚UãÕ:ï._Åğmÿòì¸8Â‚£Øò9àh¤.ÎAlCÆ9*‚|X›YJÿæ§0`àêµ0{äé<@æL=ãs82Ø—a‚BìÜÍøåÒ˜D8·Ò·¬™Åì†Vˆ3úRBú!âš2]f“‘ö-ë
ÃBPoˆ‘öú½ùä[2“	Œ à¶Îúíãï¡™ÉÌÕW²€`Óæ+@Ş•4øbÚ·V’9İÂŠlÀ³XVÉéÑ*6]Í@i#|ÀåB|^"O†œ¸õúXi¼¼¸èFåñ”ñTÌP-~`¥øuá|Á@§YCLÖzE¿wö‘ŒG"Á÷lë$ğ×ÃÙ*X‚ €KÃÿY9'Œ$ó„ò¥¯qƒ£âmŞ€K4ƒ,ü•Â9ÌŞÁŒ+/‡Ênçƒ¾u¡•ºş:ëØ|»ãÀian#n¼‚…á«ÄÔ^y=¾t*{Ïµ•)p-“YÍJ¬œÓã¯víƒ’™¶V†¥‡§¦á<ÕoÍÎ~Éå‹ásd>"TBqj6ÀÁ+Ìılõ§sË‹‹Ë+(è1µ/½´•¢aROŸ6ÌÓW¢ÏĞ¬™Ÿ‡¸Wñ´àçÍ40iÿB|o£üÛUp”«Àa®´ê~$p_RHà_	Jäà…	!J+K9A¶Â°}ÂÀ é£ªIB87Áá	®şh 3øüúáËâ7hpC°}·±´ì”BI1Ø$ç_ t'’1Î¾H%Ì{)˜N8­$œøŠúK4Bf>5ş»dò
 âÿ‡r÷ÄKŠÙ/V7~JêÌê«7[[p;ŒnY ›ªL-ç>H¸}$V­¬¾
ˆjû!¹‚3X$gDXûÌ6ÌÈPáš±¡ğ;fº—„DôÂ—!JäÓAX~qó³THñ5I`óQ$#–†'—á€'•§`a§ß&eBñBgÓZ'bñòübôqE$P5R_ì¸ g;„ü¡NÂ`“™şY¿V¶{×â{‹~¡·ë3~•¡ï¬pïnÍ«×oÖÁĞ`|tfAFîWdDÀª´¹Á|½ê»Õ­¶šs}Æ[ãØ0	ˆéˆ€Åo>’ÚoRŞuwèıÕÈœy
!;.,k¤×u²gjÍh?$ÒÈ{…€²ÈÔz™&£I‘LL“÷c’¸5=fWéÓ¢¡„ ›+ıƒÕÊä”v°`·Ş õİşíÔ
ë´v„ÙğÚÜH,»ÃïÊkHmv2Uİl.~¸»ˆ(Û"ÂkÌ¹Àg˜“f‡¿ñé+|úŠ‘·ŠÀ Ú½%|[­­vï>mÔW{ÀjíÚjXíDªU¹ùegôĞ?D{kÛ{^v>£½ˆ¾ÄÄlöFåi9ø5”Úx!fÂÿ¶=|U+¬L!xDğ’L®B™·À=™mRH>IRµJØúòt»§=«É"t$æEÇùÓ,Ü
šmx¡ÌË’&fg4‰GéœSm¯°* ùE©I¸t0H½NR )t_OìA> ¥#®Í!z$ÿ}dÿ]z kvàı…şe€ZOZ1ŒÎÎ
F8$	8Æ`" ²‡˜k”<›ïãŞñ!:†æG®­')!ùÅeååi	åÍ¤Iü“Ò9b’oÃ°Z±XÒê!5Û]ä¿)j>Ô (Ônehÿñ¸¹5y«ÕyÛPBWGÊ2ËıÇb©_ƒ¥Gÿp$¹"ü‡ IØ)ŠÓÒ¢o$AÒÙòùcûì»4(¡"æ‘ï±›±øáğ2eÊŠ–œ¬(pq¤°©JE±Úr.†ü
6sÕ?ƒªæÂ%J¼(oXé7¥%êÃßÑ¿mÿXÇª£¹ı"ÁÓ†Œ[±ELÇR=2†{¡İNœ’!:lJEö(Bã‡ˆÇ'VCŠ„õá©CW†½-GKóÌ%Í<‰Î
}¤2lƒQò¡M2-)ıæÑ·ÁÈÜ`*§¼sM_‚ÏÍo•SÙ Õ¢I£M2.V¨µ·„,V¤1±ŠÓ$U†%ğ¬Í[.şòÌv.(@ãPí^³‘¥[¡Zºf+¤aÍi5æ°‘%Snê…‚W
,[#Í—æN–²<=8›?hRAÃ'º‘ò€¦OF¢(~kşÀ"ã-ÄÚ¸Y ²_Ó QHÉÏ]¤×O¦¡Ä¦6èiÓ¤H6ıHŞM?`4°Ùv¹Ã€’h˜±¹ˆ˜]cñˆÉ xffMlˆÿ?_ûÅ¸¢àÁƒ~gÄ°„şÅ	ş”û¢Úå#ë²öÓxŸØ£Ş=÷^§ôÇD¶sˆá©×g}À}~y[~h‡.¦4‘øa‰+ôş†‘•5ø‘x G@ê5J¦ã<u“/ƒN¤iJÇ‹26Ø£ÅÒÅ>Èõß3¢ípn±ZÖ…ïaô$ë„ar¼ß3áû|Ç;|'À1ø+é@[/Ww_­îî®¿Ş61z]"²ŞDiX²åÖıòÔYë¾ìñƒ(q^Ãİ|¿4Ÿ®ìÍÏ<åç¿:à?‡wfğ¼¿ßò'ù\®HQ)7;óTWÑ~k™Í·–µ7IB#X°Mey®M²ùÙïO¡ñYö<¹énïDÊKÏ¨„ÒxõÓ&ÿ·½1aèµ9ë‘†QO?m··Ú^İ™ù’Ö,†<“)ŞVê°0/U§DÔô|
AÌ  ã¼‹en#¾5ÂÆdk*¤€œ?\v±‡ò­líËŠ²SdéT(*^9Õ^úGÈ˜úèşÆåà*¡·OÃ.8å@n$“´Êc›„{ÿX„©ÙnóhüÕ2½¡Ô¢\á‰Tqüu@Ä«6.fI»O‰İbèT%–ÆUL0×oÜÁÖ§pU Óº;†8oÌÎ7‚?ãÅgDGøèÌ?ĞÆ¢˜£g°ãÚ	;©"¦©~
,:?-ìÈ€W/w6ó#VüÓØi‚‡$»Â`¢ëmÈ½j‡`RâîhaWœKÑ´ËòÓÎÚæúöîæÆæÚáŸ6w¿{ùf÷ğùË] rá/‰–9ãÃÎ1œ±~mf	H `Ì•&]QLÆAŒÁv··=Şï˜Âï…ŸVÍ±¦Ì§e†ìeYMÇ®î<<)Bp¤Ö¦»^,DØ²bm/FÌ%èH1::ÚÏæc€bª«tX˜Ù×aŒµ„máæ…ë¯Ä|ëz£@¹IÃ˜îûå
	–»µ(Ø0Ä€˜5w2lnúO;¶»”)ª8 ™G—]ä¬;]08Şv<‹œ3´şå¨8î°Qö~9¿´¸H+%«[%d€5Qp=K¡PKJa|÷CL-™ä¹]Š&'ÆØõr¨Æ íQ‰à?A6°ÉŠ „å¬ª¯J¥ò©õsMO]5[ÕQg  Û_ê©sJ¸È•ÃéÄ0©Nh0AšiëŞRæFÎºŒzš«
dzx›¸éágĞql÷Š%/ì¯<ñƒAX];ö|ºO¨í	¾j,šêèqYDÁë>jÙ2ÛîpÇïcéj•oÄx¾º»~øzıÛõ~e(n<³à‰S¦ÿÀá	³daÎk?–mî_hÌ'UÒ‚¡¦¬²|P`R6z;V‡R,~±Îİ8àw7_¬ïì®¾xõï5‚§µC˜>‚iulÀ=ÎİÑÁO{Åşşè`¶¦é™kÄP‚Ôúæ«÷
è!ÄJR§¦u V‡q„@lyT²ŸëVzp §á0ú}
ba•;3ôÉ«ÚÓÃ¾3ppUÓÁßişËOM:3	È¦V{tPŒşµØûŠÿ9×hoiQ|¨  |æ) ¨ğ‘°)ømØpkñİ.N‡µÏ/nâk²*N^ì4§3¬Q/®ÇWŞ}tn¤b••¯UÛô²yÒiÄ%[+®€lCŸÑÅXJãlNxo„-8}"¥q²ŒzBŒ©|\q¦"Y'HÅı×CÒD~xmNÄ“ŞPt
è#VvA‘–U‚©à/VˆÙ‚z0Sã¹Nd$•COÃ‘ù™Xd©=kZ-êª¨
A3«°¢¬Ç‰Éëå=x„*î‚~°Ø&+Y@yRå.[2<à\	x¸{÷ĞÊ'6Ñë»xÛO#ÈÁ4ùOëÍîZ“š8%'Ólò&|p¦)Š½ ÿÅ^êb/•UÔ&UÛT'ïïë{e˜äıƒdL:¤‡š@t>r•²YÜÊÏBvƒ—õÙå7( ˜9ïuçµc="(i™çT©c§“œä(èÖaiºî‹ä%á^è+¡IE‚è/XPGéW4
oˆATİE¬éíÜ),B7†ª3ßàO¶!jqäæ%9F‚dQ—ÚšìLh~^*$PlÓÕìu•¶ ûaì\z@äÔa9¢Z¢~,[8NA(,ZHê˜zc‘ÜGÍ¬¨İÔW/îØ\ÒwøX;Á•ßÜyi{j´&uáÈ¿zRBe(w#ç2ÀH÷,èæ•ø“bVÈ÷Z¼<YùfÅ0lºíÉ4:Tœœ<õ¢Äq“‰M‹¨Õ8Sã›oò$*Ş€œsÖ¾1RæFH˜ä±=z½şüQwô¾;,}›xñ 1¾÷ñ¿öö?ÁœFqŒ¼ò¹bíõ\±µ—Ô|¶º³şàŞá‹U:µÕgkÏ×7¾ınóŸ¾ßz±ıòÕ^ïì¾ùãŸşùÏÿÒ>êÀ-?}Ûıë»³ó^ÿâoƒáèòÇ÷>şëâÒòİ{÷<|ôÕìÂcœ/7ÀÄ°>~÷LÂñ	n…Õ¯àÈÖ£±ÅãÇ}b¬Ø‘X¡ó$“BâA4¾bVk”H²Öïá\Bl$ÀIGùz‹ºßéXùDâ~|ÃFågÌ@`ïhM‡€–ôÉ•r®’0É›¸ó®{/lm •fià	H’æ'ÈW@¶ÁÃºx†,6E2‹VáúùùmD‘Ô—óUr7Fš0„@s?*	Ínbç‘lHhc2Óî!KŸi+gå	ÃGr’*öX#‰¿?\^ wmYãMkñ·Ö!¨ü°b7Ña#)É%„â\ìS§Y@DïÓz]ì…½ıÁ~ïñ­bÎÑtÊsœ!©(DèÔØ–{ÁeNß=A”<Ï	 õ¤q³uŞa•ü½ "qÌ0áG9±­ªÂ-²CœòàÎ=E]ó.5–õöë1iGöÀ*Û=Å¤äx‘aÌ¤é²¯UR"æ‡Å“'XA@Adml˜e›PšRLZË¾K´¦Ğñ`ÿøæ›½ı”±·¢3çïè=¿<¿Íh­œÌÀŸ$sb¨beƒ)‹ÈJ>ğë»¶TuĞi¡ê“PcÇù$”ÖøœâjKae0)4±+›Ò°•6’ÄªèP¼Aœâ‘¼¬ ¨«p™q3YœdÛ)™ÚhÅ³TY¢HƒÀºŒ¨T™ GØÄOÓ5l	=û‘›ºJjZ%÷^±ŠĞÛf¢ÜZéÅèît1* !ö{‘Æ,w7$W
ÙP0VÒ¨yuI“Í‰†Ä°ÉZ3Bú{ @Ìæƒ“1ĞŒDù-™æ¨ZÈÑ”Ã®ÆÂuq0¡\y±êø+‚!WdbbÀ€Â¼‹@_“©Å àª´Í[{pOQ/˜{ó¡ÿék1ô?Lë¿ÊšV¢ŠÜ#á\İ*H«j³ã/¯LQó^„L‘¨mÒlsiì7-ˆ|$…näÓ*ÔÔ*“¼üX"‹#Ç×AûU¼|-×İ‘æõò}‹´È?}üZÄÏ«Œ©øy=¨ûĞók¾\¦êÀ_ME/¹LôrØúò
éZ.¯º€*jU½<g]âx8Ùi÷í.BüeôÇwí!£şi¨LWUT†*ÛÒlçÕ£„õNÚÓÔóìÙm¨ò™Ù+¿(øáU_%ØÔ|%–Öˆ_`AeÚ,¸Ô¸º23À”ŞÜ¸Z9¿¼;
Ø
ÛÌ	0õè­õL>=²¤İnƒ¥4;Ñ´üX‹y!ËD
‡Y…-
“”ÑĞÑŸ @a]^‘"PáL«D~©ÙÇHçmoªg=MôQ¤¢Ò]ŒĞcÜ 'kj¾SĞLÓüˆ´K¶–ß\&_ñ†7ÊZä™f¾Yu²ğ™ıP-ª]&vúù÷ÑÀ|Q—¢„ÜD9êˆx>5Éœ:+¾ôğ#.aKkDAcJ-îñ®Œ!rWU^yŸô€Ûp÷õiló>™¹ÖiY‚ğ?…	ğâ|>ÊµfP¤8;š¦	¤ÌUnš.‰2¨hıå8øÉö½ÖXï”F‡šjZÔ!£ 5‹R(B¦ºqD x[è8··øFK¥_İV±İªO²œ¦ğÊm6‰ŠöBïˆ¡8eğ„1Ûß@LòO·<äĞl ‚ÒW%r²C‡İã`¤1 H¦ÑŸŠ[Š `àjı´åÿ†Vå,ÁWNR?«ÌÄÕ‚4aúKXXbP¬«€Œ…b1AãqisÉâÃù#9;«¼çÉƒ³jB«Ô¯5b9WÃ‡ë‹óHw×ÿy÷y¤Â¥8ğ ZÕ]Í>!ÇŒŸpì5yÔ?=Ûz¹ö½T“ËÇ?±Úãâ^èí»—/^mn{¸¶µù*íÊßãlT|ˆıøûï××¥<§«e¼âTÒíÃW¯7·wWŸm­«ÿ$c@(ğÃââ<şy„ÿ=ÃÿÖğ¿u¼XÚØÿğp?İÃÿàÇWû—ëòïRö/Ÿ?båËçÏ66šOoñÍš¾AÁƒ™Ÿ˜Eğ—¼ØO™©Cş1’‚*q‹Ã­ÍíõÃg¯×W¿ßÁX	ê£ûû—Ë‹Ëäß¯*58Ï7×Vqnì“5çö÷öö?íÿ\­²»úíáw«ÛÏ¤(^˜ô{ë§[øÿ½öü¿îÏÌŞšùr¡›ƒÊÚo^o|êæJí½¿Ä~™,ü[¦ ´çO>-ÿü“şFË¿ùzaÿéÊï÷xvÿË¹ÃıÖ­ÿ¾§±ßÜŸ!Ô3w¤ßds( Ñ—…nsóşòê‰'7ÒFÜ®¿ÜªníhlãÃâêÂ®Wp
‹}Ø!+Aé‹Ïñ~í5ßWgÄ‡únÉ:;¯V×Ö'6Ë=¥»í£±v—¹+wW•õMïâ$àiğæC_Ø_€<ï!ßF—º¦‘iÃÏÙ¯‚ïayãœÃ3 üëıgøº7ñ+q0éëCÖı4ñ+ëşŒ¯9Õ˜p^Ù*MY<ëÈä•ğú;¦=&É¬,•r¯5'MbÇôv¶„†éƒ¢ƒøâ‡å¸[	½g;¨ÏlÃ6JËíduˆ÷Jÿ(@ ,!Ú·¡0SË-V©,”XÛ¸(‰­²ç”ãè0}€¾Dâ–uczVì>Š]æÅî»Ïboòb´˜XYı!™ë†“µdWû¯IŸ	˜ÑŒÎuÁÏÍ&ADeçjØ¦${X¬Á€Â°ïùXì^	"Šr{±‡õÅ–Ñ»ªmíQm±‡÷PŒ yk_Õ[Lµ‡¶W_ğÁ:Úë%í­Ö¶÷[ûLŠ=«-¹×P²V[ì!Ç:HZ{^[ì¹JÔ§¶¶TßiEb´ø¿B,³×Û±×ååúb(¶àÅjËÜ§ÒÛ÷2ûî×ó‘»‹=º_ß{<ŒÅVëé;İ
ÅÄo¨o¦çUVÄ—«R%Á•¹"%ğ¢5"—Õ ¢àölø„Ã@S9Zá5ÛåŠªeíz½'KÍov7æ—à¬9\Í‡{K	ŠA>°.á—¤–½Öû.Vºq\O›gh-ğiA+ş†`
\ÃÃ7­åg‹Èá^\DÌA–	š›•c’HÍ©Õ±w£X˜Å+z{ê‘Wq1mñ.‡.åà¢-uhNR%²&›rÒÌò}lÿä0m»2ùpÔàI'¶;\%'îaÚÆ‹pŠ–u¤…/$Ãîº°$H6âí(ø‚U¶!pìuydkú:è¸.5w×ˆñH‹ ÷©õÄ´D?kgbâUYŞ­œj/GRû½üWì®¼>Á <¹™ş8ûÚ_Ö¿m§LÂïI*èK—c·m
Gö“^ú½?µ=|˜T
/ãñÚ¬ 5¿ëCÅÏ¯%_à)–ÇŞq±ç,ò@Gl3Óãyùš¹ÔZÂ~c«m@\äˆÅğûz€äAŸ¿e&v”Ğ.0u`™«ÑùÈ¡$ÀêË0Âÿ–ñIÊ:k¤UøR+ÔœE.§*öxoTÚ	ZÄKÖ‚;¬ÙG–ç¾ó¨=Ff¤cE|8HÏOØˆgùXÿê+±A”‰<¡‹ÂR%O¿Í†kœ¾°®@#—ÕxWùkğ'RtÆJoª)—F”n¡iœ‘y‚Ô‹m&7!áˆñr³)qŸÖÃ¬W	ô…U¨ŞJd~ş¢£2Ú´³:¥SÜ¿&)Ø¹ô„ÃfoK/Ü±«³äcd¡˜HrÇÉ‚%ñ!
¨‘í€läïKÂæ-œJ(H¶G\ò¶?Hß @(¬_Ã#O-¨cĞv#j€Sr”€æö"½v„¼*»åSµïŒ>¬BÎu×ÍR¼år¯êWorãwıª™#zB 2´p~äôôÏ±/wj"ÑDÚ×SiœŠ+V×Ÿµe’-í—ÏúEoD}z=‚EwÈK BVøWnÁ‰W½Ø/$¬à&X)`¶ˆ‘Ìx—†!†YeR.5Á’'=šF=İ¹ß/LbŸŞ8ahÚuxA'ºy¯¼ÖH"Ã®ßšBp3ıä’=(¹ïprÆXVx Ø£
Lğz+Ÿ™‡ùÜÕ¢CL+1Ç“‰åváe($gí3áºÛëëbUğMFÂÒ“²€‚3T7/yr²H'ÏÉ­(i=Ãf{ÚAª,F({×6Ÿë|±ıÈÌÂFøÎ›|™DˆÅ’Tú’ÄlàqÙå1;ãû=f´Ñ­
„KÊx
Uaİ)°!OpşÅ9Û5ˆj¼ì1È€|@ÎÏĞò%,´È)”u¡Ìx™e/#%#
%…T!C¢‘—=úMP¬Ø‹'à9™dW›`s–x,%ç™JıXÑ¡€º©à3İ#á.})P<ã">†ƒ¼"|Ë^8lùš ƒãæ¨mŒ—İöéu¥Eåë_D?$C©2qu¹Œ Š(Òc<<zßü3¬`_ FSiVälN€ão—°Øá–GLcS÷TjKÉJF,'óŒÊw3Š]wÇåÊãÙ¨*p“3Ç"ëª•gÔ¾"_ú˜–zrœ7!×‰@ôqìnĞ‚ìqc/°AOÿ6÷_ØrKF€®²UD)­§CTA”VQMG˜×ÂÔ)z®c¬¬\¡¡ã ­áÚ/è8L+,e€Ÿ±qW¶‘—¤mxõŠrüÖ*ğ‡£IT_aDåM*¥ÔÙSLr6¤EÙ9Ñ »E?12ÄÖÊò”·R¸õA3¼9G4ğl%œ¸ğO¼^ ¥Â”ÔoR>T÷u®8éÖøíË›èĞ¬-ÜÑoØ×Š 69uwbï©ú©ÀAA’Ùa mÁQ2€ğ`]„tœXğ/õu
3ç\$JÚâ 9)G¶zhNŒ?ÁÑÁŞjFTx€ı«,2,E]^dÀ3)­š<IğAçøñF©[gÈ1ÏÂÄ
ò„SºÇØùõr;&‰ºô°¶æØø“œBW=Ùº’
•¡rºTÑpâ`é²}ÎD4dşáö Şp1@@ìV`‘ªTP®!!	Ã&ì*‹ğã¹ş9tn=ÆöI¬7êÕŞš’99ìã {Ì~¿Ç*~d^-Àw²8Âşv‰›Òº£¢Éµñ']‡ijÍ€„yE6=Œ(!®
æ×âR`ıüÇî1õîĞ…lŞFšv%üHg)G8Á¶„EpŒZ>¨hˆH6r¿O±~ -øMá¥FašFÆúè"«²Ò¢š`22 ™€(î'ÒuwOT)"Ó.'™—Œ¹cræEä°hmüÀ\g	c 16’ïò&B ¸AÓCSä'‘NÅ·Å	Rü¹£ÊP>½âU§ŸHêAÁŞ\D'ß# ²AÀÉÜ¥¡Vï²àyœ&sãˆdçÈ~õd‡\İÒFş„‰4¹á$ÒÌŒd¾Â}R¹çrÄ'ƒh“çA@ëcöÀqiÓ Ï1®
„ÙÅÉr¿Ä`ĞcŞâTFh€	şWlUõ|ÄålS.€ÄVE™Èï1BÛ3øGË‚QŸAİ]©„W2¯g
[É±ï0“´T†52œcHÉu! úr,ä‹jU$–I1œ¬€LF*îrjª-õÚg‡JLEMö¦{¸MA96fx•vAò4JjOå¦Õû0
“æñKêJhàÃb?vÛà*j“o$»WkB¢à.ñ.Iœ2,úïÕñ’¤][8	Û¯}3£ìS‚À3ÄZL¿Á»z¥3å(Fq†àUdÆñáÂßÿŞ›†ˆòš¡cS3>Çã^G ILÕVÍÊ4mÁş…!M{¡— ™v’iöR)¼—[Lû¬€0"%1|ºÊ…b.ÂI,Ÿ‹™œƒD•°î±	Åo(8˜µrÏeÕºUÚ5S®Á2şÓm ÎÀ×l|R«¢ûÓ‰§[ê8H@89êåÖU10Á`çP<'fBİ€çç)ŸF3VFËé„1e_\4ã›L+è‹¬–¼Ê«ºëí5a‘bOşÑ«Ô¨7øÀ´˜ƒB†wMfzâ+^rƒ²~+f‡eµ}8*;m*óL47ë•©Ú½!N{ƒ4©ÒTÅ0ÆãÙŠúf\Ğ¡ôZ6*›Nº§—zx+rŠ­5ù­ì!¤Tûåı +¾hµ†0÷JtrH°ñ´¹ÉÎËÆôP(—œbéPÜ«`cy‰U¿
ß…j,*· ©5›Ç3áPÓ#‘·ú7Ñ™µƒoåèXe-H%ó}íœ•˜d‹E¾$AF˜WáIÚ€3nê‰5câÍbëj*\:a:\Ê|
Ñ@SØkX¾-+Å—È™>UJmÆ‰["ÂœrÀ
0_íDIE!‡ –©]Î ]Ã&–!ÖwwJÄe"Qî¨Ê¡ˆÈ6ÙŞ”“HdÂ ëà³pÊMinçY š~åêË^#s,Kõz›ØjÚHó˜VÁ( b©Šx<ñÀe
d}1{b”…Uv á<![kqõì¬~ğº.§ôw”á2ÌÔ0„å»Hø$(Ï`‚Òa˜Ïê—LXAp"WÖ»à=É¶K_Ãï¹|)%êtùÑÓÁ®E´g¹<9©øEù<úˆcÔÔÁå,Å/Á¡v[‰íOt])*zXDš‚¨ßE—*·"feàë8RG«"ÀwU8¥’@S*ƒÂÚ4yrêÌâ SèSê±×\¯óÜÔç¶ŠnÊ¡oó×(ú!È$ÁŞİ5,@hD•?Œ;q8ÖësÆõQ²#Š“°ÊÉ¨‹Y4SÂ0…(Û*Ü…2ú
%B¹DIçc«ØÆ©¯˜À¢2ÖƒQ¿ĞâSÌ…}6µÊ2-É<D’¾LT&é­ÉÁA³
ä˜ZCE|Ñ¼Ï¨µ,ŠOX*iLr¼å%ûŸ¤”BE´ê!GF-³^sÉ–Çj¬]Õ¸E_¦ÜèŸ!ª´qñ°Nÿ²7Raà£P6Ä7{1Ş†t1JQjã¥ò„ÜNT«ØÁ‰Ø9Zâ(áÆ~{¤cQO´G¨94Sw½b$dGnŸvØƒÿ¤Â6'ÇSu{8ŞğıšŞlŠ²€ vYR8xEÁğ/ON^x0›lë…ìİ:BÙV»^!zd€„¢‡U/%" ÙÕš:d®@à>„Â†\ç}ô¯×ZÅ·K»2©Ye!ê>æ¯Dø\ÍY~›\|äÌø!ØÀ¬vüÌdÇßQÓÆãgºŒø¿IŸyAÒ­‰Ÿ2‹ï§‰ŸïRêŸLü¼Ì+‘“?{ŠãÈ™PùÛ‰µïÑı~âçüü>»TäÂI+:dşÒ]f6>e‹™fs}ç^Ü4¦ÛrgvyŒ/Bk	éq¢N„­Šmà8ÏÄú_U»â{sÀ
™É‚_÷ıã 
¸’¥S)Åh£€†¡;×³ô˜´¢TÌ‹şHæÔæ ³®$DK4GèòØVgrñ%‘úeÇù2œ²üŞÊ•4l¼¬${´A[^{ˆª·­³1–
í%ƒ+T%¦Lµîpš+”q°"âhí¤6Ö°)#LL()›PÒ¢¢ıæhœ
Ñ.dŸÅRdeÔRd…ô•—š2+—¤¯ày“ *g„ÆÇmÑ~FQ­—šè[Ôå“ü˜\ÓØÔD*Á`¦—‚UÜq×.¿è!J·Ûq( ø¬û&õzÓ–¥ÁcìÉ!˜cª%bĞuT¾,îoÅ¿H†ç—wØDMrÌ"ıà$	À¡JÚt†6<ääp\A’¦+ãÄQ“'÷‘@c=ÑÄho†´i<S;q“z>´›âr™^mˆÈÌ®s´t£X2#$a×·Á…[Õ¡‰®¡§º÷ğ¬üÃeóI«BÃ…@ää™ŞôÁVYDäxşr"Gu4nü
ÍÇ±p¥)Î;Õ9z:‚«8ƒ6,S¹kê=!œ`F"3jÉÜ»óQFaÿäÁj.5‹²5EÕÕ°­Qò*°"`2K$¦Î‚®³@ˆ&ß`n2&{.åc¶Âú‰¨_aÒœ®ÓĞhe8YÊQ8Q£MlšKìS$ˆ%âb¯5hj$CË)ıyÅ'#qM¬ø²çÑa¹ ¦’\i—ßE?`éŸ
‚Ç("™±Ÿ\ï&92ÀÔq+aÍ^]Pd0ÿFıÎ)`VÕİóş%–Q®­îúU_:Ï–—§8áÛĞ›œ^Ë!şbtnĞù4¤Oı\wÔÎÎ”×¬ÔÑÎ%éšìûkkÈê(£"š&Úù@*âŒš)›”µ3å˜lt–w}6DÓLåt]çÎC	ßDQ§[Óy^>É–Ş÷±™ÁÌnO\×“ˆ™lwAÂÜÁáè©qz¢¯0Ù²&Áf¹JE7Ş®1­r¯ó6ÙMW:˜·‚…¨ê5wÃà…S»2Ş{"¥ZÙÍ™Î“x„({†lb›4„¥Q'ö„â:€å^~ÔCƒÉãü¼![§|İ>6ÕLOÖ$«Ù0²í2À”÷##Q-ƒ›z=<G˜sp†(6o¤rÆå«Ú´ `Ğ¤ßâ‡QÙÃ¾~®Õ}+Ì6øºJ[ÖÍ·`İÄj“©¯5ïzÌØQúãV…¿]"8[xœ¾â3²Økê´€7R§Nâ¼½i
ÀÊü—·A¢„8ÑÛ8óüŸŞÛ˜fÕÛÈ#üã+*ÒœXq*¶„1j%¸ôî8ÈÜ9{Ø!ã†7—ğùVdğ ~ğ¾©¦º0Õgÿ‚|şG‹cL)¨ş¦;dj|ZGj%ÄFù[Ë°òb•ì j95Œ·lH†™¶Œ“ä‰eşrPüÅ/óªtFÎ/qE‡P?Üş5â«<ÂD´jwhÃÃÇ05E6½5İÓ™©0÷§Lèé¡ôÄOÆzòH@ÚÙ
©š¬u©ÂT9ı9ßNÓúÒÜ^úÌÔŸ$¨ úôæ¶nB{ŠÓ"ÒÿÌ¨Më[ávSâF&qå"en¶¼Rtµ1
€ÿ¸EI‘ÃOqs-…P¿šóYVX2šÒìTŞh`¡ál4óRù"q¿n¹‰#ª±“çİ!74sM³Ì¶ÑûY©¸Ğì=^ÉöL—ÅJá [Æ­5	Qá$ ØVÌoOh	F·‡5ræÇÁÄ^!f‹!·®<¿}¼íŸÃ™¸ºgn©µŒ´qî([÷Ì…Ìíà©0	œÓo4­ëœ’,~‚•İã¢1×¸m^€ù Ğ,P% YÈÕ‹9mxKPr¨’Ã«î0Õoxaò®Ò™FuÂ"XÄKĞ¦¨§\1æêkg½tÁkêLìÅD!×Á59&ï*r9¾L8ÔÈ Ûÿ	¯b«Â e)›v˜ğL
¥»ë[RQjì˜'¦±š¼Q0Ñ 4éÒOd£ş°ÜİÇ+®,É½³Èu6Œ ]Ù|¡Tµ×›aIFùyš
ÎfÆtYº¬Dƒ4®ÎéV0,wÇW c¤|0¤šIŠûfC×:¿œHÜ€rv)dŒÄ˜Oİs³ÈQ0~Õm3º’ÁwÎ¤øtõõ¤"=‚az¼%G2O‚‰Šg,)|ê>‰ å}6ƒBaLî%u¦x3ÿî[cHÜÜ¿g+SŞ¤áÄa‹ûãºƒI¦-ÕØcÅêqÒ	®ÌVYõ;ï®±¼Ro„ıHsp¾Ç97ª|Gk~~&ÏÛtø¸{ü3
ËûA)R#ÃúreXSÌ¾0±/ì$]yõæÅnoA
†¼cÿÒ½ÀF5­G£Òñ¯U=ä×¸¤®¼[ªìÄE
LoÆë9Çe¬SëM«m¸^xpLğ|o¨‰…€‰#‹Œœ8{eÚ:¯ˆqvrLşhLÖ«¼-Ú‘3[Wâ³œíª–2 ŞÕOm´IÓêhÇ~ÏéËaï™ÜóŒs‹LIÑß$4MfÙƒãA3bM‚„\~K‡[#÷GmÄ)lJ›&½"zŒÈ¡@{D‘¶ì/ÑÉåXx¸g8÷‹[±²—Æ ¢¸•‹`N¿Tô@cBÜG/w›VäØ¹—TÌ8˜/jÆ™`Ÿ»äˆq=!EÇy5	œ¶IşNĞ§j’'-È3]—INñ¸bî¦IRÍZ¿MsùÏúü®ƒ3ÓÀriè€QL4/+ØScÖ	bOSDıù?Ş©ûj5U­ĞÃÚÙ£ÑÓt…Vsm‰ XïÍ
»1Co¬ŸoäŠ?I(&ç¤j Ëƒ|[m.Î,¦A=Nc•o…t¬BdW»B„?…ÜY2¾ƒ«ÖQÊ|G§gS´rÉh²Ä k ³Äv=ª©k¤:Ãáª}c™$ÂÆŞdÌ²óª »ü\§Kfèµ!ÕßQ3C‰eJ8Bís<"`q…³ı~7èÅæŠƒÀÓgu:®f}%yˆê7*°zHè‚¤pøyOø*§%¶Ê–n¯CNi˜Æb"ÚŒøÀÉ€ŠÃ8$¦aG=èËFA¥HšF‹?ˆüPt>vpL·ë"Sÿ~é¥uGØÎ€İRİ³şéeéıf:Mh:oH:àùÈÍxÜx‚ÀÏÇbp	¥ÏFíT
°f5Ê>w%Ÿ¹'9Íßà g§ºÔ€±›n('J‡¥—!+‚o5¯zÎûÀ.}ß¹ÍÖËc‡¨¯Q‘ÉÎ•1W-µ‚C=×L6<®ä|‹±èV³fç¤U¬ÀŞÀì£Ö÷2ë_•b¿F91iËÑ!Ù‡Ÿ¸ù8SöÌ¿¤^ãõÇ•D·¯üÓ%6ƒğä¯È°ßtuJœÉ —p>Éd‰Ğ“ÆÅãM¿l½/uÇyûŒ&|Šq€º4‰3rzçx•t¶iBq’ÊØCz¸€4oXàq÷äç@`[†0«÷2æ›T»¬ã–ˆŒ¨Tw×[‚b‚ùW¢·×Â‹Ãlˆé!¾¿-ÕãŸ)G›´V DßãX	œ‘Ö„d|Ä¢‹Ø¾õ:CËu¤œİz•66:Tj¦Sæ)ŞaD%˜îIë™Y8ÎŠÜŸ˜ìıõòùVßá˜¶ ª8uàÒ¬TAK'Ç›š©¸Ÿ.-Í¥ë29ü‰´ôy-#ÿ* îLàEøhë)“Ô|Mˆßq3›é1èë|WŒÅ²¹­nÁi8x6[}Áp4Øå9ÜFY¹…­ÿŠğ“4dJ‚h¿ÎWlà¶AÚ£]-
éá˜ÁHHÃW'¼lÁS0Lo ¢²+–0wÅæÓæ¬ÆÀTÎ#êOğÆ¯É'#YŞ&ÈT7~÷Kjæ[¤UbÏÏ©¥lÎ(Ç`Ëa2óy¯‰:¡ôyÆ‡°0š„q%pX€ôKìNªÃ>¾Ğ\²3b¼ÓÀÅ©.ÊGwZ0*ˆ¿jİ¬IEé´)K²/ƒªD<e¥Ó‰Ã(Çu±Ì*eî?çxT
F šù|Í ¸_´S·TQ	 s¿:ÃÛ•[ Ñp~£q*%³˜¸øP;|’Ñ"ŸÒÔÈc.	ókÅU¬IÆÃ;â<D+å…¬{ÜŒM`d%gVg0mº>]ìÕ·¦³*K½ú-„=ñHùL?Ú´õ—~ËŒ”rR®0k—­p(9R»®5QĞÑĞ†‘u£ã‡`j³H2C‡…­ÔğÙóN–w‚—¯jROÄBºV¬5,á¡Y4’ZæNF•öª§Š şô¼‘]7ÕìJVU¬![óĞV+ßâ*“vŸÖk|)î{94.3ÎÎBÚêYn9~ü¥¨Ô¸ww¥å¾•“'Dˆ&x%®ò^SæµTTkc§¿È–¹ı^Ï2“ÉjÌÌ”uvaıM$‚£çŒL·CC½HçE,f7œjÏc~‡z†"t‡zÁ
jrB< âDŠ–Œ8úXÜ~zÑ„Wì|Y=T©ÔÜ¼äÊm`TÅq©!$Qd;‰“µm˜¡	‰	;Û¤­c¸ÿChÒ=Éï¤9şÅG.ê’î!%*µğ_ªLåj4ñ/äP6ê¯«³S8s<ø3¨¡Ôíâ‡l„h7ò¤ö |4f1ghÀMœ;0–{î­+YÂpÑ>ÁÌ\"¥¯¨ >;‡O”«Ë>s’´†5OÎãú@—èZ1íâ‚Í7Š+:6÷‘Kj¾Æ”†Œ,ùC˜>i†Ô×œë¨*o·Q 7™¿<ƒó…¸#”2Ûw/=¡FEµøAK¤†x_AúÍ%‹âé7mTÅsH˜—Ø†j±#.2‰¼–·Èäº½Âd*H #bÑÏÖA%ªáÜ´*ÄôóşQX5+!oÒb`áPÀµ¶L…ŒÌâC–«½•J®®“Ì=à
»m—Øİò‹K€œÇâ¬åj-ò8ôµM•AŞcÄãZÅ·!ş[úm¥M´IDRtSànîY“#lN:=V;}º2a…­'"Wˆ.­é nÜ‹!‡±õ|º˜mIg‘ZùlØŸÇºâ Mõ ç¨AÀïóÂÖn¡@ú°L&ÛQ*Ùo‚…+Õş?JñßPõW5Qı_©`ÇTlE'p© À¯wé'nAæààsœÀ‰q(s¦«™JÂ(‚$\uô ìUÕ´Uğêz›d¯vÍƒ‡¶1€›&ór :ºúY¿çù·t¹$&LUk3<Ä—HTİQ	¼W¢ÂÂx¦ê~¤	;¿<Cìú[ŒÙy›M	ò@ªAkà¨CÎU¨Iç²7AL>‰Væ–B|F8å4_:“G}$_UO;øÂõ¾Åï¿²Nk_#pá\3ÕIt#˜?µ ğÔp:~;YLeäM”"¬·¢Êx}D‡ÓıŠÆTÃIbMéòÁ/H<©$¢v¥Bœ$à
ôFca|'ÓîZ¸V•LJ³‘å3¹TIü
¾x€	I›F—øKè¡ Câ£äuİñ0”ëã7òXÅz!#üƒbr™îq;›èµ(pŸ5Mq u!9[(Öõd)ïÀ+x¹w G¶c¡jˆ¥÷3^±èÆY–ş/·1ÈÁ½TÌ ‚ŠQg¸š f(Ù¿³İ`â'å˜q*=Ò	¢9¡ê³:¸Uû©¨®jl}[oÈô›‡+ª‰ô›Ù²,Z)0š’wÆ“\!(~.²²¦J°¬¥alr£ÇôºÃ?–ƒ#D Î¡;³xZw¸ñc²HåÆù”şYX”Ã–õ6Ù&0;|ÄOt›º|EŒW7OÕ˜n?‚š;Y$gõp$´œ:¯’#˜¦j|{ã]ÖÒà™û&9÷+Cnœïß¼›DªCoËCªò`>9'å©@ÃÆ­[–«óÙ hGy£Ò¦ /œFÌ°s›8ƒ”óˆ·*ŸŸXYD´Ê>1³ØüPv®rå0RúB/rxgäæ0êÅˆaˆXØ•œ½µ`ªnˆ[©b¸køzùïHQI‚= “fí×`­vºˆzü#Ş&³œ—@¢,"ù%åÅV-*™K[EgÃºyµº»»şzû°zYYè)ó§†ñ{¢ÖPÅsÄ,a˜kŠ¼7Eî•«ÃI¶Ì¾>ÔIœ~	|¸È…#S5/Íûl5ä'¬vkYV$¾œµq 5¯º›¥q£¡'_|oê4|–Lä!§\~VèŞöd­'Ä»$IK–¼V³“qÒe©Ğ>¯ë/t«B3²‘çšO`½6ÍÛ#Õ…ñ
7‡¥ö·¬zª^à6.NÄóËÛ²ÖHÔzu¬rŠÂ`\«"4±@î«5_´/u!5|"2(»Š@6&ôÊˆ©mÜ
——¤­âõõ[˜Ğ:ª\–2¡M3…ãê›]ı¦A4æ:FnŒ£àeƒ‰ã‘ÎÛÇö,­Ê]Â×öè~ïËOãê}™gûXÁqd.~'³û Z}’ë/„s¯cğè;Ğ
æÚ	†/pïU§Hz×AW1@ìö²F”E½ĞY¸’©•¤*¹ºÁ]ZÈ>³äÖ ö¾Ré3}¬5ÂU,şÌt¶<ë¶ípF>¿Ğ›¼~Õ)Cå<º†)oL@‚ şÿÆ4$NÇoÆ3r[ÀÊu™ÅÊ¤‹RFû ½éªáÿË^Øõ„ë’e0¢CõgEjóaÆ\émOêÈAV×	Mäü$¬ì¹?z9†U4hÇ|À}¦êÛíï”å»JÜ/d·J‘g²-•{Â12É{9ë¯æC<³>|„„Pô¦&—\„_ˆÆîBFêt®XÔçÇş<o¾Ñâ³q¹b»|Ï¨éØüÁÊyÈ3àEtDÄ—{¾øƒİs™¾ÛêCÚËø·d5ÒÀÕ$En˜E*}ÏĞïH‹ äŸ›ÌóyY€¼½&ºYKÑDãOó“è¡éë 2@Š¯%^3^:0–F+	õ„ªè y¥ÍŞ%´,ËĞıà„?×‡FÀØÁóš‚›Û€6&)ğ& (;ºåu£ÌÏÈh(Ô¡tÔ‡”Ğ'vw‡RĞ{%Ê«¬J,ó/ñ4ÇZãÀRq›ÒeÓOoï›ë¶6æl¾Tb¾¼xÑ™ĞÄp‡…ù\=ÛÊa÷¿¬Öùwqd7§P*»N#ÅmÊ˜Ç¥Ü)+<£•¢Ã%$öúM¢ÃdÊN§Å4Úµ¨;½ÍÉôk1R˜”Õ‘g¾Š2œc/[ª­áÚzNâÚTAƒQ¤Öã˜~CI	îe.Fd>.ª]©<¼s×›÷[Ui{RkYÕ2ŞiÙ¯BÊ#*ß”N,Ã$2R,SĞDóUı|D¢ªØá"Ÿ±ïté`ôõèùìMŠ©ÚèÊ~•ªê½¡üáîBR%Ë®ÔgõI¹òó ¼ˆ³à?ÈÌ*Ç`sOÆÔ:êdØzÆs  ³¾«í1ÜüÂN¹?íìòV7WZM+N>8©y‹Uk†–˜‚µšÌP®ßˆâGù‰ŞOo)úÖœÿ7]Ÿ\ñáÛşåÙ1Ì3î§â‰LíŞGŸ'g})’ŒõùPZÍ½Fcqíy‚Dg|3¥UlˆkŸ¨:èˆ/,4<MöGmjJK‡ÊTl¦g¬(}æIxú<yQ»‚º1e™@1¶²)‚Š'=Â[½°³K”Ådƒ1¨7dP[Õ ì¶bù–RU\4ä:x;]¬,,¼ÿ¾õ±}~ÖêN†XN]Àakò£õvt~ö›îñòÃ¯¾zøÈÏ\Ëx~’¾J„wŠ’2-œZ„tôâ^ƒH)A®G aê„óîÁ;ÎZÀWHÃ…ûg?r%‘MÊ‚é(Ìµ]´œK1ÕBJ
ZÄ£)ÀUk\Ç#‘¥éöå¨Ïè9rœ‚×»§=¥î…\¡®­æ¹,hW¥Kõp_:V.dr€Ğ@:ï")K	\"×«¨=[&t3LL°
¶ÉÊî³î;İF¸RÜ¾õÍÓ'ÅŞâÁmü'’Æ&®¨Æ¥_û­ØZuÙkw:å2k±ƒ\BMRŸ@	  QNW1ı…½‰·;Èt%AdrtgèAîÙ–ÜUN3şÒ»ˆ8q2AòìÙD»¤f¸TšEµ&nHª}-Oú…)¾É0Qª¾Ñ½ĞÂ‚PUt|Í]`6;ÍÎ÷w¡UJğ:DEúÅåÅ±¤!ƒÖV	±'ˆ½#X/÷ªè§• ôNÁV—‘ZYïG”Õ´ÙÕjkª–ÿh–âšœşm­ü
¯Å¸:YtúZu†°llÎôÙQ»ó®qàAI<1YÄ^ *¦¶a&MØIæº»C éY¿ÎOE %Od˜¶Ş<@ÂğU ZRÙ:¬Nà´k‚÷ñ¸?å¿¥+Ø&s„?‚øB8m¼÷_)eËaÌYi/òi……œ‰ü¿æâWn±ÏØAmLPO°PJ\˜‰2}óÄ—j“F3ÉKu$;k	‘øV‹ññ
 ¦(ÉqxhkªJS–“BßÔ’×ÖŸIµª",Ÿ«¬jĞnkÎ¦àä*æùŞµTˆY^~ I¾Ğ‘eªBL‡å\EDhSt_Z j­0Éu¬™ºk3×5vÎ<V	6†„emK¸×<-N*Œù*Cá—è÷'yùM¾ŠåZ®Àû¿Y®«/nxœ5,ø‹ã..;á8.ó½\œ†3€zî…cÎ’ÆlñQŠ|”!ªÁU¹ï˜‘åg˜¥½‹{VÎÊÓvç#‰Â¡zÍ6ÓXJñ6¥ Ú³8œd²Xãº°ÁE³5„TWİ
;¢`o¨Âüàzb3¦­EéÀB'I˜B¿d¶Eò Z@>,ûE¢QCe©›Òw•810ªšÜ6ª÷À$ A¸Á}¥Õíg@`Š<cÎ Ìu—¦8”Ğ9-ì¹ÛGU>’÷Í
";,u$Ç—ùC¥BVjÓ#$²cc:
'jbƒRT×³‚Æˆ1û0}KÒg •ÆWØE]¶@^¯»ÕSoª¿aæP ÉCÂÅ¾Ğî÷_ºF¯x	x¾÷deşJØÜ³š¬ñ“Q~6SÍü”aq=^µ$ÂÄ}q¼qÉ»î¤BAyx‚£ Ò„İæÆá¹=q«Ã{/ºŞ°ä³·Is² 7öâRü©=è%QPé«¾œÛ«—N%³nàéy¾Œ:‚¢këäè/$úUXüh¼¤
î*«@qañ•oØ#Û3¿¼å±6\oäªºÀ”ø®ŠÙµñ•Ìî2ƒâ=Ôøˆ\Ø/ˆàsÓ½ƒINJÍ
ú˜í“ŒP_– ùvTñ ®±r)¶*r@ÕùàŠÛ/·WwÖ67·6·×Ÿ½^_ıŞòSÑÙ”sïœÊQ±’3Aºj%€Q)é(9¬L£Œ]¤pÿ178#‰‘ŞŸàPñÎ3M£‘	"ø:Ú=á»ˆn›:yú…ÈŸÔZÄæ®³'¼X½•$Ä»gÀ‰Ì‰O×"&PİtÍÑ ˆ6ˆĞ…Ö¿ñi‚š]&ç$YúWlñ£Å°j:ÙëŠø!z²+Ö¨’j¼0€=;ë·Ÿ›>l
qĞü³wq~ä'R¬wqÉ¸ÂnşÀ’‘<ŠRµRøä¿àòÂ#³RÄÆ<W|”¸ó*NàCn3´ßiñÃ~ïrƒvå„†RŠèÓFŸ8k•Ø3_t‘©X[<í:ÈßºNuªÎµ×cHWTVñHQ³ƒˆĞÅ³—/&ƒ
O]™nc}cÃUD¨D…–G09Iœ7‰P ½½ò=ºƒÍşr©J!A6Ë2&CimaƒòÃË“fc‘ì€Æ‰M/Ejğ6ÒwL tn„Æ¤ÍÊfpªÎ!­„¾áNJ÷‰^ ªŞ â¼H­à"É¯Øáá"ÈdŒ›ğvo„`´\ø‡GšzÄ{Z mÌæš…ª‰„.‹XÖÁ{óJ“Ï)Íõµ‹ e9;®8CEb’½U<ä­-äƒP+ëß;‚¿n!Y§ïärgóev#­Y¦—v4ªÌ·sÁ]=;‹,!§\ò.G_
Àd:é.Ä£~EÄÉœáYµÑ?ú+THCô¯~wÙ–ÏL$>Á,ù8¬ˆ„Ï¡!ÅVlV:cKãäÖ©ú'ğmV£áG7Xo	Æ¡ÜdÏ"èG£	ÒÜ]û…¸¦–úÆŠ Z&k$¸KŒ®*ïI¡ãŸ™/S*’É¦-}6B§>1-ã°-Ü)¡Sz£ùãîĞVNæİìÚ0ÃTx-äQ{A5QÛA|ÍXRòÚ"è+=şV¤Ùp³»e7{ûÀ¬lj„^À½sÉÕL<¾—J„ˆ$’È&àöÃ%cáü¯Ã'¼ÇŸrÓ—Ëğ©x!ÚÿÍêco¨74§/õÍáÒ´[µ¨–óz†æ¼ò>P(ëpÔW³ÈîñâBØÉ7êK<×K(°•9Q]¸·/ß÷<·ŞÆ²öİêëCí&ı—“dÚm_Êí®>KKèo–[üêëfnGMb€”§rc}ıyZKÊ¯Jy±ª±øÚêë×›«ß®¾^ß}ó¹}ü“âÏ¥¸XÑX|çÕêÚºŠÿ²ø2îJ4;r¼G
Ïú?¯m­¾Xİİ|i{ËKRãVıó—om­şáÍËİØ´¿,¥og¥w€ÈWı%¥ïJéßd¥_­¿^[ßŞÍËKéûRú·YéÕ(¿³º=†ÇåRúwYéÍíoëá~(¥YéÕì2ÛÜù>E Q1	=â|íå‹«YQ<Hé5i{.+ıbsûÍNmi%è|VzíåVJ­Ç¶ï*$+Yéõ?¼Yİª6.¥µíÇYéo1³Á8w¿[¤—Òë÷“¬ôŞ¬ïäLb£¼»!¥Ÿf¥‰ssuëp5P”mßS>ü}Vzk}c÷pÀ¿æ|kuíûuÔaéûÏ¤í½¬ôëÍo¿+.¥u”r3d·o_¯şqıpu-c-–~ üµ-¬½y½õçˆ@òP!ù”•şãúëİÍ5Œ‘Bí4eÛ•ò?e¥îJãRZá–{&…­ÖwÖV_­î€ëÛkë;€@\ıêû=h™Å¡Cc¾ç×_Ô•xJ´'”xJM(ñU(1šPb5”à up<%~œPb-”8™Pây(1¨/±{)ëK,/‡6n×—¸áØß¯/òè~hd»¾Äj$Ìa}‰åÅe ı­‰%€x)ñ
%„7¯¿z½¾Á}õrk}u{çpçÏÛ»«ÿŒ‚{ğj±üÔø3ÿùˆË#ùÛş³¾Ã'Ü±€_ê¿Û®õ4ä¿ñ«Ï·õß—RşäD*Ø66_0xNKaYİY°!YøËŞüìÁÓ½Åù¯f›OWVìçö[útgæé—hÌ½K„:p©ÖeÁV,é4‡˜œ·çOºˆNœ†8äF6Ä3ÅtS6rÉõ5¹­ëtMÈ‘.yØAd3hmÔ+\qZİe[vâS“ HSâŞª“
Ùõ~QšÅnàÕrP+™7K·“.@êé°[î¤«+Ÿé0â9®å[{ûİ'…g(m7ğŸú½ŒV}Yh§ĞBÇŠñ–âxo_ ˆ$+C JáaEÌq*îV‹IU’îÓ’AI6&“³ä)ÄaâÅƒK‹"“È×æ\Iâ„%À²€úÃ@ùÊZ$_1Å%äXåû®ü€%@;1ò“Î”ç°Ü*‡ZøT„×Oè)Tk¹Ù\z0ƒ‡78Eby^M¥)
8cˆGhh®ñòLz‡™Ñ²#NÆÚ¨kå²ÚÊ½«[ÙÀŸ³J„çMµ¥GIKŸT‰MTçr&ÔES x œ!-9üêS=}Û‰ıK"F;èB&H\³Ôé•9‹ĞDa~¯İ˜ÈÍH2#qC/~ßáîŸiLÅê—tu;û¨n->‚
Qí0ÔÌæÜGÕR!õø"r{È³£¶jpİö˜6X•h”ZÔÀ’ı=.^´Go[çíMlÒòNöZJ›X•Ú½şê`Ğş¸©$}f´^Ø Ğ"¬ºÙÃ©K]å’Ôd¼Õ>ÔÕc>ñ–d³d^A§´À¡8ş‹ÑIÃtƒmğVºù¥bÅã"ùÇ€\èÅ†\”é}…Ü”èGjXQã±½ş`ô=µ¶ü¥ƒ´u#däéOr‘k%•Â­õHv›^—'ÖKV¥×ç‡º^zı5nÛÀ}Œ8)í%ıPWapÌ°Ü v³Šé‡ºŠ»ìó
#ªî|\ÉÔ“ Ò6Ÿu²°’¿Uñ	ø†ì`cN&2Ô%ê@ÃİWgíò§‰?ˆ‹
ûwÏBYWhÅ^AÈ=ÛÅER;MxÂGÁ¤yRqŒçæN«´n›Šİ“VÕÈ’CCÁh@›:H~øÀÃ¼Ó¼hâù%Á…–!¬Ú‚0ˆâªœc•94z¼-Ã7ˆéHPW=…coqÕ>ï7<ÃqÀ~•*ŞAåø/‰CeYA[%f4ÀVèÏ¡à¨è\ÜÜí=/(]éa<üÃ­\¸˜7õê–¯âc²åÊËÃ—©qA›xC/t«e]YEVƒïôb½’¹6‡È² ¼‚Ø¬]¨Ô-Bc(¨à’xpEÒÅéM!·½sÉWëfú7k6ºxD”ÇáYñQÂÉ\¡ïJˆAqŒ]0°w,ÌÓèvKtÊ½³`½m ¸…:¾&;ÕÁ(÷h”ëøBÎ@RvÃÖ|­š{^\Yt‰{íYüŞĞİ0!¤Û÷ÄyŸèqkÌ¾>Y\Ã¢€ÑMøÿƒ¬#8Ñİ ZY#Á!j‹Ë²IÒå ñ^G1ÑJÒ£IJûbÖXåzïîİƒb8ÇzÎÊ
p^OÜÅŞ"jìğOá<Şf'£GGT·D5ŞÇ4±øI!ÔÈërt9èá."<É5)jK,ñ¡è®43¡³ÕÇyıÜ°Ö¢"ÚôÏ‹?¯¾Ø*°E›¸]	~}ÿ=*„–†…ååöÙ×µ¥MÄÙ†mhŸá.$|—ö¡œŠ½ïĞÜÜV¦°¸Õöşşoÿ'Oì!«¾?øx›µŸ—¤%'„¤w4Ï^±’»?Â?¿ùğè¾üguQşÃ)µÿø*Õ~ÃW$ªà²h2†²¸¼HW½ÃiLGv¼\|¸î÷èÃM-¹º4^òùCºÔRW–^mùóWÕ¦ÖÑÁxSpŒŸ'My(:©Lˆ—]µòÒ"½jègµ{Eo¨ø"«EÜ»{Ëù–êDÚ“İy.AÎ÷¸\mÙZùÁn>š§ö™?)A¯Ÿø¥=tÛ§å¼Êëlö:g—Ç`¯ M
¸\…‡YÂ°;³lO	/‡=\œ%û)`…Ê¸„Ëà–6G3l3eşŒ&#X´™Ãíá¸íå`¢(â‚ù„±D_²;íä- tlÖ”ZË£ü5%Â²A ï)Ç¡ËV¥ùaûDx[h½FŸ|â\üıûy1¾&Ú¦ıAŸh@w]İŞuZ-tóˆŒüB ØBM
ÄŞãh"dàÂóÊÿ„ÅL«”Ãè’bÂ‚8˜=MLkŞe0/ô@D5ÂšE3¾wÌÿ·ÿkåïÿö£=üú	ŸNA8ô×gV{lNTò:¥
²,nÒŒwæ6äj;#n²#pHÑòLjrt[©p\©Aù#ÃkBÄh¦;›5bnÁ¼°NZèŠĞ·ÕP4üN%‹úg0e¢ÆÊfF›"*ì‘ãå¥ˆ)>'Œ+‘ÒY°}[™úUrg¨"*<átÌE]Ö¬İ"j]õ_á˜P²nucBÑñÅŠ	kVPÒo~‰lA¾“&òé2p+®æEã7º·’$k’O¢÷¡+Vüğ>CºÄº8O:¡M­e6(60g‡ğ:ñu4i°÷N±g7JĞÙ!{)Pö5Î&ÖšÀ?ãí¬°¡†™Õq‘0ƒŒ*¸¶²iL´†E2¿È.ÑKzˆSœÙÀ‹2z…0®F-sï„»Mw w¼Ú×]@ƒl´‹Ã†%î°EÖ–ireTRÂ¨ïåê /Pcï[@;ÚÜÆ½B—Œ°Á&şã)•ÔOAqÉ¯yQ\TKWè‘¬s3<ía„.L`sÓX‘Oå"ŸTd â<õ‘…QäE3/5¯ì§@\7Š¹0²½ğë üú~ıŒ_ÒhÎü²^[óŞ×Ck>‰Ô¾ÇBqÍûšåÏšRCï¥ªWÂ‚G1Yòëw?wÂ¯[á×Oá×ãğëIøÕ¿nãWÍDzkŞ‡µıºo¶6_ó)Ie¨ùš-ÖÖ|×Åóšé:yÍç4µ æsš1!ŸÁÍ‚Ùßìü>üú¿T-çô²Ôˆšæ³…öšïéò·»×War¸ûÍ4ØV;S`r4SMeÊ«s]¸û^ç‚«Loä´i‡Tª2GTE{æeO4M¦[ÆtF.À0Zl^`>dCc=ÄËW\±À¦/„|f4ê}§çRGóöv\q1è¿bÿZ¢¦ÓzÚ–„›¢g¤
?•ıšî-Ónô:6ú4Œ)hé'\ zş³9A_ÉšÑóg|…šŒÉaÕŒİ…åOBl»ámBŸIÜ‰=ZaírM»´wÚ'§–›)º€ÇUq^¦_oqšàÑÇâÑ­£r-‡mÿØv™;š—õ5€÷›á%RªOA­yÌê°º]
œr6ìy5,~İ,ØË[2°İ„ºYü‰.1¦«”Œ­®œÆÏ‘*Cz0–°‚ˆr€€rÍ2Ã@˜÷ËùÈÁ\2‘v€32°‹1‘ò4‡M)ÕûGœŠH$¶Ë%ê5ÃGÙïİ)°† Ë‹´è$x3.áİ?#éÕÖ*OkC+4Õ×¶R…×Ë,Õ×[›HÖYİÂë»éë—[Ï™Lö¸¸—¾¶-¼¾!tN†¢.öééêŒè¶ğÚ°Ëãx|†¢¡#„Œà9áöx`Ë]´Çyµ.0è[<æu³x‰“/$nôjPÎ“œrÙÀp…Vh>)µH8JËØ„2Å4E†íñnFº!«NI$-—\TdV^võ€†pû›L¯šøGŞ@²vŞœá½ãºoŒ§ŸÅ
D–EÒØ"Ôä«Xà–¤§Šäm›„wäÀ®` Îf;ÃÙ½ò%úšÛĞ½*²‡Ø¨#¤&g­uO/û—C®]ÌÉœ'âk4Ù4U%ØO•™ôøD¹øL?yMßùê_#U’€É]‹Œö.â1ãk,>Ó—““R\»Ci4pNñ;áƒ¢úm„ÑJì[hs »s
¾Š÷ö‘°…êR6cŞí ÛİºRãÂë«ŠßX×ğ‹3{£‚FNj©­«©d<–ª±íDâô¢…3s©Ìè„rõ¼1§ Ë[0‡¢Étí“.¼¨æ59r†lÌÌãñ€,Ìèà¢Ì—L©ü¥°n³+„/ºUûòµw1l|ŠBX]XÆÒnwvÖáä†Iá:ãØk7lv+C­$ˆ”§Š¯*/Uûªø9j'›ş7§„¤\hÈ‚¬ùİI˜šëkš“l1' =Åy¨5„Èÿ1ˆScıJ#	Ü”ÆüáH9Á+†¸‘q¨Àğ½Ê„ÆşUcé¸XVTN(‹šv$]UDŠ!{S9 8õÏÚ5Veû0ıŞ©ÔDï)èœÏÂX;š	ÿÀ£ó¢“r‘Çn¤L'û¤šŠàéW„7u ‹i…æŸHqü3^*Âù'²a²9ò?)K‹‚€u”Ó§h"¹±vWªBùÀˆí÷DT)÷˜JŞ‰E†¢vjiæ€ê“æzDµAÙë¬qQê×ÍÉJ¸hA1·ÈÀª&3jàT—®DÀeÉt§6Hµ.é‹Û‘Ë>6àáù´Å’‰ô}Ä2!ÚØD¯›•CÁ@¬jövb6Póäqáy
˜èÀÌˆB…İª ÜeïˆëÉ)	|[t &2m=\YÀ”3uÎDã_b=˜üŒúeë´•8HEƒZ¡Qü8Ô·Gı><U¸Px«òO ƒn½•%Z½[cŞ†;µrE‡‹sÕløš¸(4¬Ë=yjnœ9±+™È69Öñ#—¯Lu÷é‰"ÈÂÅ³°™§ôS•(ªvÜÉ‚RùŠ2ğÛL¤j³œsé‡@ê,9w õÇ“º¤’˜EP@²WÊFg²ãéLíâ²'çI¼/‹÷Ø²Çù1ÙÌOéT«ÂZ+¤æÍ:Vm^áhµAı
dÒeÈm0%öıP™Èq%P@.'À£©å¹¨}úAJ'ê,–É&ÛÏZ<xï×v	[Klb4°]­Ø¶)}4ÕÈÍè=_:4ch—[æP„*÷Åñå9d•ÒhF8ğ=J´5î˜Œí³÷m¤–I„`Åf)ÿ·ÿ‡ThVjTï3œ£wr";ƒqèuÉGœ ÈBT~ÅíùÛğ™˜æl+ìV6¶·„·hlP÷¹ö„ÈsX§y«ğhDDpe'r%æ»²¼ĞùÚíYëÊÃoÅ‘åóS„™	
YÍ$3“÷°NL Ş˜ÅCAŠbZ¶„_5ÄZ\t¯$Z`{'Gx“Í°|Út~§Bšñ)`¶‡.¨mçzœ×¸Ì5ä#4·S%#JVÛIÓëø4m=O¡Ç9šL¤£ÖíÎ˜İÂ¦•V“\÷l‚ûù¬A5qÈ!‚+üà™dóvãvúÁ³¦²¡>”ÿpr¤Ú„P,Øã,İÔòt¨r0¿X4ÇË"ºŸVi{bøä´„pƒÇ°nĞYÖ{IŸÄ…7\º§ı„mê÷<ÁyšÚÆ¢@3g„WÇb$<‘òW‹B+ÓÀ¹âŞ"¦İêPk ¶+kËšK ³±…ºÅßÿ÷ÿÕG`Z¡bo´·àg”A4Nº EÒZHèo¬Å'“ÛóÑ!ë¸ë·:¸Ğ¦è£’F›«KL `³±ºÿ‘Úˆè_¤ˆ‘"0ã:tŠlÁš¥>j€è¢D;F[äe—ğÑp¨°Öï´‘Z¨Š@ /AIì÷†ÚR)”d˜ˆEç™ädÍ	Q
ØIìyËúc%©8HŠØÖ¼ÁÖu*ÿÉ2h©– ½Ğ.ª’#“sÁ³31Y/yÜ®åxŠ½àJöècÎp·ÀUŒ @DaÙ„±Ü0ğB—4pî±¹A…:½=×}%ô¯ ƒ‡[ ¢Ãy±/0Ê/ºK8
Ö]¥[5#ËBĞã’±Z—œX»&àC8ºàÌv¯AJµ@%~DQËÀtš%Ø_U½ÁŠ Ş3Ë¤CqWì}¢RU¥ğÕ†×¸çXùTù!j§l.40{¤ögâ?ŠÔ´gÍXƒŸ¨dÅ#øæ¹ä ÉÇªb•F}fÅëP½­®Î† jÜ‘š¡«´s2:õºÆyò«CÏ©WB,vLQıíqÅ*iÚ^Ö0qå¸·±~íˆ¯Ç™SîO²İ	iDÚ§æ´o?7>Sw.r3†’tÔñºÃ>dÛE\Ü½9®@½‚—7i‚`7ä5Ô´G»<+¬´OY9€×­<Rmiš%­«)“PIq‹w+ÓlÚ ™ù³‹õˆÿ/n»ë{;™”RÄÎ<M$'ùŸ6‚ıTD–;aˆ Ø& ´M²&HÔ” îŒ³Çjb¥l TpH%ü/pĞÑEsÒêÓ¢1KŸ­)ã‰yR›JT,Eä"íXÚ £	”ÊMÜ¨$vWGš'k+Iiâl!—[U©i}^Ø>ÃfŠcßOt‘eQf
½–Ğ&ÌûC`‚[zYÏ
¹øÉÓÔÇ77`ò*ŠA$ ÃÀø!¨Jı•.²ÌYs²ŞSv/A1^Ü„ELæ^sÅ—ï¾‡¥ì\ò€PŸì`¦t9âiE`Ç/ßÍ.}>üıßşMÙÔl,Ñ=ÙAœ—:Cí<ì'TÁu.ñÑ†ÊÓnOf.øŠ9µXğv`@"¶JÂééó7Å İï2!ÌYRSP¬lÃxvŞâè9m“¶&6@`ÀšÒÌ<9–çm…È9™ôµ,øa»ÅìLsë~wf`È´³d½«Ê\H“œ»1¢EaSğÖ˜¾_;Uâwî
À)aM—"áÌ²„"öC—Ú³3¦‰º*hB‹ófÈ—À®Åõ³	iO÷É$?î4Õ²0 Ê.¬¤ŠYp½yR BA_—¡2¸˜Xñ‘y«-j§8->–¸-ÕÂlt¿ç
ñ®_€r”!á€œR£yÂÛ"(2†ò¼¶Ó˜—œ'™`ŒœPãXßæÁµáh#l»¥›¥+P¯ËVù¡ì>â™n¬01µ@A©°·„Ë‰åğbÙ6¯¦Ààc“…˜ªÆXeÑvÿf±v2††ä²Vé›²k9­GìXj–:šÆÆ=šY‘o¡1k¤Õ xñi7BõD]+Ènœ¿@‘Ùƒ{t©·ÛAr… !QRA`å‘8œaNÆ…c•O\EMB_‰r¾ïBn‘û6¢³NEÏÒ˜íè¹j+ˆ$HŒqaIAJ‹;ÂdÜaÂ‰*9Î*Ğ&4Î{¹—…AŞŒ3Å9†4ñètñˆıƒÈÇ”ÀnŞøŞ¹qGBPuJPƒQÓ#7²ÜpÈ•‚¨*I¨q¡‘¢ª¤
¦,B9éŸV‰xS¶})†é±Èš…?¤«•óËŞ\
ĞÓ¤2Æi'2ø‡´ÒRKr‰¶ÃOmòrj)è-j+Ü4ë@ğHåÂ_ä¯LGF‰[U±™ Ğ
8¼ÚZ|‰İ ÖB? “¦ñ_nµûõç—gZ…”«£06”Åflö†¸Ry³ß¿ O+M¯:9mKÚ/&„Ë°¿}m“K­Ò-±ÌbeÙfP1F4Õ1d¨a)BL=È9yrY9}gÁ
2™9àêp¤Tó¯OL‰‡	)l*õ’4ñD1Ë¼òŒEhPGX	âJº³t2,éƒœoK•3+2göCh%T7]'£àdh9–HÅò[¨’Ãè@¤ÇÒ5Vğ¾&ª 8Æ¢ÆÊdLÊA›¡æ³IÀ§T@¦å-õËU!
Ü²‚èfgå	ì
Ô3ˆJ‰è†i¦÷ÏWäÊ*Ù€îmÂ¾©˜%Ç¦rŒZ 
Î,&9ÔŒ™P´)KP2__…´ŠVx½²¶ºgLÕ`®»â¤@qgÂGÎŸ•2²lNd–—™!OÆÒ’ï…ÌŞ'·'ü"ásP´¨u‰m•Ä‰,
€IÑÆjà_‘Ü‡lAõÉ×1«ä^`ãy‰AÏ3º‡Âüù¸û¡v~ËÑé#}¥ËòQeYıòo¢ßiªš¬ùK3,¬›iù¡gÈÇØÁ;¬ÏóZ(,$ö­X´M¦’B‘ädD’(ªöºæÌh;WÌIw¥zyÉêdÄN;Bƒid~J‡i
‰ Ô»Á6Ëìovq§rõ•­ZèI‹q
hƒK7'rC7ş<´‡G·b¼t—ıA5¾?Iê¤¸ÚV1if°7^ytW\›º3UÚZq|7*$‘Uß*¯£"ä^/ÿ®ç°h[si0â|y©-Lqú—t)pnD©ktĞ‰œğ1+ÃÀí»íc®³yüÆKQ¯(“]¶Z…÷,«IFé6ç,©dÙõ‡rlZ¶ñ Êp|"ÏË”Ø‰Îûkz Œ•„·­&%Á™@=æ™ÂŸá7æ¨¹š·“Ìc1À¡Æÿ‰?M…Ì¿¤¢Và’¢~Ì«ôÌ r?ÇÂ vc]†¦ŠÆ¦2Pa9?“‹¢§1ù¦¯rKèqûn§4AÃB-²-ü_a{}øU™_;T˜Ô_UnÓ0˜ç<èrA¨ş2ıô —±Û¬KyKØ–'Of“9},(ŒÌà¦f²†Ğaè'?‘¡RLƒ#À“Œ$öª­]_d½à¬±q¥'¢sø¥‘7VXU‰Š2CÚĞ˜PÓpá,œô’Ø+ìÇBKÖpëå_tT‰Sğ}ùÑn.{©V‰ëmMı6ã6mŠ¹­xY}ñÇöøÚøä¢İ<»D²,ñJ<¡ÉvÑ º¦y”.b‚%[FO
ŠR'#H‘SİÎl:s]eiCÊ‡a«l`ãL¼'¸åöBÕÔ	SêŒ[ğ¼…¼TnÇC³˜
%…¹%ç(oM2ÁI¦ˆÔGacÈ®Û»,…¯wtª†Éq„@„¬2§ÖœäTÁ1Í¡Ï/K‹Ë÷Æ0«j¤ÉI…“öXŸR’1¾%‰ o¡DcEìv}9±Ú’óà»;ÊÖvÃ•ş'QF7Äˆ¿ºF¦†&Õ0mò10.‰ËDNÀ
~u-ÙuØ56G:HŠˆi^Ç§Š×ñóD¯cš†šât¸BúO©ª<·àxz‚úV¹8€éş€§ji†‚Äl™Â¢'Œë@>m/nVèv@ˆ¨kØôÎz‚CKËì²†>ëiqŞ‹phQªìkóŒA6ÈPøÉJç¬ıñÛÑËÚåŞJ'…;–“ºÊÛ¬v\ùj]ì„¨pñ~€p¯tP» –Û³…DˆÂÒR%Hâ êb°pô¯jMÈ›QjÌ˜¸¢:¯á%µ¯é™ìÚKñ?¹EQ¯3ËÜè€~¾æ„Ìôf*µ@Ÿ™j9º¬2;…ƒuŸ8²¼Wº²3AU“×§•b¸KëÕØ¬ÄwH!p!N%İÛúL'7çªä:õJ%ã^:,bFuXì¼¥!·×)‡ä:N¿õ8Å÷H9Å,¬rIBDë/¶³Qÿ"ºä¸€«aîN>÷¨–òÉÇõ(úïnóİeà´åì}œ¶`	“lÖÂñT&-´p9bÑÃ:*ö<¸I“Ù”xZgP°T´cš€ô)¤½ÓÑ[ıÀÔ9ÉÊ×B²½9xy*•şb%ıBÒ=-…NŞŠ”N´Şø5§%V,^3xüÁNèÇŒ‡á*Òòå‰$²x«¶’~CŸÄ¬ô¢c,è„
 DÓC^ŠJ]ãÖßP\PK6I“¸ûÕ—>b3\8ï&ÀP–OüD5ËxT‰9š£ê{éPoÈDò¶áÈm‚ÉDİÃ[ê|—õ¾Uˆˆè1åVÓZK*Èc•Y´çT{êä/K€>©î1ò0°<Á÷•‹°yM¶œî+ã±|·Àº…¶î*INÁN:“…b›—=Ü¼Ûï€ĞŸlHlÇåTyñ^D­‘a˜3™±)+¨î&ŸÅšñú×ëÔÎâ¾ªïşZ—O¯íô‘>˜²=‘ãÊ1´şòõ‚mdç`W eÃC3°àmU(#vŠ:«ˆ‚ì¨sV1İ’Ìhnô[öxö)Ä'T +‹ÕNÌ´şªæÅd"&SjnaºÑéYÿ¨}Vü +
?HúÁëôØEœD4¼ìàœUDÏáÕÊ,±õ5×–Y¯ë­‰jkY$0&]P©¶+c(}R¢¦r@·ˆcÖw†'mOT¦ìÉš=L.'Óö#8§ ­¡?+Á–•2=ieelDê·OwFJ"ŒòÍyVPÁ\Àå¹<Y{‰¯±oŸÛXt2CŞaÿ_sW×ÕDŸ›_±¨¥»¡İ… ¥t)•RTPD$Ò<´BiIË	Q$hJ{Ï9óaûîİ„HHí>$¾c{lgü1Û'r°í#½¿!¡ÛÒ°<‘e‡5‡'«|OÒÉmúû}PŸ%4‰İÊdÊŒÊÂO°Ùà­9ËîÒŸÙ#Ã†‚‹_»:¯!	/²`.è*³xjó`GÔ×97‰¨0‘/ªÚØ:U~²ø¬ ³ZûZ_È{™BM€OñStU‡u‡W`{õ”Ú‹6µx¯^’±Å­Ylæá‡ó|\%¢g§&5ƒL™túY+ÚhéŒ¯Qµ‘±Ş[ ¹wEw5Ôiì‚BuIƒÓú6ÁP‡Ç9~TS‰•´)uZ¤ş—ıÔGw”Øö³ÍHÎPÖŒRm—ë¿®O[GáSSÕ½šQ—Ê}¡ROdªª·–wsX7şbÊYæü,"Ö¬Jo÷|ÃˆF+:/&ßôuùÂê©æ¡^¬çbÌ~ÿÏØéÜzÿù	³6_õ*°°×J©ÆèˆO÷¾&·DÖÙ~Š«÷äbé‚V™ØN»èõe]«v©D)î°P©võÄD>¹£•DÔ¡wˆ+´X/Û…÷—˜lt™w¸5sÑ¥åE˜Ré]©ùÅ†Ocø Ù
¡ ${dƒÏ½4µ¡/G¹6‘ëF¾öË
ÁÒ
{'ÿ×0—5*üÇ,âHjíİÀ#QpÇˆû‚xÎ	—ÏØ½Ïßİ¸6Æ8¤½
Xãïà@±Î·ÊÈøüà]'c­¤'Ş¾ßßtsİB´>Ö“½‚ß"ü–Á÷Çt*@§Ğó1¼{ÍfcÜõ¤µ~Ô\¿Yw„¿"#üÙ¡ !üÖàûã¿:ÍC/®P?3ï¶¨¯Ö-n¡ò”Gÿ¥µ{¤Ò½=™%*ÃW—éJ‘…tÍ‡
(•H_‡{	SÒ;é¨ïj†ú\N‡~Å}bqøUæı"CtRù‘•xš™&*ÿIØ•?Œ£„­f¨õŠ™•È ?pÚÁ+N”<á¥a‚±áj ¯.Â«•H#Z‰RK¡;WØÉûõ^
‡cGF=,–íîãææ—O!N;j”Š dLÀÔèxWÃ:jtõ/
/__ó{FD](d©Ğ—©jŸ¨›ŠÆw!ÌñX„WöÅk·íÍã¾×·–à¯
ˆFİÎù©3¶6û¾ÔUşàIß|±¢eêçŠÔš„”½ËÎD}€·, q£7ñbÉcz<A·„ù€¯
¬e_Å—MöÄáZ®-çZÚcg]Çr_Ñ±³³íÒ‘|½kCl“@œzcO½€¤CK–ª Ò_@äÌİØñÛùsß]ÌË¶%çºÂx¨8º£İ:€¸‰4Ğ.rdJQ´ &;T|tuÿ±Í×±t€Ÿ+E,¥1xÙ'X.4bÒä!öé­,œÊ*!D#<ïß RR,!‘—×ĞM»Di±ËÕ¨:Ó`±×'ê
K«‹f…s}Ô³ê:ãÊë©˜ÌæÖ#–¼:¼:ƒµ,íø‰E¢Ğ…şuÆ9‡Ë-7…ÖBC…ÕÇ ]´½hó#Y±ìK%¦Aó)Z× !¹hcÕh³jaáÒpÉàîE¼zL…ëœ*’ò"évqÜá)^83ş o¸ªÀ^ûZ]6 Î`&ã¡(Lôf¿Á›ÈˆµqmHVVïbÅiÛXS&ŸÂìkêØ>`nÖf¼ÀYSík"æ&a­OfÁÖ>Ø[AZWc~ĞU[Ø#y	ˆÙ¦ĞÃàFg4# X"êõoFL=úÎéÓ|ñ>ñ¶jñÚÛ	×‚ÒmLÙlòøhŠòÁûıÃWÎ}º7Áù¶á+7C_ÌÇL2¸9áDçÒ1ÜÅÒ=sb)£|fÅŒ;pr½4tÒD§|2Áü·?ÔŞŸ©ÓìüLMo/ƒïàöãá~› º<A-Åıõ[;ë÷ñ.á½Ÿ6ıùh*Ëf¯X¸¥y¸³ı¨'¾»hÜë#|ï%Wù-Ş.=ÿÆæıõİ-<•\Š@şò0!{O´·õd„â6ÿYQş’{“²IK)jÒ!¡@È–ŒO
mjSAôäX|…=Ùãƒ1¢`÷¢í§"9ìWL¢¸õÍë`\–Ò©	LÖwûZ=e™È˜ƒÁo38Ty?eiäœåğ>\Åğ§ a85ˆ‚„p:tĞS†	ÓÉ¨$7#'‚„ğ:#„‹2‘AÂièâI$Wº"3‚„œü‰»{ü)HØëR;	‚Â?2"(ÈøU°ncHEOs'‰•|TéáÎX/<İ˜\›¼ÕÈƒ[Î¸	3ùF4F!9ƒòAf
8˜Ágß/dCtäd°Ê¼şÈœt23š9ÉFZÎ³Ğó_(ë{(—Óÿ~½ò™	!Üœ‰ èÈÜtĞ I%rSĞ%åQ÷Š´MÕ¢ZA›ÂWT-xH@"Á	şúÚmß ÄÙ˜‰F4¦z|+%Ñâh0¥ŸAs\ùöN«€*&àV¿HGKÏ¸ÃåÌG<'êŸ6î¶oå‚şÖ-æh`€- )£¿¬¤ZÂšYhK‘u+¬ñƒwVşŞ¢ĞxuTMoÛ0İÙ¿‚ë¡¶‘À^‡nHZä0	Ğa‡ì2 E¡/¶äIrÓaİ)ÙNÜvğ!ıH>>>iSé\¼Ï_å9üøğå3 1Ú€¬„µìœk®òÜ:!÷úMQéC&uÿjÑºR+›Ï.ßÍæ³Ë(Ï£¸µÖ™Rºø:Š¢¢U’APhS·äÊ	>Hl8:*ÔéRøÜ‡„Äñj´VÜñ¿!#3(,•{|„8iÕ^éƒ‚K¹!@Y@òúˆ¯…Ù§„p­Q}Á7†eJÔ˜@ÇcBDJg1LN8pM¦h|Ôà/÷ä9)áŒã ™O©J…¾H9ïê%„ÔU[«s:R§œŸ?ebUÙ4ØixJâVİª˜wøõXæFÏ$sÑ`Ç-²=–ıö’ ;íÉkÌ$­ÛÉ<ägZé´¡°_{&EU%nWÚÔ/€ß‚Š¤×¨°Ôî¶½èVÌ”}œ;’-øçÜrê5†O¡•ÅĞ–(Ş(Yµ[ö)yœ¶l¯7?Q:jÄFê‰7d\3ü;£{“P­;£k¡¶ğUoñÓš2?ÉóÓOÃ'
12 qôçÀë¸ZMáf	o&¾øZÂ”ğ~’ÁŠtÜ0sš´£c}S¯L˜i‰ÂCĞ=IÓ,DùĞtfå­z%(»tPĞ6‘5F;í~7|¿ye2IKqØI3|§ş“I—Åàª2Bñ1
fN¯éQw”3Ü"},İıü|†ıñò~î„>‘ŒÍÍk½m+Ìğ¡ÑÆÙçôşK¦ŒxµV]o7ìóıŠ-
äN©tJR lE‚ºjUûPE@İñ¤s(òJòäÿ{gIŞI²U=?vggf—^)³¢Wß}óí_}9ï¯Z=—zGÚÔ2Ë²¼w’œ·måóË,›?—NµÚÏêÖ‰•’86«ŒvFÉçsß	K£øY•ö­•EŞ¸|rv…]wÂ"èÑî°6œÙ‹­
!Î”%ïÁÿüI +Õ‘–÷4€)ßØu¿•Úß2\[ü•uÖ¬/²üÎÍf>Å²¨ë÷©:lyÛËì‘"bÉˆÂùl—O)ŸÍvÒºÖhüà˜¢òøqAù¸ŒÅôıâÀ`YÎ;Q}kYŞ9\”éÌ?f«b¶ÊlqÑ§l	&å?´®SbOÒZcµšÒAÚBùXÖ€Ìycå{.-Ùæsªege%¼¬©ĞÆƒ:Yã»h¼´t/|kvX0½ïzà
i&LÇ“ë;DpNÖSZáaJz©öãıÆØˆÌ·«Vµ~Ø»Xª7³ÀM$v(utùÛíí/WË%KVKçYIèÈJëğ¤Ú3J2PÒ[Q« ã._nÌ=ZbÁØ'XşÏišV=‰ş#ÖÈğ#@\ï›Ùk’º‚f5İ·~¾éíÍÏ!—FéUæß‡ŸµlD¯Pv>K:~®nŠ;tsúûÀŸ©…›^¯V˜¡‚©Ób+§‘œV¯§T	¥Veôj*Î’OÓb±`fâ.œÊScÍrÖ­Îà´&F\µéõ.ïİèt^Åd¨`æ2,.òZxkŒĞŠpiˆN)FÙõn“¶.C¤0<Î‡”º>‰xf¥ï-Z8UXè^©)½í›FÚ“¸IéÍó\¯‹`|™@NÈ™ñ—¤ÂxæÑD˜å%“ğï”†›ÙC–Ç¹E³À©¯OÀ‡–˜bğ`<ÄB˜Ù8.°ì~Çtä²PáğPî¸€Êê¤ÛÕõÍÕõ¯£x 7¾Je¸Yä\A1éu ¯Ó rAıDÁAHù±õÅ«™(òiÌ@Qb¯?{{FàğéS:`”[Xü°<(ÁC˜e§//£(¼ãí>É’†ê‚~ZŞ\Çş*"‘QÉÈüÙhU…ªM`ò `u%MCË½öâãU€“rçeKŒ¹Ùû¼À~
KeDıF©ˆäØùµ©3İŒç¥KzÀèŒ®‹aFÜüÖ$6x'ôjxHJ´õÚoB³¾˜À°áp‚ƒÏ_zyt)–òîÅĞÄlş¦¤1}xµ\y,syòÈk2-?‚sjyhÃ¡QÒû;Ú€3Ÿ±/?âO:õ±ãGi†ğOlHlÚ§î$:øóÖYP	íµŠ:ˆQf]«ò’zİ6ûbhô8©r<Rqé®ø^°Vİo»t…±gşÁÖ-†x+)JMU°°d040075UHOÍÓMÎHMÎÎÉ,.ÑË*fXğ4æêKV×1Óƒ&ÕÇVn{
U›“™W‚ªøŠÙŠ£aL®7°ÔHv&I|>ÙÙ	 Â£%Òx­[isG’İÏú%)bDî .JÃã1E‰cz(KkJc;8
u£Q ZltcúàaÇü÷}/³ªŠİØ‡h]ÙYy¾<8O²¹¿œLGÿñÔœ¬Ãte“lõèÑq’˜4+ÃybM$¦ÌL¹³Í³/6*ÍMŒ‡æÖ,²¨ÚØ´´§úÈ2NìğÑ£kk–Y¾	Kƒsó°À#Yj.ÿfíÖ„Íû>í¬Ër[íï_á›P_>†Q¶Ù·éşx8öw÷…é¢ËC¸XÛÜ
o—v¦e™¿Û¼ˆ³4NWáÂn®m>ÌòÕ~±µÑşõ„4‡ër“ì‚ÓGOŸšËÙ/údf2šŒ£Ù`|€ÏŸšãÅÂ.Ì‡»-^æ¢¹1öv›å¼tX˜à.Ü$Ã’ßùå—`ˆ§ßà}w†ŸÉãk>–mK0V”áÖæå„X®M–Ç«8Ğ^‰(se·%)—k‹‡pÇGÆìÖv^§å°&‰‡Ã\…›mby'²®*%óÁE´†€†ö¶´ébg7®(ïÂd	ÄJF³|asj1‚®L¶4Q–.“8*¾ŞWCÓ%siÂ=3ß3‘ù´ëI_ò|¼ÀgÔ;…%„¬Ây´ğ’¢´!ìai‚h.‚– ™FĞÄôŞ]NÖ6º2—›x•‡¨YUñÂ~ÚÑìçëéç2û|=n»4[ÊmaË0N
Ú£	i¸¹¯`"Ş¼©²Wî³#ó¤J‹piŸ˜2\Ao)ö—UñmÁû ·+Aık•.ì2N-.À6Ù5®Œ÷_~)´~Š‘4v¹‚ş«¹zš-lîßv×À#®ÂªÍan•|@>ÿ30»bh>BwA’A¦à”?áÍüßEµÙàË‹şfGk±g
„j"-3¿ƒ°–a•”|£šöë7§ÇÏ?|¾8>}óùâäû7oqKxc÷ëÓççÍ×pÇå©
J¤û´§ãøiŞæl,‚:J»Sˆáî‰*`¶°¨6Uè÷Şú¨0>¥æ%4?Ã»ò;5ù0¹	ï
³	·[ÕNğ~txœç!€1Qb<÷“]TImQÒPh©ûI<‡¬á0&xæ}˜CØiµ™#æ˜0Š`è|Jÿõøí¹'wŸÍN0O¦3¹ÍÇ›0Ù£ŒFYıU•øĞã£ÉTİò}rŠ2ç‹¼.Aœñõùn¥QÕêã¸‚znşYe%¢WpDK¸ä?ŸøÏÿ¼ìmÄˆs³¶).Ù¢€ÀöÌÓÙ‹ş=8xA²ç°nÑz”%Õ&ÅËİ9µ:0jÄ÷‘qç—£_}@¼"BBZ¿ r(©_³&E†Èh$ÒFô‡é—.…ì‚étB>Nà)¦Hch°4j%’{ôÂ…ŠàŸgØrŒ¨(/-4æÊûâî‰~`ó8Lâß(°¶[ã×´‚3)wI‚4¨W‡'¨Q2rÃºÖyÑÖa\ˆ6¥”è‹qç­’‚â*Ş¥×xõâÏe^YµØ7±~iâÒnŠ¯¸@¬w"¡ª(³F¯¢s1`}Çc	Oâî´µ¦à1ü¦ö1õÇßğ³oa`öùÿBOID‚İ›ŒF“£æ-ÅyIa€F‹xJ²“ƒC—¦|†•Ÿ&n¾ Gî@ú›lQ%¶Ø5Eµeº%î!4ˆ}@Şr¡†Ùÿ;‡#kª•x/÷Ìé”Ìgñª’ğì<(,säŞ¢¼K,¹z)?yÙz—|W™ßÍ³Ç)ãgGæ™İlË»gæ_ş]­WAõHÖıï²#ÑŸGª~È'ÁšõÁ‹Qëe¹İ&adóšîNoâ$”èµ¨ù.Şı8Ô;ÄË;õáùDu| F#`úå` ‡®òóÆ+ä1 ä€¥.ã[°6=<p::oã@Zç”°'ˆÈ›FpÏÓˆC¼â¡D'‹j<°îşò¤	#Âì6CDF@)	 ³<'ŞÔHZ³‰onÁ>İl Od™ˆÏ7^©€%¸„¤÷öæaş)Øòå:Ç“–ôàÁĞW+œ!òÓP©j
a¢Îúù3¾²økĞòwF¢Ïs@Èu.ØXcªÇéñóµû“OØóxnø¥ ’àçPS;«< ˆ q¥€¹ˆqœ©–ßyáò;ãikP×uœUErT Gji–Â"ŠcÕû&¼ƒ-\#BEpP$3ÁK!æ0}V×k®‘|rœFpb…r7Y~åu‚÷‰İˆ+@ Å5qÁ`@ŞkÔ(Rpæß9O2À8Mq‡hM“› —ZKyk‘àäùÂş³‚ì¾?#² aÔÑ>ÄM@ŸÂ©ØO‡c`{)Gƒñd0z!òÂFU—wx¹İfEKÉÃcoñ­ÀKHÉ	hdù
0ÜEòºÙÁ×
EB5†•7z;Œ“É={¡ø kßÁ4ĞÚVå^Ğüuˆ0‚ëQ£ğ^JæäìÈ,P@˜¬*p%@ğû¥0°B>zm¯* îçò÷\Xb¤	ş,yÁ(@‚£5ˆÄ¦û‘¶V„ÎÁãoşòm@[‚µL ´C0	Ó
ìİVWñ2†+Ä­ÿ0¸DDÓ9„
- Ä·ó;‚P’{“oêá&fQÄBÄ¢&7Ğ­Ê†Ò	…èõPöÁ)ªÖ6Ä¯Ú¿d7Ò:îÿCÛ´ÏaM}­ÂWM“Ñ}Ãòo5ËøöHµ}î¼šÁ™ÅµÂ®Ô¡bN\Q˜•$,˜Agh~Dì’V´¢&UãÎ(™!ø|ÁĞvÌ%ä1N‘L“çÂ'¤-ARÒL@ğ™øS}H:Ï2 6{mgÏ™¶º-Q£Vë–Ì.W?H™¤ˆçZ¤œÇŒ£çƒÑynÔ„ ¸:
.B”p
v$ø†îúu}Ï7L`ÆÙ¥ÜØ!©ı^²¬°ÛdD¦1£ÜØè¾¿¶·<‹ˆV©]¡bEøE‚Cõ˜K¸|	«Y¬kßñ‹Áèå`¬öÔ~Kàÿ¦5U%B†Ù€¯è“*+ röğšºÊ.€¥¤ “é‹±ü+ ã5y%§#ğ,DÍ¿íÃäÖ™âœ§ÛFğ²v7ğŒÿ;’y“’à+”±¬Ş<Â'—.I!{2½@tm^ÿ‹¯8h©îeífíW´p#º.&8±Hb7;}RGò½%:.:Ghao))Ü¨DfŒmuúè,Ş?,«#¦f¸¦'‰ÚÂl+ÛgÎ×ÀìÁ}yPâ6?"?×L\¢.¥Ì",Öblò^¶6oòpËWÌ¦§Í+êçÍäbUèé ƒGÄgñ*¤1·è5	 @HÓ7«”¼@¦&\™N[aã°¸	F]Ò¿?‰å‚Á%ŠV`vo×ìZ Tz`ù(#¬PndRFñßlyèFÙqU( øhx{{«ØC. i Ã¶[J±xĞë‹x%•¨pÔç=é°m”uÆobo‘öĞ
Câ¶G¦Ú2‘¢)”İ·#ÀVq‚F@CÏG'ˆ¢¦×€;bNÖ9‹&œæ ï¢Æ:ä(¹Åè‡ˆïéÎç¨ …9¬ÚÚş«Cg<±ót2›¢%‚ìq%İÏïPeE ÛB /j—y>zÄÀ½ËxßfÉİ&Ë·èìnÄò¤ØˆƒZô7YzeS’o»	- …ì$1ÒQg!@²½a©å‚ä¬Cr’|´Úâùy­4Äÿ°ıÕÛ\¸2c¯&4ÛX@öä°•ÿŸ·nÎ6n7×©ÿÁ§	&`¡KÜ¡îÌ+ q­…rôi¥Á?Ôy£¯Ó<¸ŠÑ\yãf< K“”3î}'z¾– 3ƒêVÁÖùÎiÌì`xà˜Æ
T½™½ÖÌ¦ŞØò*Z°ã’Y ¥,](-f‹I;rÔ‘JŞ6zÙ± ‚ö`Ê·H
l{!@Iğ‚3¼¡ù •N9ÕÍ-ô/*4ÂkÏ9¨c“ºWêƒ­@~‡à„Àå @8+V‹xğğ‘ÙÄ¡’Ô„Ì&RjáWım’²<L²®Ôâ€5.i8ªàTò+dDì:d Beæ¢©ˆÊÛM=ÔˆÚO|Ğ[]›V”™n¾W[šS¶èµØG™&ÂÇXJjÿ”E¸èq›¨(‚}J×ë
RÑÒ”ˆc¢ÍµÚ¡¯´ÌM˜shâôìët?—ĞÙ¥-ÛÚ­{#	HÚÙ„(wïÀüÉ¯ªå’ö¤BW åê³ásgèôsHÅ²‹Ì.B¹DP+¦Ç±EÃƒ5'N /0ôe½íÌj_ÒWèÁG@‡M~åÚKNl[Ì¼MÉgt¥ôU\"Lƒ…xˆÁ(B,q,h,Š‘³W"ş
8H6™`†F{Aìfn¾»†Î‚VC°:bj×æÏÃğ‡
W­¨f+ÙyÃœ«®ÙkcÅà&_IæîhÊ—À2¨r4Hø$?ë©ÎcP¬¶²nKAˆ2Óïb…# ë«sØu†ñc±²j¢öİ¼»êëµÂ¸÷z‚KDÜÈj§‹fÿ_Ù½=¦dM¶öˆaÎt‘’NO÷ÏŞtnê‘¨m0¹?xR£ı#ÄXç0ÀÍ)s¨u£—,ıY=©mQèyEk!ík?Ì`Uz…şæ¦líÜ {7œ[0ËäÈŞc®AÈ’cRˆ °Ô;ÁæÃ‚Áö^ZÆÃ’Ô¤ÏMÃ¤#¿|A—¯…^Fğ©»qdí™œ’™à³"COĞ·v0÷B“†–èš’¢ƒ>èkÃ éo`!U<Ì5::° ÿ²©Ò<{ğJZ¨´›.øÈÅZõBS–ƒÙ×Ñå¨‘îˆÖ
š±j–ÔqV=Url©Î|è Ã²˜XøÖ¼z÷–}*{e+ÿM†/êHÇü§şóo“4?
&EÚöÉ>ÄÏ¿?»øğî§_1Ü4ƒoÍÉ÷Ç?şõÍù»¿â÷:ğMZ±õA¬J`Ÿ–~Kúøá(‰5c«ÊÃ$Q;¨Oşñq4OgÓñsrüÁœŸĞk¼Ñ,˜Ø}PH@zãqœ~NhUóN˜ÔÑ‰nÕ¨av–%×KÊËÔ!sT:P«÷Ø°ä[ŒŞ—êçhØ
’@CàjS#!ˆspT7‘’@†GlÖ
ìl¿@hÁÚFyeioÄ_8CïXO!r]gİ0Ö¹îc™4H«ì³]ÍÅ¢&5¶U´_ºBD¶N¤}S5N	(Îbh†ÓBÄç«HÚì±Š½½çø²¿#ä!L§BßÊ´*©0¨ñ¬†óvä¿Ê"ÚÌÆŠ'tü¾Û2QŸTP½"©tq®j?nKÑ¡Øíd°Ôf/ŞÖAÒÔb$°*:„ÎÔÀí¾¶Ó©‹å:Á~æ‚¯{?Lêj<"Ì:AöÇë0˜Ø›¡ùÍvAÿévc¶Õ<‰QÇKŒoò6N\hSë¢iƒ²¦¡¦<®à99?{0Â2	ì³äB4%R^”T‡ŸÒ"‡cN_¶bvÓGì«ÈıšÀ4Ü&·ìéRâYVHK×ãc&f$½9{œÛg(Û‡w›äZ×*§nÁ($N¤–Vè<Áè`n˜$a	†Y`Î\3ÇïÏÜvÆbhÎ–æ.«´êºF²Ş¡<¢šî¿ÀpyÇ~³Ÿ­ ÷ (JCå;°œé,QÏÑ_Ù?SpÉqÊaêâ­I„MÒá”µ•ß¸$ıYÄç$ØÍ×(ÄœÃ¶Ö‚‹i‚©a`Ş*Šæ,ÈW¨y5#×ğÌ«jE—k‘Q]Acˆ™yª'µgfù¹†Ó@ÆØmjKGÉ	º_õy v¤™*…Ë{wî‚ñ÷ÚÚÂ¡p!9¦Jë¥íw	¬pÃ2F&&Gã¹ĞğGAKv«$Yï|kÆ£ÉŒşØtU®w¥Ú¾šw;¹šk4Fş“³>0KËú)1?ÂÅ¶µQsŞü}'"K\ïNŠ­'f@÷îíÑøSs„ŒvF×¦¢ƒ¤~‚ÓÂãs© v‡ÒchW~à‚/öRºJˆIÅÖŸ#èéö0sÌ1ÅåŞ‰¿}İvVE¹ÚOæu _zÎáï0ÀÁ@*¼¿°é·„Ï0şå°ŞƒaŸ?¿®ÄçÏRÓ|¸&à,ş:M9v± ÎÇLÊ
÷®6·Xbº	?6Úéñ¹NP.ên§6äfI¬Áíj½—>´b$=Ÿ•„Ş×Y	)è˜"i"ƒ¶0é´5–ğæGŠ¾zQŠ]ÏzMñòR7¸4Gg, k©1ä2Nn8ª¶âú,#¬E¡<u'Ù¨¤îánÀ ‰¯ Ú}ÁåÇ¥u0!kgpŞòÕèjgı/´·£‹VXƒ8å&WÅv‚Óã³óöR–4¬&à;rá·Áv%ÒŸ  Á'ï~ª·ÈÄT'1k–_î•.õµ}6å–BP¯¥¹4„Ğú³ö.xb¢	Úœ²Ì¯nAgóA³ì‘hçË*›@,_¢B¸&8ÂÒ	~<;Ç!'¸2=`Â|ÁQË!óÕh+©¾ù‡^{]µø	"^q’dl‹¸±µYğåÿë+‰Ê2”v_5.S&[–øSM+¬œØzOÕAaÅËF¾:ñ –¢b!Ğ\væ*dc½ùßl‹¢ïQpàK2/<5ãV¼W?usú€C­H—ŸD¿ÿ2¬ç[Ìh^R’#³æz¨i ‰_¶­¤mqÄÅÅubÚ²i|šåÕC{:Ùõ»H’[Tëˆ•`rŠ^´¤ÔrÊšv#÷S\b–Ş5†Á‹,y´H0¢Bö:E‰Lø1€ÑaÄ%mÚ´£ÑÉgLrüNŠD‰øu1¢±lİú(ÑU[U.‡.¨»Pë¥E^¸æ®İø÷áeõbà!|±7n“õÍÅÁà‚¿Š¹²Z÷o<À4(8ÎdÍŒ™O—Øƒf`æT+bïÀqBØÂ‡¬ÛwŞã/x‚Ó8İ_¨'?¼€W7Ç>&·%€½À(qßp¢ƒÍ°zëïç2…KùH Ôá‹u#æıºBçšpücşß\àßÜ ¦ğ]fI˜¾0D`‘CFš ôæ’7ğF¥7¸ßDî¸zgşç4ãÿê²s¶\b	Î› œ|1Â„_ùüä`ˆ6”_î$Q}]Àş,c6ÊMv¨Â×"ÒB‘ÿ#ql·Ş€’W$
„º¤À·»•N	8°Úz}ZÌüü-4¬Ú|.çœ:Kèu‹ÕC "çm0íº5Á &uËgêÂÅr`Ù_ïf9Ö²as$ ‘“4}c[iª½7ì‘ QM®@'¶Ì0÷«V+,Êd¬qèÙ`~m“-?qş®÷@Á^b·ãç‰şú5f6@èµÕ½Dôì(}¤ÀE†êÃÙ+ÂÿYÖS°y	Ÿ‰p	Œ]ºc‰Ÿ9éXÕ“VXVÑÊ:5òÔ¨Ö6Š›`{€¹ñ­ĞF^¾1Â!åı*[Í	øAŸøàì Qg[N:aíÁ*ù|õÌC.bè\—í*ŠkúqåA÷Œ ‡ªÅìÁL§mn}SnU0?A&‚Xà¢–%mé3Ê“'MÆ~mc_
ÁÅºs&#€ú¯
IÙÄvË°mV|`Vøõ¬ÈOT"÷èòæúU3xÖÖ€¡®‰©&€qd<ê 4—f}g¸—±ğDö¸}$	L}á?\œû0ğ)%ë€«‹Ş$'²
Øyä 3Lª~B†qn,;Ğ	¾×~ë¹qû€Áá?õú®àZ5‘Ø]Ç„Ü¢]#Kğ„õı˜Ãx1ÒTªiŒJRuËêàûG@ıvh°Ëğë{$kÂ¹ü¨=$&Ùïk©GÿÄD‚¢¨«Î,Úÿò\sRŞZoqıŒVq;¸pHŠ$Â‡¯58Èêz›\ªbíÇa•K”‘L.9ëP’[ •XĞw{š^×˜KÈDF(‹t,ãN(õyKuo<­rê\Ê+¦61\×|ÂÅ+Ñ	®ğà1<úÑ	¬KñòïïD‡˜®£u£Xû¤]QùøûÃÅğ„™¦ÆÇÊ·UáEECÀ!)^J6Ùm\râ‡ªB²×
¼²¾Uc(ÄWu.XFZ@Óç‘KµÅMX5joj‡\çKôáüJçe÷µG†¢Qëî¾.D!Ìb¦Ôb¯ãP÷ ŞXş@³8‹U³óÍìª•|ZZo¥zÙû	ôTú®Šr`ÅııŞ‘ñLø‡[Å{áºvFd4å/ÿH€@©İó
8úˆ‹– Ò—N„øßş4xÄFo>`e†Ş…f×Sl+8+|àƒş4Ü]pÖÑè}‚^Ç‡ŞôåCÅYá£¿y`5RÙpæÁUÉ~Åæ£PÀIòÀEÈ~°èÈ%¸œØ—ÀTà$9àêa_jW8©úZvùbS\íëË
'•ƒ¾BÄ2ã@„Èİº~`³Mà$9à¢[_ÊN*¾`³L8Àv	pÑ¬X8©úÁ1$î…õå@	'•ƒ¾†tà´€­2%ĞWÎ@H	ôÕÖœDÜ‚ê',5	œ$ÜqêK@Õˆ“J ¯gN3øµ7ªFœTúª‘ùšÁ}¦jä÷ô•:N*}Õˆ¤à85â×`AE¸tÍ}•~WÀV‰# pÉ¤/µDœ¤¸3Ò—€Z"N*¾–8q› J ¯%bûAd BJ ¯%zÄBJ ¯%z¸ãĞN°ÃV5MÙAbß~Zğ@'y…ş0‡Õ… %%Àvm?Ğ8IØ.íK@e€“J Ÿ¨µYòk/x‚2“.å×Ş(9©úÉ€)ş„ä×`väÀhUı¼‘'˜ä¤èç<H-!%ĞÏyPµ BJ Ÿ%’€jA,Q~í-DÕ‚X"	ô³D*ÑË Z_{qÀ”œTıdÀƒ”Rı,‘)!¤úÉ€`fB.å×^2à	f&9©úe&¤/!%ĞÏx¾ „”@?_àAÚRı|iBH	ô³¤!%ĞÏxv „”@_;Ğä*„H ¿ö´†Ar É•?ú^¬TIàÿv×S*ö1Bİ—cşÙh9xKNÄ0DYç½1 ‚â*ív{ÆÂŸ‘cÜˆ#°*Õ“J¯¸×š'(ïæ¯òmä$Ê¢'RNâ»ZQÈj¸úåNCÚ„¨-ië¢N1(MÑ²fÙ·àÕ$6h¼Gö}Ï[@#K÷$#VjÍ¡û¼VÊå•{ı€Õmf[½Q<£B\Nz^œò¯ñ’„æã½P{	Oop0¥ÔK¾	•|L8~)õWi2höq’Û©;³3 ¹·åß\vx+)JMU07a040031QHL.ÉÌÏÓ«ÌÍaø´Ií@È´ïºjSZ:…&Æ3t«½ªÊÌKI­ĞË*f¸³âÈ¡ï/&Ÿ÷Vß¹á ±š`^/ ôÿ ÖxuUMoÜ6íY¿b …»±6ˆ‹h€l×‰Ø¨a»íÁ0 J­˜å’I­½…úq(ĞC[ßR ¹åùä'ôwµŞâÃZ"9Ã7oŞ•Æ•ôì›¯¿úl‹Î¼kt|atGoîé{Ëù™Âkò—F…@Çô9íõÑÍTÔÎÒEô*òd‘e¡:ÂÉ¼Ñ>Dê¼{ÍU¤²×&’ò®·5ÅÖ3So+7ÃşLm'8©m¥;Ãáy–=Óh„¤Ï¸)]ØÏUi˜´ºf$aòÜ¹„Õºˆu¬i_çòqAÑ9Æ£Q¶+¹.*¯»h©î½$Ú!Õ×:®k‰±qyûÀû¥Ä^â¦óÃ½ïNiáú”Â³ª4	) È‚ë}ÅäŠ¾­$Èò<Ï²­-úøîŸ?èDÏYhN”\Dûe{ÆMëRAj5åšZöÀX.¨æ 'vL”=üû}KB›áÈo~ùøîşW¬ ô!CZ|ûU©lí,2¡¢šökÁ"`î?Ğ±m¼
@ZÅ¬œjPqîĞZGwt©Â”î²;Ô‘şVX!Aƒ“•jgjÜsf”¥}ªZ®¦F£ûÛE‡¥¼Ü/ÔÌĞÃïÓx½;ÕÅ’z•h?Iä¥G}I{URXthRtyÔÕ”täÄ`E‡a‡«pûnŞ‚Ù,ûÕÒ\+BEİŠU»q¤|ÍÂKá{›ƒw¶ycÔdÚ‚ntl©QÚĞbí=!ã&`bó ÍˆŞW¡¥U]šIút
+¹=F	D•ŞMÙ¢373€›±ê:
3,SDÒM©¯wôB[eôÏLótM¢BÛšojyMP	\ˆoaa«<í_‡b‡
Ë7ùòœÔ¶Iö©šrƒ/ë-ÖM‘¨„ePÖºXAƒºîhÕ§WÊBfT:pJ(Ä;®·aL£¤)/LHî’û7üğáı††Ar)‡Wf[™k4â[®ú¤‡œ§»F£1ı+³Ñ¥ÔÏfñ<Ëioît=`;¡gŒ?ÜxIş‚aqü‡ÀT,o5¦íVOÚÜğœ]9œ¬]Š^S¶ÄĞ["M2ˆ0N"KàÎSŸ˜LÔ±bávÙP9)NúÉ²ÄÇ”š’A~Óì›&ç9&¡;Xùª}e¨s*o i“òû?é/èc3@\0¼x]ĞÑ³ŞcOƒÙ×ÏEÆWÅ§Ë¿Şşäš¾œ!k¾–î»:¹YÙùêÃ¢¸Ş˜–Ù!iğåiÇÄ2FKLI8sºKˆ›<_oo¼¥xÚ5ÍƒC“ß‹ñŒ£‚iœ-0^mäÛ¥¯ŠÁ(À3<J®ƒ“cºñ<æŒˆÊ¸JÈ²q²¦Òü’±±¡ø·ïéÈİHÿEx'bğñ”‰|ŞÛÍğDH‰zÆÃ¢(¤’lÏ.eÿ±"³5x“]s¢0†÷Ú_Ápë¢µS:ÓñWkÑÖÖ‹îˆä#$AÅÿû†X?¦ÓígŞ“¼ïÉ37Î\éÎhÿøS“$9	”ï%™AÊäŸ•gŞzÆğf)o¶„N`^„R.0R@¡aà­ZåÆoóî±âµ7]ˆaêÃÔ¯‰ƒUJÄUöûª«YHÒA|•5_æÃßIæ1¤ B«Ï!›ó˜rSm¨ºx„¸ÊgÍâô«ˆ€1Lï5@RFJ5ÅIDÕŒ ³©¦œKE8©í/naÊ "!++;€¶ŞTîêÆ"‡®ÛÛãWãÑ©/ÀícÓ t˜!èŒ÷^Ÿ™Ã‰ÇƒAi"½±j´Á¬÷Òq=+ï¯´éëV·"sYÏ›škuP«»)È¨õôğpIåyŞ‰·xVz0äiÉ‚,­¦=ÂûÚôWÌè°9îo2ûğäÈ>*EøüŸØï–Ô˜d»%°­™İ.çe×o8nôF3³ŞëÀK˜Œ‚ñv½{B·­àf®lôÜày>íN/IŞ~ˆ8‘wØbã˜ß'6Î¯áşk9¯M~?®Õi;Ï¨Ü°ú7NL9»h™÷NdÔˆ~Úlît¨j¤†ıvxUÁJÃ@†=ç)~)H{ØÄVÔ¢</Rè&™$K7»afÓÒ›¾ƒàûõILbzıçŸïc&µ>ÅÕÍõÙK«Ÿßñ‡/4ìK&ÖÙ†8º=W
÷mğªmr(GºG\šPµi²ó¼)¬ßIò;TYEÙÆ	ñ¾¶Pê.uº\"…w¬°œB(c
¢¶Ä¦Ø#óumBÖ.G§'ãğ¸8mÌğdûšÍ•Íe«9GM\RŞæl¬=	{€*¬.‘÷yÏo,õüñ:N$cÓI¸ujpÕXªõäè{1[R…a{kÓî`ªH³è?°ÁK…q&ïàÌ½£#âõÿ…!AWK}¨†k.ğFœ‘Åx1Çôrı ş‡ÚxUQKNÃ0dıNñ0¡Aº@Bı Uj…@j#AvUNòÚR;Š¶¨í¸—ã$8¨°³gægüâ\Åx{swrvTºb!’kŒ¹Î@“AŸ*……(hÁE0NÆæuDÃç‡q4`µÒ_ó*7NJQxµŠÁdÿñ+2<å†Ş®Vœ·uvh×`ûU+É f3ôÈ¼Æ›á|­î’L!ûúü@g</‰§ïH[¡f½ú`°ÓÃ€QU’= ÉV*Å«ínğŞuB†ışÓK8… ²¦ëZÒ•¸®Á”XØ–‰ÂQØÅ‘cÂMfİL&46*LiæÓPêì.lsBÿñ²¡xe2U6ÌÒ†O”\ˆ%VšÊ¶ä+Âı¾©]É7©6ògÌ¶†ac6woğ¢ÈéH!Ã—Úİà ®H•’Ûéï¦Şeâ™ÒÖ~=|šE›½x+)JMU01d01 …’ÌälİäŒÔäìœÌâ†­w˜wrÏ
^±ÿÛÌI&&
š÷÷  —¯0x]RÏOÃ ö¼¿â¥‡y±l]œ.LôbbŒw£	¥oJ ›6fÿ»(Îxƒ÷>¾_m«LW›ÕÙ÷ Ò|Àê*îzËÇê"N;ôÂI¤Ñqy÷ø Ø¨ƒ‡„sxk\ ³;†Ñç>"„e®:?ñ¬Ø’5yúã§q'úR$M¡dZÑ1+”[á+w“}E£„¥­¯èøšŒ\&Çå{÷Yo+şû¿'"%ÛÅ‰HIšê ôÏ)XMæ3•Ck¼Æq«M‡‚/
a†äö¢^,9‘ëÑè•Ôr54èÓ\ÛÜ^CÚÎç Gƒ;^BC=ò>*àø&p4Eß¡®óìÂ bãôE÷hQw¨…LMLÎn[Ş¢ZdcõÔ<9}»fM3E&£Ìª}/uíGøW-÷¾¶ÎXt!³¦wKvY|gŞ×'¾.7¿?ÉPî„mÖ,ŠGû³ãìÙ.ÃJThis is a test content
{
  "devDependencies": {
    "js-yaml": "^4.1.0"
  }
}
# ----------------------------------------------
# bootstrap-plan-b2.sh
# ----------------------------------------------
set -euo pipefail
mkdir -p docs scripts bin .github/workflows .github/actions/tick-checklist
cat > docs/plan-b2.checklist.md <<"EOF"
# Plan Bâ—.2 â€” progress tracker
<!-- Auto-updated by .github/workflows/update-checklist.yml -->
## Patches
- [ ] P1 secrets-verify committed and green in CI
- [ ] P2 Fly cold-start guard merged
## Drills
- [ ] Green-flag drill completed (`./scripts/run-green-flag.sh`)
- [ ] Live-fire rollback rehearsal completed
## Definition of Done
- [ ] Secrets-verify passes on both Fly & Vercel (ID 10)
EOF

cat > scripts/stopwatch.sh <<"EOF"
#!/usr/bin/env bash
set -euo pipefail
CMD=${1:-start}; TMP=/tmp/plan_b_stopwatch
[[ "$CMD" == start ]] && { date -u +%s > "$TMP"; echo "Stopwatch started."; exit; }
[[ "$CMD" == check ]] || { echo "Usage: $0 {start|check}"; exit 1; }
[[ -f "$TMP" ]] || { echo "::error::Stopwatch not started."; exit 1; }
START=$(cat "$TMP"); NOW=$(date -u +%s); DUR=$((NOW-START)); echo "Elapsed ${DUR}s"
(( DUR > 7200 )) && { echo "::error::>2 h buffer blown"; exit 1; }
EOF
chmod +x scripts/stopwatch.sh

cat > scripts/run-green-flag.sh <<"EOF"
#!/usr/bin/env bash
set -euo pipefail
pnpm run smoke:fork
pnpm run smoke:amoy
curl -fsS --max-time 5 https://demo.vercel.app/api/ping
curl -fsS --max-time 5 https://operator.fly.dev/healthz
EOF
chmod +x scripts/run-green-flag.sh

cat > bin/lint-checklist.js <<"EOF"
// simple duplicate checker
#!/usr/bin/env node
const fs = require('fs');
const md = fs.readFileSync(process.argv[2]||'docs/plan-b2.checklist.md','utf8').split('\n');
const dupe = md.filter(l=>/^-\s\[\s\]/.test(l)).map(l=>l.slice(6).trim())
  .filter((v,i,a)=>a.indexOf(v)!==i);
if(dupe.length){ console.error('Duplicates:',dupe); process.exit(1); }
console.log('Checklist OK, unchecked:', md.filter(l=>/^-\s\[\s\]/.test(l)).length);
EOF
chmod +x bin/lint-checklist.js

cat > .github/workflows/ci-status.yml <<"EOF"
name: CI Status
on: [push, pull_request]
jobs:
  progress:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: {node-version: 20}
      - run: npm i -g pnpm
      - run: ./scripts/run-green-flag.sh
      - uses: ./.github/actions/tick-checklist
        with:
          checklist-path: docs/plan-b2.checklist.md
          items: |
            P1 secrets-verify committed and green in CI
            Green-flag drill completed (`./scripts/run-green-flag.sh`)
      - uses: peter-evans/create-pull-request@v6
        with:
          branch: progress-bot/${{ github.run_id }}
          delete-branch: true
          title: "chore(progress): auto-update checklist"
          commit-message: "chore(progress): auto-tick items"
EOF

mkdir -p .github/actions/tick-checklist
cat > .github/actions/tick-checklist/action.yml <<"EOF"
name: Tick Checklist
inputs:
  checklist-path: {required: true}
  items: {required: true}
runs:
  using: node20
  main: index.js
EOF

cat > .github/actions/tick-checklist/index.js <<"EOF"
const fs = require('fs'); const core = require('@actions/core');
const path = core.getInput('checklist-path'); const targets = core.getInput('items').split('\n').filter(Boolean);
const lines = fs.readFileSync(path,'utf8').split('\n'); let dirty=false;
lines.forEach((l,i)=>targets.forEach(t=>{ if(l.trim()==`- [ ] ${t}`){lines[i]=l.replace('- [ ]','- [x]'); dirty=true;} }));
dirty && fs.writeFileSync(path,lines.join('\n'));
EOF
echo ".DS_Store\nnode_modules" > .gitignore
git init && git add . && git commit -m "feat: scaffold Plan Bâ—.2 launch kit"
echo "Repo ready â†’ push to GitHub when youâ€™re set."
# ----------------------------------------------

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).


## [4.1.0] - 2021-04-15
### Added
- Types are now exported as `yaml.types.XXX`.
- Every type now has `options` property with original arguments kept as they were
  (see `yaml.types.int.options` as an example).

### Changed
- `Schema.extend()` now keeps old type order in case of conflicts
  (e.g. Schema.extend([ a, b, c ]).extend([ b, a, d ]) is now ordered as `abcd` instead of `cbad`).


## [4.0.0] - 2021-01-03
### Changed
- Check [migration guide](migrate_v3_to_v4.md) to see details for all breaking changes.
- Breaking: "unsafe" tags `!!js/function`, `!!js/regexp`, `!!js/undefined` are
  moved to [js-yaml-js-types](https://github.com/nodeca/js-yaml-js-types) package.
- Breaking: removed `safe*` functions. Use `load`, `loadAll`, `dump`
  instead which are all now safe by default.
- `yaml.DEFAULT_SAFE_SCHEMA` and `yaml.DEFAULT_FULL_SCHEMA` are removed, use
  `yaml.DEFAULT_SCHEMA` instead.
- `yaml.Schema.create(schema, tags)` is removed, use `schema.extend(tags)` instead.
- `!!binary` now always mapped to `Uint8Array` on load.
- Reduced nesting of `/lib` folder.
- Parse numbers according to YAML 1.2 instead of YAML 1.1 (`01234` is now decimal,
  `0o1234` is octal, `1:23` is parsed as string instead of base60).
- `dump()` no longer quotes `:`, `[`, `]`, `(`, `)` except when necessary, #470, #557.
- Line and column in exceptions are now formatted as `(X:Y)` instead of
  `at line X, column Y` (also present in compact format), #332.
- Code snippet created in exceptions now contains multiple lines with line numbers.
- `dump()` now serializes `undefined` as `null` in collections and removes keys with
  `undefined` in mappings, #571.
- `dump()` with `skipInvalid=true` now serializes invalid items in collections as null.
- Custom tags starting with `!` are now dumped as `!tag` instead of `!<!tag>`, #576.
- Custom tags starting with `tag:yaml.org,2002:` are now shorthanded using `!!`, #258.

### Added
- Added `.mjs` (es modules) support.
- Added `quotingType` and `forceQuotes` options for dumper to configure
  string literal style, #290, #529.
- Added `styles: { '!!null': 'empty' }` option for dumper
  (serializes `{ foo: null }` as "`foo: `"), #570.
- Added `replacer` option (similar to option in JSON.stringify), #339.
- Custom `Tag` can now handle all tags or multiple tags with the same prefix, #385.

### Fixed
- Astral characters are no longer encoded by `dump()`, #587.
- "duplicate mapping key" exception now points at the correct column, #452.
- Extra commas in flow collections (e.g. `[foo,,bar]`) now throw an exception
  instead of producing null, #321.
- `__proto__` key no longer overrides object prototype, #164.
- Removed `bower.json`.
- Tags are now url-decoded in `load()` and url-encoded in `dump()`
  (previously usage of custom non-ascii tags may have led to invalid YAML that can't be parsed).
- Anchors now work correctly with empty nodes, #301.
- Fix incorrect parsing of invalid block mapping syntax, #418.
- Throw an error if block sequence/mapping indent contains a tab, #80.


## [3.14.1] - 2020-12-07
### Security
- Fix possible code execution in (already unsafe) `.load()` (in &anchor).


## [3.14.0] - 2020-05-22
### Changed
- Support `safe/loadAll(input, options)` variant of call.
- CI: drop outdated nodejs versions.
- Dev deps bump.

### Fixed
- Quote `=` in plain scalars #519.
- Check the node type for `!<?>` tag in case user manually specifies it.
- Verify that there are no null-bytes in input.
- Fix wrong quote position when writing condensed flow, #526.


## [3.13.1] - 2019-04-05
### Security
- Fix possible code execution in (already unsafe) `.load()`, #480.


## [3.13.0] - 2019-03-20
### Security
- Security fix: `safeLoad()` can hang when arrays with nested refs
  used as key. Now throws exception for nested arrays. #475.


## [3.12.2] - 2019-02-26
### Fixed
- Fix `noArrayIndent` option for root level, #468.


## [3.12.1] - 2019-01-05
### Added
- Added `noArrayIndent` option, #432.


## [3.12.0] - 2018-06-02
### Changed
- Support arrow functions without a block statement, #421.


## [3.11.0] - 2018-03-05
### Added
- Add arrow functions suport for `!!js/function`.

### Fixed
- Fix dump in bin/octal/hex formats for negative integers, #399.


## [3.10.0] - 2017-09-10
### Fixed
- Fix `condenseFlow` output (quote keys for sure, instead of spaces), #371, #370.
- Dump astrals as codepoints instead of surrogate pair, #368.


## [3.9.1] - 2017-07-08
### Fixed
- Ensure stack is present for custom errors in node 7.+, #351.


## [3.9.0] - 2017-07-08
### Added
- Add `condenseFlow` option (to create pretty URL query params), #346.

### Fixed
- Support array return from safeLoadAll/loadAll, #350.


## [3.8.4] - 2017-05-08
### Fixed
- Dumper: prevent space after dash for arrays that wrap, #343.


## [3.8.3] - 2017-04-05
### Fixed
- Should not allow numbers to begin and end with underscore, #335.


## [3.8.2] - 2017-03-02
### Fixed
- Fix `!!float 123` (integers) parse, #333.
- Don't allow leading zeros in floats (except 0, 0.xxx).
- Allow positive exponent without sign in floats.


## [3.8.1] - 2017-02-07
### Changed
- Maintenance: update browserified build.


## [3.8.0] - 2017-02-07
### Fixed
- Fix reported position for `duplicated mapping key` errors.
  Now points to block start instead of block end.
  (#243, thanks to @shockey).


## [3.7.0] - 2016-11-12
### Added
- Support polymorphism for tags (#300, thanks to @monken).

### Fixed
- Fix parsing of quotes followed by newlines (#304, thanks to @dplepage).


## [3.6.1] - 2016-05-11
### Fixed
- Fix output cut on a pipe, #286.


## [3.6.0] - 2016-04-16
### Fixed
- Dumper rewrite, fix multiple bugs with trailing `\n`.
  Big thanks to @aepsilon!
- Loader: fix leading/trailing newlines in block scalars, @aepsilon.


## [3.5.5] - 2016-03-17
### Fixed
- Date parse fix: don't allow dates with on digit in month and day, #268.


## [3.5.4] - 2016-03-09
### Added
- `noCompatMode` for dumper, to disable quoting YAML 1.1 values.


## [3.5.3] - 2016-02-11
### Changed
- Maintenance release.


## [3.5.2] - 2016-01-11
### Changed
- Maintenance: missed comma in bower config.


## [3.5.1] - 2016-01-11
### Changed
- Removed `inherit` dependency, #239.
- Better browserify workaround for esprima load.
- Demo rewrite.


## [3.5.0] - 2016-01-10
### Fixed
- Dumper. Fold strings only, #217.
- Dumper. `norefs` option, to clone linked objects, #229.
- Loader. Throw a warning for duplicate keys, #166.
- Improved browserify support (mark `esprima` & `Buffer` excluded).


## [3.4.6] - 2015-11-26
### Changed
- Use standalone `inherit` to keep browserified files clear.


## [3.4.5] - 2015-11-23
### Added
- Added `lineWidth` option to dumper.


## [3.4.4] - 2015-11-21
### Fixed
- Fixed floats dump (missed dot for scientific format), #220.
- Allow non-printable characters inside quoted scalars, #192.


## [3.4.3] - 2015-10-10
### Changed
- Maintenance release - deps bump (esprima, argparse).


## [3.4.2] - 2015-09-09
### Fixed
- Fixed serialization of duplicated entries in sequences, #205.
  Thanks to @vogelsgesang.


## [3.4.1] - 2015-09-05
### Fixed
- Fixed stacktrace handling in generated errors, for browsers (FF/IE).


## [3.4.0] - 2015-08-23
### Changed
- Don't throw on warnings anymore. Use `onWarning` option to catch.
- Throw error on unknown tags (was warning before).
- Reworked internals of error class.

### Fixed
- Fixed multiline keys dump, #197. Thanks to @tcr.
- Fixed heading line breaks in some scalars (regression).


## [3.3.1] - 2015-05-13
### Added
- Added `.sortKeys` dumper option, thanks to @rjmunro.

### Fixed
- Fixed astral characters support, #191.


## [3.3.0] - 2015-04-26
### Changed
- Significantly improved long strings formatting in dumper, thanks to @isaacs.
- Strip BOM if exists.


## [3.2.7] - 2015-02-19
### Changed
- Maintenance release.
- Updated dependencies.
- HISTORY.md -> CHANGELOG.md


## [3.2.6] - 2015-02-07
### Fixed
- Fixed encoding of UTF-16 surrogate pairs. (e.g. "\U0001F431" CAT FACE).
- Fixed demo dates dump (#113, thanks to @Hypercubed).


## [3.2.5] - 2014-12-28
### Fixed
- Fixed resolving of all built-in types on empty nodes.
- Fixed invalid warning on empty lines within quoted scalars and flow collections.
- Fixed bug: Tag on an empty node didn't resolve in some cases.


## [3.2.4] - 2014-12-19
### Fixed
- Fixed resolving of !!null tag on an empty node.


## [3.2.3] - 2014-11-08
### Fixed
- Implemented dumping of objects with circular and cross references.
- Partially fixed aliasing of constructed objects. (see issue #141 for details)


## [3.2.2] - 2014-09-07
### Fixed
- Fixed infinite loop on unindented block scalars.
- Rewritten base64 encode/decode in binary type, to keep code licence clear.


## [3.2.1] - 2014-08-24
### Fixed
- Nothig new. Just fix npm publish error.


## [3.2.0] - 2014-08-24
### Added
- Added input piping support to CLI.

### Fixed
- Fixed typo, that could cause hand on initial indent (#139).


## [3.1.0] - 2014-07-07
### Changed
- 1.5x-2x speed boost.
- Removed deprecated `require('xxx.yml')` support.
- Significant code cleanup and refactoring.
- Internal API changed. If you used custom types - see updated examples.
  Others are not affected.
- Even if the input string has no trailing line break character,
  it will be parsed as if it has one.
- Added benchmark scripts.
- Moved bower files to /dist folder
- Bugfixes.


## [3.0.2] - 2014-02-27
### Fixed
- Fixed bug: "constructor" string parsed as `null`.


## [3.0.1] - 2013-12-22
### Fixed
- Fixed parsing of literal scalars. (issue #108)
- Prevented adding unnecessary spaces in object dumps. (issue #68)
- Fixed dumping of objects with very long (> 1024 in length) keys.


## [3.0.0] - 2013-12-16
### Changed
- Refactored code. Changed API for custom types.
- Removed output colors in CLI, dump json by default.
- Removed big dependencies from browser version (esprima, buffer). Load `esprima` manually, if `!!js/function` needed. `!!bin` now returns Array in browser
- AMD support.
- Don't quote dumped strings because of `-` & `?` (if not first char).
- __Deprecated__ loading yaml files via `require()`, as not recommended
  behaviour for node.


## [2.1.3] - 2013-10-16
### Fixed
- Fix wrong loading of empty block scalars.


## [2.1.2] - 2013-10-07
### Fixed
- Fix unwanted line breaks in folded scalars.


## [2.1.1] - 2013-10-02
### Fixed
- Dumper now respects deprecated booleans syntax from YAML 1.0/1.1
- Fixed reader bug in JSON-like sequences/mappings.


## [2.1.0] - 2013-06-05
### Added
- Add standard YAML schemas: Failsafe (`FAILSAFE_SCHEMA`),
  JSON (`JSON_SCHEMA`) and Core (`CORE_SCHEMA`).
- Add `skipInvalid` dumper option.

### Changed
- Rename `DEFAULT_SCHEMA` to `DEFAULT_FULL_SCHEMA`
  and `SAFE_SCHEMA` to `DEFAULT_SAFE_SCHEMA`.
- Use `safeLoad` for `require` extension.

### Fixed
- Bug fix: export `NIL` constant from the public interface.


## [2.0.5] - 2013-04-26
### Security
- Close security issue in !!js/function constructor.
  Big thanks to @nealpoole for security audit.


## [2.0.4] - 2013-04-08
### Changed
- Updated .npmignore to reduce package size


## [2.0.3] - 2013-02-26
### Fixed
- Fixed dumping of empty arrays ans objects. ([] and {} instead of null)


## [2.0.2] - 2013-02-15
### Fixed
- Fixed input validation: tabs are printable characters.


## [2.0.1] - 2013-02-09
### Fixed
- Fixed error, when options not passed to function cass


## [2.0.0] - 2013-02-09
### Changed
- Full rewrite. New architecture. Fast one-stage parsing.
- Changed custom types API.
- Added YAML dumper.


## [1.0.3] - 2012-11-05
### Fixed
- Fixed utf-8 files loading.


## [1.0.2] - 2012-08-02
### Fixed
- Pull out hand-written shims. Use ES5-Shims for old browsers support. See #44.
- Fix timstamps incorectly parsed in local time when no time part specified.


## [1.0.1] - 2012-07-07
### Fixed
- Fixes `TypeError: 'undefined' is not an object` under Safari. Thanks Phuong.
- Fix timestamps incorrectly parsed in local time. Thanks @caolan. Closes #46.


## [1.0.0] - 2012-07-01
### Changed
- `y`, `yes`, `n`, `no`, `on`, `off` are not converted to Booleans anymore.
  Fixes #42.
- `require(filename)` now returns a single document and throws an Error if
  file contains more than one document.
- CLI was merged back from js-yaml.bin


## [0.3.7] - 2012-02-28
### Fixed
- Fix export of `addConstructor()`. Closes #39.


## [0.3.6] - 2012-02-22
### Changed
- Removed AMD parts - too buggy to use. Need help to rewrite from scratch

### Fixed
- Removed YUI compressor warning (renamed `double` variable). Closes #40.


## [0.3.5] - 2012-01-10
### Fixed
- Workagound for .npmignore fuckup under windows. Thanks to airportyh.


## [0.3.4] - 2011-12-24
### Fixed
- Fixes str[] for oldIEs support.
- Adds better has change support for browserified demo.
- improves compact output of Error. Closes #33.


## [0.3.3] - 2011-12-20
### Added
- adds `compact` stringification of Errors.

### Changed
- jsyaml executable moved to separate module.


## [0.3.2] - 2011-12-16
### Added
- Added jsyaml executable.
- Added !!js/function support. Closes #12.

### Fixed
- Fixes ug with block style scalars. Closes #26.
- All sources are passing JSLint now.
- Fixes bug in Safari. Closes #28.
- Fixes bug in Opers. Closes #29.
- Improves browser support. Closes #20.


## [0.3.1] - 2011-11-18
### Added
- Added AMD support for browserified version.
- Added permalinks for online demo YAML snippets. Now we have YPaste service, lol.
- Added !!js/regexp and !!js/undefined types. Partially solves #12.

### Changed
- Wrapped browserified js-yaml into closure.

### Fixed
- Fixed the resolvement of non-specific tags. Closes #17.
- Fixed !!set mapping.
- Fixed month parse in dates. Closes #19.


## [0.3.0] - 2011-11-09
### Added
- Added browserified version. Closes #13.
- Added live demo of browserified version.
- Ported some of the PyYAML tests. See #14.

### Fixed
- Removed JS.Class dependency. Closes #3.
- Fixed timestamp bug when fraction was given.


## [0.2.2] - 2011-11-06
### Fixed
- Fixed crash on docs without ---. Closes #8.
- Fixed multiline string parse
- Fixed tests/comments for using array as key


## [0.2.1] - 2011-11-02
### Fixed
- Fixed short file read (<4k). Closes #9.


## [0.2.0] - 2011-11-02
### Changed
- First public release


[4.1.0]: https://github.com/nodeca/js-yaml/compare/4.0.0...4.1.0
[4.0.0]: https://github.com/nodeca/js-yaml/compare/3.14.0...4.0.0
[3.14.0]: https://github.com/nodeca/js-yaml/compare/3.13.1...3.14.0
[3.13.1]: https://github.com/nodeca/js-yaml/compare/3.13.0...3.13.1
[3.13.0]: https://github.com/nodeca/js-yaml/compare/3.12.2...3.13.0
[3.12.2]: https://github.com/nodeca/js-yaml/compare/3.12.1...3.12.2
[3.12.1]: https://github.com/nodeca/js-yaml/compare/3.12.0...3.12.1
[3.12.0]: https://github.com/nodeca/js-yaml/compare/3.11.0...3.12.0
[3.11.0]: https://github.com/nodeca/js-yaml/compare/3.10.0...3.11.0
[3.10.0]: https://github.com/nodeca/js-yaml/compare/3.9.1...3.10.0
[3.9.1]: https://github.com/nodeca/js-yaml/compare/3.9.0...3.9.1
[3.9.0]: https://github.com/nodeca/js-yaml/compare/3.8.4...3.9.0
[3.8.4]: https://github.com/nodeca/js-yaml/compare/3.8.3...3.8.4
[3.8.3]: https://github.com/nodeca/js-yaml/compare/3.8.2...3.8.3
[3.8.2]: https://github.com/nodeca/js-yaml/compare/3.8.1...3.8.2
[3.8.1]: https://github.com/nodeca/js-yaml/compare/3.8.0...3.8.1
[3.8.0]: https://github.com/nodeca/js-yaml/compare/3.7.0...3.8.0
[3.7.0]: https://github.com/nodeca/js-yaml/compare/3.6.1...3.7.0
[3.6.1]: https://github.com/nodeca/js-yaml/compare/3.6.0...3.6.1
[3.6.0]: https://github.com/nodeca/js-yaml/compare/3.5.5...3.6.0
[3.5.5]: https://github.com/nodeca/js-yaml/compare/3.5.4...3.5.5
[3.5.4]: https://github.com/nodeca/js-yaml/compare/3.5.3...3.5.4
[3.5.3]: https://github.com/nodeca/js-yaml/compare/3.5.2...3.5.3
[3.5.2]: https://github.com/nodeca/js-yaml/compare/3.5.1...3.5.2
[3.5.1]: https://github.com/nodeca/js-yaml/compare/3.5.0...3.5.1
[3.5.0]: https://github.com/nodeca/js-yaml/compare/3.4.6...3.5.0
[3.4.6]: https://github.com/nodeca/js-yaml/compare/3.4.5...3.4.6
[3.4.5]: https://github.com/nodeca/js-yaml/compare/3.4.4...3.4.5
[3.4.4]: https://github.com/nodeca/js-yaml/compare/3.4.3...3.4.4
[3.4.3]: https://github.com/nodeca/js-yaml/compare/3.4.2...3.4.3
[3.4.2]: https://github.com/nodeca/js-yaml/compare/3.4.1...3.4.2
[3.4.1]: https://github.com/nodeca/js-yaml/compare/3.4.0...3.4.1
[3.4.0]: https://github.com/nodeca/js-yaml/compare/3.3.1...3.4.0
[3.3.1]: https://github.com/nodeca/js-yaml/compare/3.3.0...3.3.1
[3.3.0]: https://github.com/nodeca/js-yaml/compare/3.2.7...3.3.0
[3.2.7]: https://github.com/nodeca/js-yaml/compare/3.2.6...3.2.7
[3.2.6]: https://github.com/nodeca/js-yaml/compare/3.2.5...3.2.6
[3.2.5]: https://github.com/nodeca/js-yaml/compare/3.2.4...3.2.5
[3.2.4]: https://github.com/nodeca/js-yaml/compare/3.2.3...3.2.4
[3.2.3]: https://github.com/nodeca/js-yaml/compare/3.2.2...3.2.3
[3.2.2]: https://github.com/nodeca/js-yaml/compare/3.2.1...3.2.2
[3.2.1]: https://github.com/nodeca/js-yaml/compare/3.2.0...3.2.1
[3.2.0]: https://github.com/nodeca/js-yaml/compare/3.1.0...3.2.0
[3.1.0]: https://github.com/nodeca/js-yaml/compare/3.0.2...3.1.0
[3.0.2]: https://github.com/nodeca/js-yaml/compare/3.0.1...3.0.2
[3.0.1]: https://github.com/nodeca/js-yaml/compare/3.0.0...3.0.1
[3.0.0]: https://github.com/nodeca/js-yaml/compare/2.1.3...3.0.0
[2.1.3]: https://github.com/nodeca/js-yaml/compare/2.1.2...2.1.3
[2.1.2]: https://github.com/nodeca/js-yaml/compare/2.1.1...2.1.2
[2.1.1]: https://github.com/nodeca/js-yaml/compare/2.1.0...2.1.1
[2.1.0]: https://github.com/nodeca/js-yaml/compare/2.0.5...2.1.0
[2.0.5]: https://github.com/nodeca/js-yaml/compare/2.0.4...2.0.5
[2.0.4]: https://github.com/nodeca/js-yaml/compare/2.0.3...2.0.4
[2.0.3]: https://github.com/nodeca/js-yaml/compare/2.0.2...2.0.3
[2.0.2]: https://github.com/nodeca/js-yaml/compare/2.0.1...2.0.2
[2.0.1]: https://github.com/nodeca/js-yaml/compare/2.0.0...2.0.1
[2.0.0]: https://github.com/nodeca/js-yaml/compare/1.0.3...2.0.0
[1.0.3]: https://github.com/nodeca/js-yaml/compare/1.0.2...1.0.3
[1.0.2]: https://github.com/nodeca/js-yaml/compare/1.0.1...1.0.2
[1.0.1]: https://github.com/nodeca/js-yaml/compare/1.0.0...1.0.1
[1.0.0]: https://github.com/nodeca/js-yaml/compare/0.3.7...1.0.0
[0.3.7]: https://github.com/nodeca/js-yaml/compare/0.3.6...0.3.7
[0.3.6]: https://github.com/nodeca/js-yaml/compare/0.3.5...0.3.6
[0.3.5]: https://github.com/nodeca/js-yaml/compare/0.3.4...0.3.5
[0.3.4]: https://github.com/nodeca/js-yaml/compare/0.3.3...0.3.4
[0.3.3]: https://github.com/nodeca/js-yaml/compare/0.3.2...0.3.3
[0.3.2]: https://github.com/nodeca/js-yaml/compare/0.3.1...0.3.2
[0.3.1]: https://github.com/nodeca/js-yaml/compare/0.3.0...0.3.1
[0.3.0]: https://github.com/nodeca/js-yaml/compare/0.2.2...0.3.0
[0.2.2]: https://github.com/nodeca/js-yaml/compare/0.2.1...0.2.2
[0.2.1]: https://github.com/nodeca/js-yaml/compare/0.2.0...0.2.1
[0.2.0]: https://github.com/nodeca/js-yaml/releases/tag/0.2.0
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).jsyaml={})}(this,(function(e){"use strict";function t(e){return null==e}var n={isNothing:t,isObject:function(e){return"object"==typeof e&&null!==e},toArray:function(e){return Array.isArray(e)?e:t(e)?[]:[e]},repeat:function(e,t){var n,i="";for(n=0;n<t;n+=1)i+=e;return i},isNegativeZero:function(e){return 0===e&&Number.NEGATIVE_INFINITY===1/e},extend:function(e,t){var n,i,r,o;if(t)for(n=0,i=(o=Object.keys(t)).length;n<i;n+=1)e[r=o[n]]=t[r];return e}};function i(e,t){var n="",i=e.reason||"(unknown reason)";return e.mark?(e.mark.name&&(n+='in "'+e.mark.name+'" '),n+="("+(e.mark.line+1)+":"+(e.mark.column+1)+")",!t&&e.mark.snippet&&(n+="\n\n"+e.mark.snippet),i+" "+n):i}function r(e,t){Error.call(this),this.name="YAMLException",this.reason=e,this.mark=t,this.message=i(this,!1),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack||""}r.prototype=Object.create(Error.prototype),r.prototype.constructor=r,r.prototype.toString=function(e){return this.name+": "+i(this,e)};var o=r;function a(e,t,n,i,r){var o="",a="",l=Math.floor(r/2)-1;return i-t>l&&(t=i-l+(o=" ... ").length),n-i>l&&(n=i+l-(a=" ...").length),{str:o+e.slice(t,n).replace(/\t/g,"â†’")+a,pos:i-t+o.length}}function l(e,t){return n.repeat(" ",t-e.length)+e}var c=function(e,t){if(t=Object.create(t||null),!e.buffer)return null;t.maxLength||(t.maxLength=79),"number"!=typeof t.indent&&(t.indent=1),"number"!=typeof t.linesBefore&&(t.linesBefore=3),"number"!=typeof t.linesAfter&&(t.linesAfter=2);for(var i,r=/\r?\n|\r|\0/g,o=[0],c=[],s=-1;i=r.exec(e.buffer);)c.push(i.index),o.push(i.index+i[0].length),e.position<=i.index&&s<0&&(s=o.length-2);s<0&&(s=o.length-1);var u,p,f="",d=Math.min(e.line+t.linesAfter,c.length).toString().length,h=t.maxLength-(t.indent+d+3);for(u=1;u<=t.linesBefore&&!(s-u<0);u++)p=a(e.buffer,o[s-u],c[s-u],e.position-(o[s]-o[s-u]),h),f=n.repeat(" ",t.indent)+l((e.line-u+1).toString(),d)+" | "+p.str+"\n"+f;for(p=a(e.buffer,o[s],c[s],e.position,h),f+=n.repeat(" ",t.indent)+l((e.line+1).toString(),d)+" | "+p.str+"\n",f+=n.repeat("-",t.indent+d+3+p.pos)+"^\n",u=1;u<=t.linesAfter&&!(s+u>=c.length);u++)p=a(e.buffer,o[s+u],c[s+u],e.position-(o[s]-o[s+u]),h),f+=n.repeat(" ",t.indent)+l((e.line+u+1).toString(),d)+" | "+p.str+"\n";return f.replace(/\n$/,"")},s=["kind","multi","resolve","construct","instanceOf","predicate","represent","representName","defaultStyle","styleAliases"],u=["scalar","sequence","mapping"];var p=function(e,t){if(t=t||{},Object.keys(t).forEach((function(t){if(-1===s.indexOf(t))throw new o('Unknown option "'+t+'" is met in definition of "'+e+'" YAML type.')})),this.options=t,this.tag=e,this.kind=t.kind||null,this.resolve=t.resolve||function(){return!0},this.construct=t.construct||function(e){return e},this.instanceOf=t.instanceOf||null,this.predicate=t.predicate||null,this.represent=t.represent||null,this.representName=t.representName||null,this.defaultStyle=t.defaultStyle||null,this.multi=t.multi||!1,this.styleAliases=function(e){var t={};return null!==e&&Object.keys(e).forEach((function(n){e[n].forEach((function(e){t[String(e)]=n}))})),t}(t.styleAliases||null),-1===u.indexOf(this.kind))throw new o('Unknown kind "'+this.kind+'" is specified for "'+e+'" YAML type.')};function f(e,t){var n=[];return e[t].forEach((function(e){var t=n.length;n.forEach((function(n,i){n.tag===e.tag&&n.kind===e.kind&&n.multi===e.multi&&(t=i)})),n[t]=e})),n}function d(e){return this.extend(e)}d.prototype.extend=function(e){var t=[],n=[];if(e instanceof p)n.push(e);else if(Array.isArray(e))n=n.concat(e);else{if(!e||!Array.isArray(e.implicit)&&!Array.isArray(e.explicit))throw new o("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");e.implicit&&(t=t.concat(e.implicit)),e.explicit&&(n=n.concat(e.explicit))}t.forEach((function(e){if(!(e instanceof p))throw new o("Specified list of YAML types (or a single Type object) contains a non-Type object.");if(e.loadKind&&"scalar"!==e.loadKind)throw new o("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");if(e.multi)throw new o("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.")})),n.forEach((function(e){if(!(e instanceof p))throw new o("Specified list of YAML types (or a single Type object) contains a non-Type object.")}));var i=Object.create(d.prototype);return i.implicit=(this.implicit||[]).concat(t),i.explicit=(this.explicit||[]).concat(n),i.compiledImplicit=f(i,"implicit"),i.compiledExplicit=f(i,"explicit"),i.compiledTypeMap=function(){var e,t,n={scalar:{},sequence:{},mapping:{},fallback:{},multi:{scalar:[],sequence:[],mapping:[],fallback:[]}};function i(e){e.multi?(n.multi[e.kind].push(e),n.multi.fallback.push(e)):n[e.kind][e.tag]=n.fallback[e.tag]=e}for(e=0,t=arguments.length;e<t;e+=1)arguments[e].forEach(i);return n}(i.compiledImplicit,i.compiledExplicit),i};var h=d,g=new p("tag:yaml.org,2002:str",{kind:"scalar",construct:function(e){return null!==e?e:""}}),m=new p("tag:yaml.org,2002:seq",{kind:"sequence",construct:function(e){return null!==e?e:[]}}),y=new p("tag:yaml.org,2002:map",{kind:"mapping",construct:function(e){return null!==e?e:{}}}),b=new h({explicit:[g,m,y]});var A=new p("tag:yaml.org,2002:null",{kind:"scalar",resolve:function(e){if(null===e)return!0;var t=e.length;return 1===t&&"~"===e||4===t&&("null"===e||"Null"===e||"NULL"===e)},construct:function(){return null},predicate:function(e){return null===e},represent:{canonical:function(){return"~"},lowercase:function(){return"null"},uppercase:function(){return"NULL"},camelcase:function(){return"Null"},empty:function(){return""}},defaultStyle:"lowercase"});var v=new p("tag:yaml.org,2002:bool",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t=e.length;return 4===t&&("true"===e||"True"===e||"TRUE"===e)||5===t&&("false"===e||"False"===e||"FALSE"===e)},construct:function(e){return"true"===e||"True"===e||"TRUE"===e},predicate:function(e){return"[object Boolean]"===Object.prototype.toString.call(e)},represent:{lowercase:function(e){return e?"true":"false"},uppercase:function(e){return e?"TRUE":"FALSE"},camelcase:function(e){return e?"True":"False"}},defaultStyle:"lowercase"});function w(e){return 48<=e&&e<=55}function k(e){return 48<=e&&e<=57}var C=new p("tag:yaml.org,2002:int",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t,n,i=e.length,r=0,o=!1;if(!i)return!1;if("-"!==(t=e[r])&&"+"!==t||(t=e[++r]),"0"===t){if(r+1===i)return!0;if("b"===(t=e[++r])){for(r++;r<i;r++)if("_"!==(t=e[r])){if("0"!==t&&"1"!==t)return!1;o=!0}return o&&"_"!==t}if("x"===t){for(r++;r<i;r++)if("_"!==(t=e[r])){if(!(48<=(n=e.charCodeAt(r))&&n<=57||65<=n&&n<=70||97<=n&&n<=102))return!1;o=!0}return o&&"_"!==t}if("o"===t){for(r++;r<i;r++)if("_"!==(t=e[r])){if(!w(e.charCodeAt(r)))return!1;o=!0}return o&&"_"!==t}}if("_"===t)return!1;for(;r<i;r++)if("_"!==(t=e[r])){if(!k(e.charCodeAt(r)))return!1;o=!0}return!(!o||"_"===t)},construct:function(e){var t,n=e,i=1;if(-1!==n.indexOf("_")&&(n=n.replace(/_/g,"")),"-"!==(t=n[0])&&"+"!==t||("-"===t&&(i=-1),t=(n=n.slice(1))[0]),"0"===n)return 0;if("0"===t){if("b"===n[1])return i*parseInt(n.slice(2),2);if("x"===n[1])return i*parseInt(n.slice(2),16);if("o"===n[1])return i*parseInt(n.slice(2),8)}return i*parseInt(n,10)},predicate:function(e){return"[object Number]"===Object.prototype.toString.call(e)&&e%1==0&&!n.isNegativeZero(e)},represent:{binary:function(e){return e>=0?"0b"+e.toString(2):"-0b"+e.toString(2).slice(1)},octal:function(e){return e>=0?"0o"+e.toString(8):"-0o"+e.toString(8).slice(1)},decimal:function(e){return e.toString(10)},hexadecimal:function(e){return e>=0?"0x"+e.toString(16).toUpperCase():"-0x"+e.toString(16).toUpperCase().slice(1)}},defaultStyle:"decimal",styleAliases:{binary:[2,"bin"],octal:[8,"oct"],decimal:[10,"dec"],hexadecimal:[16,"hex"]}}),x=new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");var I=/^[-+]?[0-9]+e/;var S=new p("tag:yaml.org,2002:float",{kind:"scalar",resolve:function(e){return null!==e&&!(!x.test(e)||"_"===e[e.length-1])},construct:function(e){var t,n;return n="-"===(t=e.replace(/_/g,"").toLowerCase())[0]?-1:1,"+-".indexOf(t[0])>=0&&(t=t.slice(1)),".inf"===t?1===n?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:".nan"===t?NaN:n*parseFloat(t,10)},predicate:function(e){return"[object Number]"===Object.prototype.toString.call(e)&&(e%1!=0||n.isNegativeZero(e))},represent:function(e,t){var i;if(isNaN(e))switch(t){case"lowercase":return".nan";case"uppercase":return".NAN";case"camelcase":return".NaN"}else if(Number.POSITIVE_INFINITY===e)switch(t){case"lowercase":return".inf";case"uppercase":return".INF";case"camelcase":return".Inf"}else if(Number.NEGATIVE_INFINITY===e)switch(t){case"lowercase":return"-.inf";case"uppercase":return"-.INF";case"camelcase":return"-.Inf"}else if(n.isNegativeZero(e))return"-0.0";return i=e.toString(10),I.test(i)?i.replace("e",".e"):i},defaultStyle:"lowercase"}),O=b.extend({implicit:[A,v,C,S]}),j=O,T=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),N=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");var F=new p("tag:yaml.org,2002:timestamp",{kind:"scalar",resolve:function(e){return null!==e&&(null!==T.exec(e)||null!==N.exec(e))},construct:function(e){var t,n,i,r,o,a,l,c,s=0,u=null;if(null===(t=T.exec(e))&&(t=N.exec(e)),null===t)throw new Error("Date resolve error");if(n=+t[1],i=+t[2]-1,r=+t[3],!t[4])return new Date(Date.UTC(n,i,r));if(o=+t[4],a=+t[5],l=+t[6],t[7]){for(s=t[7].slice(0,3);s.length<3;)s+="0";s=+s}return t[9]&&(u=6e4*(60*+t[10]+ +(t[11]||0)),"-"===t[9]&&(u=-u)),c=new Date(Date.UTC(n,i,r,o,a,l,s)),u&&c.setTime(c.getTime()-u),c},instanceOf:Date,represent:function(e){return e.toISOString()}});var E=new p("tag:yaml.org,2002:merge",{kind:"scalar",resolve:function(e){return"<<"===e||null===e}}),M="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";var L=new p("tag:yaml.org,2002:binary",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t,n,i=0,r=e.length,o=M;for(n=0;n<r;n++)if(!((t=o.indexOf(e.charAt(n)))>64)){if(t<0)return!1;i+=6}return i%8==0},construct:function(e){var t,n,i=e.replace(/[\r\n=]/g,""),r=i.length,o=M,a=0,l=[];for(t=0;t<r;t++)t%4==0&&t&&(l.push(a>>16&255),l.push(a>>8&255),l.push(255&a)),a=a<<6|o.indexOf(i.charAt(t));return 0===(n=r%4*6)?(l.push(a>>16&255),l.push(a>>8&255),l.push(255&a)):18===n?(l.push(a>>10&255),l.push(a>>2&255)):12===n&&l.push(a>>4&255),new Uint8Array(l)},predicate:function(e){return"[object Uint8Array]"===Object.prototype.toString.call(e)},represent:function(e){var t,n,i="",r=0,o=e.length,a=M;for(t=0;t<o;t++)t%3==0&&t&&(i+=a[r>>18&63],i+=a[r>>12&63],i+=a[r>>6&63],i+=a[63&r]),r=(r<<8)+e[t];return 0===(n=o%3)?(i+=a[r>>18&63],i+=a[r>>12&63],i+=a[r>>6&63],i+=a[63&r]):2===n?(i+=a[r>>10&63],i+=a[r>>4&63],i+=a[r<<2&63],i+=a[64]):1===n&&(i+=a[r>>2&63],i+=a[r<<4&63],i+=a[64],i+=a[64]),i}}),_=Object.prototype.hasOwnProperty,D=Object.prototype.toString;var U=new p("tag:yaml.org,2002:omap",{kind:"sequence",resolve:function(e){if(null===e)return!0;var t,n,i,r,o,a=[],l=e;for(t=0,n=l.length;t<n;t+=1){if(i=l[t],o=!1,"[object Object]"!==D.call(i))return!1;for(r in i)if(_.call(i,r)){if(o)return!1;o=!0}if(!o)return!1;if(-1!==a.indexOf(r))return!1;a.push(r)}return!0},construct:function(e){return null!==e?e:[]}}),q=Object.prototype.toString;var Y=new p("tag:yaml.org,2002:pairs",{kind:"sequence",resolve:function(e){if(null===e)return!0;var t,n,i,r,o,a=e;for(o=new Array(a.length),t=0,n=a.length;t<n;t+=1){if(i=a[t],"[object Object]"!==q.call(i))return!1;if(1!==(r=Object.keys(i)).length)return!1;o[t]=[r[0],i[r[0]]]}return!0},construct:function(e){if(null===e)return[];var t,n,i,r,o,a=e;for(o=new Array(a.length),t=0,n=a.length;t<n;t+=1)i=a[t],r=Object.keys(i),o[t]=[r[0],i[r[0]]];return o}}),R=Object.prototype.hasOwnProperty;var B=new p("tag:yaml.org,2002:set",{kind:"mapping",resolve:function(e){if(null===e)return!0;var t,n=e;for(t in n)if(R.call(n,t)&&null!==n[t])return!1;return!0},construct:function(e){return null!==e?e:{}}}),K=j.extend({implicit:[F,E],explicit:[L,U,Y,B]}),P=Object.prototype.hasOwnProperty,W=/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,H=/[\x85\u2028\u2029]/,$=/[,\[\]\{\}]/,G=/^(?:!|!!|![a-z\-]+!)$/i,V=/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;function Z(e){return Object.prototype.toString.call(e)}function J(e){return 10===e||13===e}function Q(e){return 9===e||32===e}function z(e){return 9===e||32===e||10===e||13===e}function X(e){return 44===e||91===e||93===e||123===e||125===e}function ee(e){var t;return 48<=e&&e<=57?e-48:97<=(t=32|e)&&t<=102?t-97+10:-1}function te(e){return 48===e?"\0":97===e?"":98===e?"\b":116===e||9===e?"\t":110===e?"\n":118===e?"\v":102===e?"\f":114===e?"\r":101===e?"":32===e?" ":34===e?'"':47===e?"/":92===e?"\\":78===e?"Â…":95===e?"Â ":76===e?"\u2028":80===e?"\u2029":""}function ne(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(55296+(e-65536>>10),56320+(e-65536&1023))}for(var ie=new Array(256),re=new Array(256),oe=0;oe<256;oe++)ie[oe]=te(oe)?1:0,re[oe]=te(oe);function ae(e,t){this.input=e,this.filename=t.filename||null,this.schema=t.schema||K,this.onWarning=t.onWarning||null,this.legacy=t.legacy||!1,this.json=t.json||!1,this.listener=t.listener||null,this.implicitTypes=this.schema.compiledImplicit,this.typeMap=this.schema.compiledTypeMap,this.length=e.length,this.position=0,this.line=0,this.lineStart=0,this.lineIndent=0,this.firstTabInLine=-1,this.documents=[]}function le(e,t){var n={name:e.filename,buffer:e.input.slice(0,-1),position:e.position,line:e.line,column:e.position-e.lineStart};return n.snippet=c(n),new o(t,n)}function ce(e,t){throw le(e,t)}function se(e,t){e.onWarning&&e.onWarning.call(null,le(e,t))}var ue={YAML:function(e,t,n){var i,r,o;null!==e.version&&ce(e,"duplication of %YAML directive"),1!==n.length&&ce(e,"YAML directive accepts exactly one argument"),null===(i=/^([0-9]+)\.([0-9]+)$/.exec(n[0]))&&ce(e,"ill-formed argument of the YAML directive"),r=parseInt(i[1],10),o=parseInt(i[2],10),1!==r&&ce(e,"unacceptable YAML version of the document"),e.version=n[0],e.checkLineBreaks=o<2,1!==o&&2!==o&&se(e,"unsupported YAML version of the document")},TAG:function(e,t,n){var i,r;2!==n.length&&ce(e,"TAG directive accepts exactly two arguments"),i=n[0],r=n[1],G.test(i)||ce(e,"ill-formed tag handle (first argument) of the TAG directive"),P.call(e.tagMap,i)&&ce(e,'there is a previously declared suffix for "'+i+'" tag handle'),V.test(r)||ce(e,"ill-formed tag prefix (second argument) of the TAG directive");try{r=decodeURIComponent(r)}catch(t){ce(e,"tag prefix is malformed: "+r)}e.tagMap[i]=r}};function pe(e,t,n,i){var r,o,a,l;if(t<n){if(l=e.input.slice(t,n),i)for(r=0,o=l.length;r<o;r+=1)9===(a=l.charCodeAt(r))||32<=a&&a<=1114111||ce(e,"expected valid JSON character");else W.test(l)&&ce(e,"the stream contains non-printable characters");e.result+=l}}function fe(e,t,i,r){var o,a,l,c;for(n.isObject(i)||ce(e,"cannot merge mappings; the provided source object is unacceptable"),l=0,c=(o=Object.keys(i)).length;l<c;l+=1)a=o[l],P.call(t,a)||(t[a]=i[a],r[a]=!0)}function de(e,t,n,i,r,o,a,l,c){var s,u;if(Array.isArray(r))for(s=0,u=(r=Array.prototype.slice.call(r)).length;s<u;s+=1)Array.isArray(r[s])&&ce(e,"nested arrays are not supported inside keys"),"object"==typeof r&&"[object Object]"===Z(r[s])&&(r[s]="[object Object]");if("object"==typeof r&&"[object Object]"===Z(r)&&(r="[object Object]"),r=String(r),null===t&&(t={}),"tag:yaml.org,2002:merge"===i)if(Array.isArray(o))for(s=0,u=o.length;s<u;s+=1)fe(e,t,o[s],n);else fe(e,t,o,n);else e.json||P.call(n,r)||!P.call(t,r)||(e.line=a||e.line,e.lineStart=l||e.lineStart,e.position=c||e.position,ce(e,"duplicated mapping key")),"__proto__"===r?Object.defineProperty(t,r,{configurable:!0,enumerable:!0,writable:!0,value:o}):t[r]=o,delete n[r];return t}function he(e){var t;10===(t=e.input.charCodeAt(e.position))?e.position++:13===t?(e.position++,10===e.input.charCodeAt(e.position)&&e.position++):ce(e,"a line break is expected"),e.line+=1,e.lineStart=e.position,e.firstTabInLine=-1}function ge(e,t,n){for(var i=0,r=e.input.charCodeAt(e.position);0!==r;){for(;Q(r);)9===r&&-1===e.firstTabInLine&&(e.firstTabInLine=e.position),r=e.input.charCodeAt(++e.position);if(t&&35===r)do{r=e.input.charCodeAt(++e.position)}while(10!==r&&13!==r&&0!==r);if(!J(r))break;for(he(e),r=e.input.charCodeAt(e.position),i++,e.lineIndent=0;32===r;)e.lineIndent++,r=e.input.charCodeAt(++e.position)}return-1!==n&&0!==i&&e.lineIndent<n&&se(e,"deficient indentation"),i}function me(e){var t,n=e.position;return!(45!==(t=e.input.charCodeAt(n))&&46!==t||t!==e.input.charCodeAt(n+1)||t!==e.input.charCodeAt(n+2)||(n+=3,0!==(t=e.input.charCodeAt(n))&&!z(t)))}function ye(e,t){1===t?e.result+=" ":t>1&&(e.result+=n.repeat("\n",t-1))}function be(e,t){var n,i,r=e.tag,o=e.anchor,a=[],l=!1;if(-1!==e.firstTabInLine)return!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=a),i=e.input.charCodeAt(e.position);0!==i&&(-1!==e.firstTabInLine&&(e.position=e.firstTabInLine,ce(e,"tab characters must not be used in indentation")),45===i)&&z(e.input.charCodeAt(e.position+1));)if(l=!0,e.position++,ge(e,!0,-1)&&e.lineIndent<=t)a.push(null),i=e.input.charCodeAt(e.position);else if(n=e.line,we(e,t,3,!1,!0),a.push(e.result),ge(e,!0,-1),i=e.input.charCodeAt(e.position),(e.line===n||e.lineIndent>t)&&0!==i)ce(e,"bad indentation of a sequence entry");else if(e.lineIndent<t)break;return!!l&&(e.tag=r,e.anchor=o,e.kind="sequence",e.result=a,!0)}function Ae(e){var t,n,i,r,o=!1,a=!1;if(33!==(r=e.input.charCodeAt(e.position)))return!1;if(null!==e.tag&&ce(e,"duplication of a tag property"),60===(r=e.input.charCodeAt(++e.position))?(o=!0,r=e.input.charCodeAt(++e.position)):33===r?(a=!0,n="!!",r=e.input.charCodeAt(++e.position)):n="!",t=e.position,o){do{r=e.input.charCodeAt(++e.position)}while(0!==r&&62!==r);e.position<e.length?(i=e.input.slice(t,e.position),r=e.input.charCodeAt(++e.position)):ce(e,"unexpected end of the stream within a verbatim tag")}else{for(;0!==r&&!z(r);)33===r&&(a?ce(e,"tag suffix cannot contain exclamation marks"):(n=e.input.slice(t-1,e.position+1),G.test(n)||ce(e,"named tag handle cannot contain such characters"),a=!0,t=e.position+1)),r=e.input.charCodeAt(++e.position);i=e.input.slice(t,e.position),$.test(i)&&ce(e,"tag suffix cannot contain flow indicator characters")}i&&!V.test(i)&&ce(e,"tag name cannot contain such characters: "+i);try{i=decodeURIComponent(i)}catch(t){ce(e,"tag name is malformed: "+i)}return o?e.tag=i:P.call(e.tagMap,n)?e.tag=e.tagMap[n]+i:"!"===n?e.tag="!"+i:"!!"===n?e.tag="tag:yaml.org,2002:"+i:ce(e,'undeclared tag handle "'+n+'"'),!0}function ve(e){var t,n;if(38!==(n=e.input.charCodeAt(e.position)))return!1;for(null!==e.anchor&&ce(e,"duplication of an anchor property"),n=e.input.charCodeAt(++e.position),t=e.position;0!==n&&!z(n)&&!X(n);)n=e.input.charCodeAt(++e.position);return e.position===t&&ce(e,"name of an anchor node must contain at least one character"),e.anchor=e.input.slice(t,e.position),!0}function we(e,t,i,r,o){var a,l,c,s,u,p,f,d,h,g=1,m=!1,y=!1;if(null!==e.listener&&e.listener("open",e),e.tag=null,e.anchor=null,e.kind=null,e.result=null,a=l=c=4===i||3===i,r&&ge(e,!0,-1)&&(m=!0,e.lineIndent>t?g=1:e.lineIndent===t?g=0:e.lineIndent<t&&(g=-1)),1===g)for(;Ae(e)||ve(e);)ge(e,!0,-1)?(m=!0,c=a,e.lineIndent>t?g=1:e.lineIndent===t?g=0:e.lineIndent<t&&(g=-1)):c=!1;if(c&&(c=m||o),1!==g&&4!==i||(d=1===i||2===i?t:t+1,h=e.position-e.lineStart,1===g?c&&(be(e,h)||function(e,t,n){var i,r,o,a,l,c,s,u=e.tag,p=e.anchor,f={},d=Object.create(null),h=null,g=null,m=null,y=!1,b=!1;if(-1!==e.firstTabInLine)return!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=f),s=e.input.charCodeAt(e.position);0!==s;){if(y||-1===e.firstTabInLine||(e.position=e.firstTabInLine,ce(e,"tab characters must not be used in indentation")),i=e.input.charCodeAt(e.position+1),o=e.line,63!==s&&58!==s||!z(i)){if(a=e.line,l=e.lineStart,c=e.position,!we(e,n,2,!1,!0))break;if(e.line===o){for(s=e.input.charCodeAt(e.position);Q(s);)s=e.input.charCodeAt(++e.position);if(58===s)z(s=e.input.charCodeAt(++e.position))||ce(e,"a whitespace character is expected after the key-value separator within a block mapping"),y&&(de(e,f,d,h,g,null,a,l,c),h=g=m=null),b=!0,y=!1,r=!1,h=e.tag,g=e.result;else{if(!b)return e.tag=u,e.anchor=p,!0;ce(e,"can not read an implicit mapping pair; a colon is missed")}}else{if(!b)return e.tag=u,e.anchor=p,!0;ce(e,"can not read a block mapping entry; a multiline key may not be an implicit key")}}else 63===s?(y&&(de(e,f,d,h,g,null,a,l,c),h=g=m=null),b=!0,y=!0,r=!0):y?(y=!1,r=!0):ce(e,"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),e.position+=1,s=i;if((e.line===o||e.lineIndent>t)&&(y&&(a=e.line,l=e.lineStart,c=e.position),we(e,t,4,!0,r)&&(y?g=e.result:m=e.result),y||(de(e,f,d,h,g,m,a,l,c),h=g=m=null),ge(e,!0,-1),s=e.input.charCodeAt(e.position)),(e.line===o||e.lineIndent>t)&&0!==s)ce(e,"bad indentation of a mapping entry");else if(e.lineIndent<t)break}return y&&de(e,f,d,h,g,null,a,l,c),b&&(e.tag=u,e.anchor=p,e.kind="mapping",e.result=f),b}(e,h,d))||function(e,t){var n,i,r,o,a,l,c,s,u,p,f,d,h=!0,g=e.tag,m=e.anchor,y=Object.create(null);if(91===(d=e.input.charCodeAt(e.position)))a=93,s=!1,o=[];else{if(123!==d)return!1;a=125,s=!0,o={}}for(null!==e.anchor&&(e.anchorMap[e.anchor]=o),d=e.input.charCodeAt(++e.position);0!==d;){if(ge(e,!0,t),(d=e.input.charCodeAt(e.position))===a)return e.position++,e.tag=g,e.anchor=m,e.kind=s?"mapping":"sequence",e.result=o,!0;h?44===d&&ce(e,"expected the node content, but found ','"):ce(e,"missed comma between flow collection entries"),f=null,l=c=!1,63===d&&z(e.input.charCodeAt(e.position+1))&&(l=c=!0,e.position++,ge(e,!0,t)),n=e.line,i=e.lineStart,r=e.position,we(e,t,1,!1,!0),p=e.tag,u=e.result,ge(e,!0,t),d=e.input.charCodeAt(e.position),!c&&e.line!==n||58!==d||(l=!0,d=e.input.charCodeAt(++e.position),ge(e,!0,t),we(e,t,1,!1,!0),f=e.result),s?de(e,o,y,p,u,f,n,i,r):l?o.push(de(e,null,y,p,u,f,n,i,r)):o.push(u),ge(e,!0,t),44===(d=e.input.charCodeAt(e.position))?(h=!0,d=e.input.charCodeAt(++e.position)):h=!1}ce(e,"unexpected end of the stream within a flow collection")}(e,d)?y=!0:(l&&function(e,t){var i,r,o,a,l,c=1,s=!1,u=!1,p=t,f=0,d=!1;if(124===(a=e.input.charCodeAt(e.position)))r=!1;else{if(62!==a)return!1;r=!0}for(e.kind="scalar",e.result="";0!==a;)if(43===(a=e.input.charCodeAt(++e.position))||45===a)1===c?c=43===a?3:2:ce(e,"repeat of a chomping mode identifier");else{if(!((o=48<=(l=a)&&l<=57?l-48:-1)>=0))break;0===o?ce(e,"bad explicit indentation width of a block scalar; it cannot be less than one"):u?ce(e,"repeat of an indentation width identifier"):(p=t+o-1,u=!0)}if(Q(a)){do{a=e.input.charCodeAt(++e.position)}while(Q(a));if(35===a)do{a=e.input.charCodeAt(++e.position)}while(!J(a)&&0!==a)}for(;0!==a;){for(he(e),e.lineIndent=0,a=e.input.charCodeAt(e.position);(!u||e.lineIndent<p)&&32===a;)e.lineIndent++,a=e.input.charCodeAt(++e.position);if(!u&&e.lineIndent>p&&(p=e.lineIndent),J(a))f++;else{if(e.lineIndent<p){3===c?e.result+=n.repeat("\n",s?1+f:f):1===c&&s&&(e.result+="\n");break}for(r?Q(a)?(d=!0,e.result+=n.repeat("\n",s?1+f:f)):d?(d=!1,e.result+=n.repeat("\n",f+1)):0===f?s&&(e.result+=" "):e.result+=n.repeat("\n",f):e.result+=n.repeat("\n",s?1+f:f),s=!0,u=!0,f=0,i=e.position;!J(a)&&0!==a;)a=e.input.charCodeAt(++e.position);pe(e,i,e.position,!1)}}return!0}(e,d)||function(e,t){var n,i,r;if(39!==(n=e.input.charCodeAt(e.position)))return!1;for(e.kind="scalar",e.result="",e.position++,i=r=e.position;0!==(n=e.input.charCodeAt(e.position));)if(39===n){if(pe(e,i,e.position,!0),39!==(n=e.input.charCodeAt(++e.position)))return!0;i=e.position,e.position++,r=e.position}else J(n)?(pe(e,i,r,!0),ye(e,ge(e,!1,t)),i=r=e.position):e.position===e.lineStart&&me(e)?ce(e,"unexpected end of the document within a single quoted scalar"):(e.position++,r=e.position);ce(e,"unexpected end of the stream within a single quoted scalar")}(e,d)||function(e,t){var n,i,r,o,a,l,c;if(34!==(l=e.input.charCodeAt(e.position)))return!1;for(e.kind="scalar",e.result="",e.position++,n=i=e.position;0!==(l=e.input.charCodeAt(e.position));){if(34===l)return pe(e,n,e.position,!0),e.position++,!0;if(92===l){if(pe(e,n,e.position,!0),J(l=e.input.charCodeAt(++e.position)))ge(e,!1,t);else if(l<256&&ie[l])e.result+=re[l],e.position++;else if((a=120===(c=l)?2:117===c?4:85===c?8:0)>0){for(r=a,o=0;r>0;r--)(a=ee(l=e.input.charCodeAt(++e.position)))>=0?o=(o<<4)+a:ce(e,"expected hexadecimal character");e.result+=ne(o),e.position++}else ce(e,"unknown escape sequence");n=i=e.position}else J(l)?(pe(e,n,i,!0),ye(e,ge(e,!1,t)),n=i=e.position):e.position===e.lineStart&&me(e)?ce(e,"unexpected end of the document within a double quoted scalar"):(e.position++,i=e.position)}ce(e,"unexpected end of the stream within a double quoted scalar")}(e,d)?y=!0:!function(e){var t,n,i;if(42!==(i=e.input.charCodeAt(e.position)))return!1;for(i=e.input.charCodeAt(++e.position),t=e.position;0!==i&&!z(i)&&!X(i);)i=e.input.charCodeAt(++e.position);return e.position===t&&ce(e,"name of an alias node must contain at least one character"),n=e.input.slice(t,e.position),P.call(e.anchorMap,n)||ce(e,'unidentified alias "'+n+'"'),e.result=e.anchorMap[n],ge(e,!0,-1),!0}(e)?function(e,t,n){var i,r,o,a,l,c,s,u,p=e.kind,f=e.result;if(z(u=e.input.charCodeAt(e.position))||X(u)||35===u||38===u||42===u||33===u||124===u||62===u||39===u||34===u||37===u||64===u||96===u)return!1;if((63===u||45===u)&&(z(i=e.input.charCodeAt(e.position+1))||n&&X(i)))return!1;for(e.kind="scalar",e.result="",r=o=e.position,a=!1;0!==u;){if(58===u){if(z(i=e.input.charCodeAt(e.position+1))||n&&X(i))break}else if(35===u){if(z(e.input.charCodeAt(e.position-1)))break}else{if(e.position===e.lineStart&&me(e)||n&&X(u))break;if(J(u)){if(l=e.line,c=e.lineStart,s=e.lineIndent,ge(e,!1,-1),e.lineIndent>=t){a=!0,u=e.input.charCodeAt(e.position);continue}e.position=o,e.line=l,e.lineStart=c,e.lineIndent=s;break}}a&&(pe(e,r,o,!1),ye(e,e.line-l),r=o=e.position,a=!1),Q(u)||(o=e.position+1),u=e.input.charCodeAt(++e.position)}return pe(e,r,o,!1),!!e.result||(e.kind=p,e.result=f,!1)}(e,d,1===i)&&(y=!0,null===e.tag&&(e.tag="?")):(y=!0,null===e.tag&&null===e.anchor||ce(e,"alias node should not have any properties")),null!==e.anchor&&(e.anchorMap[e.anchor]=e.result)):0===g&&(y=c&&be(e,h))),null===e.tag)null!==e.anchor&&(e.anchorMap[e.anchor]=e.result);else if("?"===e.tag){for(null!==e.result&&"scalar"!==e.kind&&ce(e,'unacceptable node kind for !<?> tag; it should be "scalar", not "'+e.kind+'"'),s=0,u=e.implicitTypes.length;s<u;s+=1)if((f=e.implicitTypes[s]).resolve(e.result)){e.result=f.construct(e.result),e.tag=f.tag,null!==e.anchor&&(e.anchorMap[e.anchor]=e.result);break}}else if("!"!==e.tag){if(P.call(e.typeMap[e.kind||"fallback"],e.tag))f=e.typeMap[e.kind||"fallback"][e.tag];else for(f=null,s=0,u=(p=e.typeMap.multi[e.kind||"fallback"]).length;s<u;s+=1)if(e.tag.slice(0,p[s].tag.length)===p[s].tag){f=p[s];break}f||ce(e,"unknown tag !<"+e.tag+">"),null!==e.result&&f.kind!==e.kind&&ce(e,"unacceptable node kind for !<"+e.tag+'> tag; it should be "'+f.kind+'", not "'+e.kind+'"'),f.resolve(e.result,e.tag)?(e.result=f.construct(e.result,e.tag),null!==e.anchor&&(e.anchorMap[e.anchor]=e.result)):ce(e,"cannot resolve a node with !<"+e.tag+"> explicit tag")}return null!==e.listener&&e.listener("close",e),null!==e.tag||null!==e.anchor||y}function ke(e){var t,n,i,r,o=e.position,a=!1;for(e.version=null,e.checkLineBreaks=e.legacy,e.tagMap=Object.create(null),e.anchorMap=Object.create(null);0!==(r=e.input.charCodeAt(e.position))&&(ge(e,!0,-1),r=e.input.charCodeAt(e.position),!(e.lineIndent>0||37!==r));){for(a=!0,r=e.input.charCodeAt(++e.position),t=e.position;0!==r&&!z(r);)r=e.input.charCodeAt(++e.position);for(i=[],(n=e.input.slice(t,e.position)).length<1&&ce(e,"directive name must not be less than one character in length");0!==r;){for(;Q(r);)r=e.input.charCodeAt(++e.position);if(35===r){do{r=e.input.charCodeAt(++e.position)}while(0!==r&&!J(r));break}if(J(r))break;for(t=e.position;0!==r&&!z(r);)r=e.input.charCodeAt(++e.position);i.push(e.input.slice(t,e.position))}0!==r&&he(e),P.call(ue,n)?ue[n](e,n,i):se(e,'unknown document directive "'+n+'"')}ge(e,!0,-1),0===e.lineIndent&&45===e.input.charCodeAt(e.position)&&45===e.input.charCodeAt(e.position+1)&&45===e.input.charCodeAt(e.position+2)?(e.position+=3,ge(e,!0,-1)):a&&ce(e,"directives end mark is expected"),we(e,e.lineIndent-1,4,!1,!0),ge(e,!0,-1),e.checkLineBreaks&&H.test(e.input.slice(o,e.position))&&se(e,"non-ASCII line breaks are interpreted as content"),e.documents.push(e.result),e.position===e.lineStart&&me(e)?46===e.input.charCodeAt(e.position)&&(e.position+=3,ge(e,!0,-1)):e.position<e.length-1&&ce(e,"end of the stream or a document separator is expected")}function Ce(e,t){t=t||{},0!==(e=String(e)).length&&(10!==e.charCodeAt(e.length-1)&&13!==e.charCodeAt(e.length-1)&&(e+="\n"),65279===e.charCodeAt(0)&&(e=e.slice(1)));var n=new ae(e,t),i=e.indexOf("\0");for(-1!==i&&(n.position=i,ce(n,"null byte is not allowed in input")),n.input+="\0";32===n.input.charCodeAt(n.position);)n.lineIndent+=1,n.position+=1;for(;n.position<n.length-1;)ke(n);return n.documents}var xe={loadAll:function(e,t,n){null!==t&&"object"==typeof t&&void 0===n&&(n=t,t=null);var i=Ce(e,n);if("function"!=typeof t)return i;for(var r=0,o=i.length;r<o;r+=1)t(i[r])},load:function(e,t){var n=Ce(e,t);if(0!==n.length){if(1===n.length)return n[0];throw new o("expected a single document in the stream, but found more")}}},Ie=Object.prototype.toString,Se=Object.prototype.hasOwnProperty,Oe=65279,je={0:"\\0",7:"\\a",8:"\\b",9:"\\t",10:"\\n",11:"\\v",12:"\\f",13:"\\r",27:"\\e",34:'\\"',92:"\\\\",133:"\\N",160:"\\_",8232:"\\L",8233:"\\P"},Te=["y","Y","yes","Yes","YES","on","On","ON","n","N","no","No","NO","off","Off","OFF"],Ne=/^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;function Fe(e){var t,i,r;if(t=e.toString(16).toUpperCase(),e<=255)i="x",r=2;else if(e<=65535)i="u",r=4;else{if(!(e<=4294967295))throw new o("code point within a string may not be greater than 0xFFFFFFFF");i="U",r=8}return"\\"+i+n.repeat("0",r-t.length)+t}function Ee(e){this.schema=e.schema||K,this.indent=Math.max(1,e.indent||2),this.noArrayIndent=e.noArrayIndent||!1,this.skipInvalid=e.skipInvalid||!1,this.flowLevel=n.isNothing(e.flowLevel)?-1:e.flowLevel,this.styleMap=function(e,t){var n,i,r,o,a,l,c;if(null===t)return{};for(n={},r=0,o=(i=Object.keys(t)).length;r<o;r+=1)a=i[r],l=String(t[a]),"!!"===a.slice(0,2)&&(a="tag:yaml.org,2002:"+a.slice(2)),(c=e.compiledTypeMap.fallback[a])&&Se.call(c.styleAliases,l)&&(l=c.styleAliases[l]),n[a]=l;return n}(this.schema,e.styles||null),this.sortKeys=e.sortKeys||!1,this.lineWidth=e.lineWidth||80,this.noRefs=e.noRefs||!1,this.noCompatMode=e.noCompatMode||!1,this.condenseFlow=e.condenseFlow||!1,this.quotingType='"'===e.quotingType?2:1,this.forceQuotes=e.forceQuotes||!1,this.replacer="function"==typeof e.replacer?e.replacer:null,this.implicitTypes=this.schema.compiledImplicit,this.explicitTypes=this.schema.compiledExplicit,this.tag=null,this.result="",this.duplicates=[],this.usedDuplicates=null}function Me(e,t){for(var i,r=n.repeat(" ",t),o=0,a=-1,l="",c=e.length;o<c;)-1===(a=e.indexOf("\n",o))?(i=e.slice(o),o=c):(i=e.slice(o,a+1),o=a+1),i.length&&"\n"!==i&&(l+=r),l+=i;return l}function Le(e,t){return"\n"+n.repeat(" ",e.indent*t)}function _e(e){return 32===e||9===e}function De(e){return 32<=e&&e<=126||161<=e&&e<=55295&&8232!==e&&8233!==e||57344<=e&&e<=65533&&e!==Oe||65536<=e&&e<=1114111}function Ue(e){return De(e)&&e!==Oe&&13!==e&&10!==e}function qe(e,t,n){var i=Ue(e),r=i&&!_e(e);return(n?i:i&&44!==e&&91!==e&&93!==e&&123!==e&&125!==e)&&35!==e&&!(58===t&&!r)||Ue(t)&&!_e(t)&&35===e||58===t&&r}function Ye(e,t){var n,i=e.charCodeAt(t);return i>=55296&&i<=56319&&t+1<e.length&&(n=e.charCodeAt(t+1))>=56320&&n<=57343?1024*(i-55296)+n-56320+65536:i}function Re(e){return/^\n* /.test(e)}function Be(e,t,n,i,r,o,a,l){var c,s,u=0,p=null,f=!1,d=!1,h=-1!==i,g=-1,m=De(s=Ye(e,0))&&s!==Oe&&!_e(s)&&45!==s&&63!==s&&58!==s&&44!==s&&91!==s&&93!==s&&123!==s&&125!==s&&35!==s&&38!==s&&42!==s&&33!==s&&124!==s&&61!==s&&62!==s&&39!==s&&34!==s&&37!==s&&64!==s&&96!==s&&function(e){return!_e(e)&&58!==e}(Ye(e,e.length-1));if(t||a)for(c=0;c<e.length;u>=65536?c+=2:c++){if(!De(u=Ye(e,c)))return 5;m=m&&qe(u,p,l),p=u}else{for(c=0;c<e.length;u>=65536?c+=2:c++){if(10===(u=Ye(e,c)))f=!0,h&&(d=d||c-g-1>i&&" "!==e[g+1],g=c);else if(!De(u))return 5;m=m&&qe(u,p,l),p=u}d=d||h&&c-g-1>i&&" "!==e[g+1]}return f||d?n>9&&Re(e)?5:a?2===o?5:2:d?4:3:!m||a||r(e)?2===o?5:2:1}function Ke(e,t,n,i,r){e.dump=function(){if(0===t.length)return 2===e.quotingType?'""':"''";if(!e.noCompatMode&&(-1!==Te.indexOf(t)||Ne.test(t)))return 2===e.quotingType?'"'+t+'"':"'"+t+"'";var a=e.indent*Math.max(1,n),l=-1===e.lineWidth?-1:Math.max(Math.min(e.lineWidth,40),e.lineWidth-a),c=i||e.flowLevel>-1&&n>=e.flowLevel;switch(Be(t,c,e.indent,l,(function(t){return function(e,t){var n,i;for(n=0,i=e.implicitTypes.length;n<i;n+=1)if(e.implicitTypes[n].resolve(t))return!0;return!1}(e,t)}),e.quotingType,e.forceQuotes&&!i,r)){case 1:return t;case 2:return"'"+t.replace(/'/g,"''")+"'";case 3:return"|"+Pe(t,e.indent)+We(Me(t,a));case 4:return">"+Pe(t,e.indent)+We(Me(function(e,t){var n,i,r=/(\n+)([^\n]*)/g,o=(l=e.indexOf("\n"),l=-1!==l?l:e.length,r.lastIndex=l,He(e.slice(0,l),t)),a="\n"===e[0]||" "===e[0];var l;for(;i=r.exec(e);){var c=i[1],s=i[2];n=" "===s[0],o+=c+(a||n||""===s?"":"\n")+He(s,t),a=n}return o}(t,l),a));case 5:return'"'+function(e){for(var t,n="",i=0,r=0;r<e.length;i>=65536?r+=2:r++)i=Ye(e,r),!(t=je[i])&&De(i)?(n+=e[r],i>=65536&&(n+=e[r+1])):n+=t||Fe(i);return n}(t)+'"';default:throw new o("impossible error: invalid scalar style")}}()}function Pe(e,t){var n=Re(e)?String(t):"",i="\n"===e[e.length-1];return n+(i&&("\n"===e[e.length-2]||"\n"===e)?"+":i?"":"-")+"\n"}function We(e){return"\n"===e[e.length-1]?e.slice(0,-1):e}function He(e,t){if(""===e||" "===e[0])return e;for(var n,i,r=/ [^ ]/g,o=0,a=0,l=0,c="";n=r.exec(e);)(l=n.index)-o>t&&(i=a>o?a:l,c+="\n"+e.slice(o,i),o=i+1),a=l;return c+="\n",e.length-o>t&&a>o?c+=e.slice(o,a)+"\n"+e.slice(a+1):c+=e.slice(o),c.slice(1)}function $e(e,t,n,i){var r,o,a,l="",c=e.tag;for(r=0,o=n.length;r<o;r+=1)a=n[r],e.replacer&&(a=e.replacer.call(n,String(r),a)),(Ve(e,t+1,a,!0,!0,!1,!0)||void 0===a&&Ve(e,t+1,null,!0,!0,!1,!0))&&(i&&""===l||(l+=Le(e,t)),e.dump&&10===e.dump.charCodeAt(0)?l+="-":l+="- ",l+=e.dump);e.tag=c,e.dump=l||"[]"}function Ge(e,t,n){var i,r,a,l,c,s;for(a=0,l=(r=n?e.explicitTypes:e.implicitTypes).length;a<l;a+=1)if(((c=r[a]).instanceOf||c.predicate)&&(!c.instanceOf||"object"==typeof t&&t instanceof c.instanceOf)&&(!c.predicate||c.predicate(t))){if(n?c.multi&&c.representName?e.tag=c.representName(t):e.tag=c.tag:e.tag="?",c.represent){if(s=e.styleMap[c.tag]||c.defaultStyle,"[object Function]"===Ie.call(c.represent))i=c.represent(t,s);else{if(!Se.call(c.represent,s))throw new o("!<"+c.tag+'> tag resolver accepts not "'+s+'" style');i=c.represent[s](t,s)}e.dump=i}return!0}return!1}function Ve(e,t,n,i,r,a,l){e.tag=null,e.dump=n,Ge(e,n,!1)||Ge(e,n,!0);var c,s=Ie.call(e.dump),u=i;i&&(i=e.flowLevel<0||e.flowLevel>t);var p,f,d="[object Object]"===s||"[object Array]"===s;if(d&&(f=-1!==(p=e.duplicates.indexOf(n))),(null!==e.tag&&"?"!==e.tag||f||2!==e.indent&&t>0)&&(r=!1),f&&e.usedDuplicates[p])e.dump="*ref_"+p;else{if(d&&f&&!e.usedDuplicates[p]&&(e.usedDuplicates[p]=!0),"[object Object]"===s)i&&0!==Object.keys(e.dump).length?(!function(e,t,n,i){var r,a,l,c,s,u,p="",f=e.tag,d=Object.keys(n);if(!0===e.sortKeys)d.sort();else if("function"==typeof e.sortKeys)d.sort(e.sortKeys);else if(e.sortKeys)throw new o("sortKeys must be a boolean or a function");for(r=0,a=d.length;r<a;r+=1)u="",i&&""===p||(u+=Le(e,t)),c=n[l=d[r]],e.replacer&&(c=e.replacer.call(n,l,c)),Ve(e,t+1,l,!0,!0,!0)&&((s=null!==e.tag&&"?"!==e.tag||e.dump&&e.dump.length>1024)&&(e.dump&&10===e.dump.charCodeAt(0)?u+="?":u+="? "),u+=e.dump,s&&(u+=Le(e,t)),Ve(e,t+1,c,!0,s)&&(e.dump&&10===e.dump.charCodeAt(0)?u+=":":u+=": ",p+=u+=e.dump));e.tag=f,e.dump=p||"{}"}(e,t,e.dump,r),f&&(e.dump="&ref_"+p+e.dump)):(!function(e,t,n){var i,r,o,a,l,c="",s=e.tag,u=Object.keys(n);for(i=0,r=u.length;i<r;i+=1)l="",""!==c&&(l+=", "),e.condenseFlow&&(l+='"'),a=n[o=u[i]],e.replacer&&(a=e.replacer.call(n,o,a)),Ve(e,t,o,!1,!1)&&(e.dump.length>1024&&(l+="? "),l+=e.dump+(e.condenseFlow?'"':"")+":"+(e.condenseFlow?"":" "),Ve(e,t,a,!1,!1)&&(c+=l+=e.dump));e.tag=s,e.dump="{"+c+"}"}(e,t,e.dump),f&&(e.dump="&ref_"+p+" "+e.dump));else if("[object Array]"===s)i&&0!==e.dump.length?(e.noArrayIndent&&!l&&t>0?$e(e,t-1,e.dump,r):$e(e,t,e.dump,r),f&&(e.dump="&ref_"+p+e.dump)):(!function(e,t,n){var i,r,o,a="",l=e.tag;for(i=0,r=n.length;i<r;i+=1)o=n[i],e.replacer&&(o=e.replacer.call(n,String(i),o)),(Ve(e,t,o,!1,!1)||void 0===o&&Ve(e,t,null,!1,!1))&&(""!==a&&(a+=","+(e.condenseFlow?"":" ")),a+=e.dump);e.tag=l,e.dump="["+a+"]"}(e,t,e.dump),f&&(e.dump="&ref_"+p+" "+e.dump));else{if("[object String]"!==s){if("[object Undefined]"===s)return!1;if(e.skipInvalid)return!1;throw new o("unacceptable kind of an object to dump "+s)}"?"!==e.tag&&Ke(e,e.dump,t,a,u)}null!==e.tag&&"?"!==e.tag&&(c=encodeURI("!"===e.tag[0]?e.tag.slice(1):e.tag).replace(/!/g,"%21"),c="!"===e.tag[0]?"!"+c:"tag:yaml.org,2002:"===c.slice(0,18)?"!!"+c.slice(18):"!<"+c+">",e.dump=c+" "+e.dump)}return!0}function Ze(e,t){var n,i,r=[],o=[];for(Je(e,r,o),n=0,i=o.length;n<i;n+=1)t.duplicates.push(r[o[n]]);t.usedDuplicates=new Array(i)}function Je(e,t,n){var i,r,o;if(null!==e&&"object"==typeof e)if(-1!==(r=t.indexOf(e)))-1===n.indexOf(r)&&n.push(r);else if(t.push(e),Array.isArray(e))for(r=0,o=e.length;r<o;r+=1)Je(e[r],t,n);else for(r=0,o=(i=Object.keys(e)).length;r<o;r+=1)Je(e[i[r]],t,n)}function Qe(e,t){return function(){throw new Error("Function yaml."+e+" is removed in js-yaml 4. Use yaml."+t+" instead, which is now safe by default.")}}var ze=p,Xe=h,et=b,tt=O,nt=j,it=K,rt=xe.load,ot=xe.loadAll,at={dump:function(e,t){var n=new Ee(t=t||{});n.noRefs||Ze(e,n);var i=e;return n.replacer&&(i=n.replacer.call({"":i},"",i)),Ve(n,0,i,!0,!0)?n.dump+"\n":""}}.dump,lt=o,ct={binary:L,float:S,map:y,null:A,pairs:Y,set:B,timestamp:F,bool:v,int:C,merge:E,omap:U,seq:m,str:g},st=Qe("safeLoad","load"),ut=Qe("safeLoadAll","loadAll"),pt=Qe("safeDump","dump"),ft={Type:ze,Schema:Xe,FAILSAFE_SCHEMA:et,JSON_SCHEMA:tt,CORE_SCHEMA:nt,DEFAULT_SCHEMA:it,load:rt,loadAll:ot,dump:at,YAMLException:lt,types:ct,safeLoad:st,safeLoadAll:ut,safeDump:pt};e.CORE_SCHEMA=nt,e.DEFAULT_SCHEMA=it,e.FAILSAFE_SCHEMA=et,e.JSON_SCHEMA=tt,e.Schema=Xe,e.Type=ze,e.YAMLException=lt,e.default=ft,e.dump=at,e.load=rt,e.loadAll=ot,e.safeDump=pt,e.safeLoad=st,e.safeLoadAll=ut,e.types=ct,Object.defineProperty(e,"__esModule",{value:!0})}));

/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException$1(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


var exception = YAMLException$1;

// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, 'â†’') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


var snippet = makeSnippet;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$1(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type$1;

/*eslint-disable max-len*/





function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  return this.extend(definition);
}


Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type$1.loadKind && type$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type$1.multi) {
      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema$1.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


var schema = Schema$1;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

var int = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

var float = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});

var core = json;

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/





// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

/*eslint-disable max-len,no-use-before-define*/







var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State$1(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || _default;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = snippet(mark);

  return new exception(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
        _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State$1(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load$1(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception('expected a single document in the stream, but found more');
}


var loadAll_1 = loadAll$1;
var load_1    = load$1;

var loader = {
	loadAll: loadAll_1,
	load: load_1
};

/*eslint-disable no-use-before-define*/





var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || _default;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnâ€™t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out
//                             c = flow-in   â‡’ ns-plain-safe-in
//                             c = block-key â‡’ ns-plain-safe-out
//                             c = flow-key  â‡’ ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )
//                            | ( /* An ns-char preceding */ â€œ#â€ )
//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ"â€
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | â€œ%â€ | â€œ@â€ | â€œ`â€)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    â€¢ No ending newline => unaffected; already using strip "-" chomping.
//    â€¢ Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€
      // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€
      //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€
      //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump$1(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

var dump_1 = dump$1;

var dumper = {
	dump: dump_1
};

function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


var Type                = type;
var Schema              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json;
var CORE_SCHEMA         = core;
var DEFAULT_SCHEMA      = _default;
var load                = loader.load;
var loadAll             = loader.loadAll;
var dump                = dumper.dump;
var YAMLException       = exception;

// Re-export all types in case user wants to create custom schema
var types = {
  binary:    binary,
  float:     float,
  map:       map,
  null:      _null,
  pairs:     pairs,
  set:       set,
  timestamp: timestamp,
  bool:      bool,
  int:       int,
  merge:     merge,
  omap:      omap,
  seq:       seq,
  str:       str
};

// Removed functions from JS-YAML 3.0.x
var safeLoad            = renamed('safeLoad', 'load');
var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
var safeDump            = renamed('safeDump', 'dump');

var jsYaml = {
	Type: Type,
	Schema: Schema,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	load: load,
	loadAll: loadAll,
	dump: dump,
	YAMLException: YAMLException,
	types: types,
	safeLoad: safeLoad,
	safeLoadAll: safeLoadAll,
	safeDump: safeDump
};

export default jsYaml;
export { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };

/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jsyaml = {}));
}(this, (function (exports) { 'use strict';

  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = '', cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }


  var isNothing_1      = isNothing;
  var isObject_1       = isObject;
  var toArray_1        = toArray;
  var repeat_1         = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1         = extend;

  var common = {
  	isNothing: isNothing_1,
  	isObject: isObject_1,
  	toArray: toArray_1,
  	repeat: repeat_1,
  	isNegativeZero: isNegativeZero_1,
  	extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984


  function formatError(exception, compact) {
    var where = '', message = exception.reason || '(unknown reason)';

    if (!exception.mark) return message;

    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }

    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

    if (!compact && exception.mark.snippet) {
      where += '\n\n' + exception.mark.snippet;
    }

    return message + ' ' + where;
  }


  function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || '';
    }
  }


  // Inherit from Error
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;


  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ': ' + formatError(this, compact);
  };


  var exception = YAMLException$1;

  // get snippet for a single line, respecting maxLength
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = '';
    var tail = '';
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

    if (position - lineStart > maxHalfLength) {
      head = ' ... ';
      lineStart = position - maxHalfLength + head.length;
    }

    if (lineEnd - position > maxHalfLength) {
      tail = ' ...';
      lineEnd = position + maxHalfLength - tail.length;
    }

    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, 'â†’') + tail,
      pos: position - lineStart + head.length // relative position
    };
  }


  function padStart(string, max) {
    return common.repeat(' ', max - string.length) + string;
  }


  function makeSnippet(mark, options) {
    options = Object.create(options || null);

    if (!mark.buffer) return null;

    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent      !== 'number') options.indent      = 1;
    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
    if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

    var re = /\r?\n|\r|\0/g;
    var lineStarts = [ 0 ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;

    while ((match = re.exec(mark.buffer))) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);

      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }

    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

    var result = '', i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n' + result;
    }

    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n';
    }

    return result.replace(/\n$/, '');
  }


  var snippet = makeSnippet;

  var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'multi',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'representName',
    'defaultStyle',
    'styleAliases'
  ];

  var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$1(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });

    // TODO: Add tag format check.
    this.options       = options; // keep original options in case user wants to extend this type later
    this.tag           = tag;
    this.kind          = options['kind']          || null;
    this.resolve       = options['resolve']       || function () { return true; };
    this.construct     = options['construct']     || function (data) { return data; };
    this.instanceOf    = options['instanceOf']    || null;
    this.predicate     = options['predicate']     || null;
    this.represent     = options['represent']     || null;
    this.representName = options['representName'] || null;
    this.defaultStyle  = options['defaultStyle']  || null;
    this.multi         = options['multi']         || false;
    this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type$1;

  /*eslint-disable max-len*/





  function compileList(schema, name) {
    var result = [];

    schema[name].forEach(function (currentType) {
      var newIndex = result.length;

      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag &&
            previousType.kind === currentType.kind &&
            previousType.multi === currentType.multi) {

          newIndex = previousIndex;
        }
      });

      result[newIndex] = currentType;
    });

    return result;
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {},
          multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
          }
        }, index, length;

    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi['fallback'].push(type);
      } else {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema$1(definition) {
    return this.extend(definition);
  }


  Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];

    if (definition instanceof type) {
      // Schema.extend(type)
      explicit.push(definition);

    } else if (Array.isArray(definition)) {
      // Schema.extend([ type1, type2, ... ])
      explicit = explicit.concat(definition);

    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);

    } else {
      throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
        'or a schema definition ({ implicit: [...], explicit: [...] })');
    }

    implicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }

      if (type$1.loadKind && type$1.loadKind !== 'scalar') {
        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }

      if (type$1.multi) {
        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
      }
    });

    explicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
    });

    var result = Object.create(Schema$1.prototype);

    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);

    result.compiledImplicit = compileList(result, 'implicit');
    result.compiledExplicit = compileList(result, 'explicit');
    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

    return result;
  };


  var schema = Schema$1;

  var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) { return data !== null ? data : ''; }
  });

  var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) { return data !== null ? data : []; }
  });

  var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) { return data !== null ? data : {}; }
  });

  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 && data === '~') ||
           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; },
      empty:     function () { return '';     }
    },
    defaultStyle: 'lowercase'
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }

  function constructYamlBoolean(data) {
    return data === 'true' ||
           data === 'True' ||
           data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    },
    defaultStyle: 'lowercase'
  });

  function isHexCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
           ((0x61/* a */ <= c) && (c <= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'o') {
        // base 8
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
    }

    // base 10 (except 0)

    // value should not start with `_`;
    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;

    return true;
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' &&
           (object % 1 === 0 && !common.isNegativeZero(object));
  }

  var int = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign;

    value  = data.replace(/_/g, '').toLowerCase();
    sign   = value[0] === '-' ? -1 : 1;

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === '.nan') {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase': return '.nan';
        case 'uppercase': return '.NAN';
        case 'camelcase': return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '.inf';
        case 'uppercase': return '.INF';
        case 'camelcase': return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '-.inf';
        case 'uppercase': return '-.INF';
        case 'camelcase': return '-.Inf';
      }
    } else if (common.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') &&
           (object % 1 !== 0 || common.isNegativeZero(object));
  }

  var float = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });

  var core = json;

  var YAML_DATE_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9])'                    + // [2] month
    '-([0-9][0-9])$');                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9]?)'                   + // [2] month
    '-([0-9][0-9]?)'                   + // [3] day
    '(?:[Tt]|[ \\t]+)'                 + // ...
    '([0-9][0-9]?)'                    + // [4] hour
    ':([0-9][0-9])'                    + // [5] minute
    ':([0-9][0-9])'                    + // [6] second
    '(?:\\.([0-9]*))?'                 + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error('Date resolve error');

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) { // milli-seconds
        fraction += '0';
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/





  // [ 64, 65, 66 ] -> [ padding, CR, LF ]
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code > 64) continue;

      // Fail on illegal characters
      if (code < 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }

    return new Uint8Array(result);
  }

  function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(obj) {
    return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
  }

  var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString$2.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      if (_toString$1.call(pair) !== '[object Object]') return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });

  /*eslint-disable max-len,no-use-before-define*/







  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? '\x00' :
          (c === 0x61/* a */) ? '\x07' :
          (c === 0x62/* b */) ? '\x08' :
          (c === 0x74/* t */) ? '\x09' :
          (c === 0x09/* Tab */) ? '\x09' :
          (c === 0x6E/* n */) ? '\x0A' :
          (c === 0x76/* v */) ? '\x0B' :
          (c === 0x66/* f */) ? '\x0C' :
          (c === 0x72/* r */) ? '\x0D' :
          (c === 0x65/* e */) ? '\x1B' :
          (c === 0x20/* Space */) ? ' ' :
          (c === 0x22/* " */) ? '\x22' :
          (c === 0x2F/* / */) ? '/' :
          (c === 0x5C/* \ */) ? '\x5C' :
          (c === 0x4E/* N */) ? '\x85' :
          (c === 0x5F/* _ */) ? '\xA0' :
          (c === 0x4C/* L */) ? '\u2028' :
          (c === 0x50/* P */) ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) >> 10) + 0xD800,
      ((c - 0x010000) & 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State$1(input, options) {
    this.input = input;

    this.filename  = options['filename']  || null;
    this.schema    = options['schema']    || _default;
    this.onWarning = options['onWarning'] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy    = options['legacy']    || false;

    this.json      = options['json']      || false;
    this.listener  = options['listener']  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    var mark = {
      name:     state.filename,
      buffer:   state.input.slice(0, -1), // omit trailing \0
      position: state.position,
      line:     state.line,
      column:   state.position - state.lineStart
    };

    mark.snippet = snippet(mark);

    return new exception(message, mark);
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, 'tag prefix is malformed: ' + prefix);
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
    startLine, startLineStart, startPos) {

    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &&
          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
          _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }

      // used for this specific key only because Object.defineProperty is slow
      if (keyNode === '__proto__') {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
        ch === state.input.charCodeAt(_position + 1) &&
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common.repeat('\n', count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* & */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* > */    ||
        ch === 0x27/* ' */    ||
        ch === 0x22/* " */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* ' */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* ' */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* " */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;

            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _lineStart,
        _pos,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = Object.create(null),
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      } else if (ch === 0x2C/* , */) {
        // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
        throwError(state, "expected the node content, but found ','");
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line; // Save the current line.
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* > */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }

      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) && (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) &&
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent < textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        }

        // Break this `while` cycle and go to the funciton's epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += ' ';
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common.repeat('\n', emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _keyLine,
        _keyLineStart,
        _keyPos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = Object.create(null),
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;

        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          // Neither implicit nor explicit notation.
          // Reading is done. Go to the epilogue.
          break;
        }

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }

        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 && ch !== 0x3E/* > */);

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, 'tag name is malformed: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;

    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* & */) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        typeList,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &&
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }

    } else if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== '!') {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];
      } else {
        // looking for multi type
        type = null;
        typeList = state.typeMap.multi[state.kind || 'fallback'];

        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }

      if (!type) {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 && !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &&
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += '\n';
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);

    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, 'null byte is not allowed in input');
    }

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load$1(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception('expected a single document in the stream, but found more');
  }


  var loadAll_1 = loadAll$1;
  var load_1    = load$1;

  var loader = {
  	loadAll: loadAll_1,
  	load: load_1
  };

  /*eslint-disable no-use-before-define*/





  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_BOM                  = 0xFEFF;
  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* & */
  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_EQUALS               = 0x3D; /* = */
  var CHAR_GREATER_THAN         = 0x3E; /* > */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = '\\0';
  ESCAPE_SEQUENCES[0x07]   = '\\a';
  ESCAPE_SEQUENCES[0x08]   = '\\b';
  ESCAPE_SEQUENCES[0x09]   = '\\t';
  ESCAPE_SEQUENCES[0x0A]   = '\\n';
  ESCAPE_SEQUENCES[0x0B]   = '\\v';
  ESCAPE_SEQUENCES[0x0C]   = '\\f';
  ESCAPE_SEQUENCES[0x0D]   = '\\r';
  ESCAPE_SEQUENCES[0x1B]   = '\\e';
  ESCAPE_SEQUENCES[0x22]   = '\\"';
  ESCAPE_SEQUENCES[0x5C]   = '\\\\';
  ESCAPE_SEQUENCES[0x85]   = '\\N';
  ESCAPE_SEQUENCES[0xA0]   = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';

  var DEPRECATED_BOOLEANS_SYNTAX = [
    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
  ];

  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }


  var QUOTING_TYPE_SINGLE = 1,
      QUOTING_TYPE_DOUBLE = 2;

  function State(options) {
    this.schema        = options['schema'] || _default;
    this.indent        = Math.max(1, (options['indent'] || 2));
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid   = options['skipInvalid'] || false;
    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys      = options['sortKeys'] || false;
    this.lineWidth     = options['lineWidth'] || 80;
    this.noRefs        = options['noRefs'] || false;
    this.noCompatMode  = options['noCompatMode'] || false;
    this.condenseFlow  = options['condenseFlow'] || false;
    this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes   = options['forceQuotes'] || false;
    this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = '';

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isnâ€™t mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 <= c && c <= 0x00007E)
        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
        ||  (0x10000 <= c && c <= 0x10FFFF);
  }

  // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // Including s-white (for some reason, examples doesn't match specs in this aspect)
  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
  function isNsCharOrWhitespace(c) {
    return isPrintable(c)
      && c !== CHAR_BOM
      // - b-char
      && c !== CHAR_CARRIAGE_RETURN
      && c !== CHAR_LINE_FEED;
  }

  // [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out
  //                             c = flow-in   â‡’ ns-plain-safe-in
  //                             c = block-key â‡’ ns-plain-safe-out
  //                             c = flow-key  â‡’ ns-plain-safe-in
  // [128] ns-plain-safe-out ::= ns-char
  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )
  //                            | ( /* An ns-char preceding */ â€œ#â€ )
  //                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      inblock ? // c = flow-in
        cIsNsCharOrWhitespace
        : cIsNsCharOrWhitespace
          // - c-flow-indicator
          && c !== CHAR_COMMA
          && c !== CHAR_LEFT_SQUARE_BRACKET
          && c !== CHAR_RIGHT_SQUARE_BRACKET
          && c !== CHAR_LEFT_CURLY_BRACKET
          && c !== CHAR_RIGHT_CURLY_BRACKET
    )
      // ns-plain-char
      && c !== CHAR_SHARP // false on '#'
      && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
      || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
      || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM
      && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€
      && c !== CHAR_MINUS
      && c !== CHAR_QUESTION
      && c !== CHAR_COLON
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ"â€
      && c !== CHAR_SHARP
      && c !== CHAR_AMPERSAND
      && c !== CHAR_ASTERISK
      && c !== CHAR_EXCLAMATION
      && c !== CHAR_VERTICAL_LINE
      && c !== CHAR_EQUALS
      && c !== CHAR_GREATER_THAN
      && c !== CHAR_SINGLE_QUOTE
      && c !== CHAR_DOUBLE_QUOTE
      // | â€œ%â€ | â€œ@â€ | â€œ`â€)
      && c !== CHAR_PERCENT
      && c !== CHAR_COMMERCIAL_AT
      && c !== CHAR_GRAVE_ACCENT;
  }

  // Simplified test for values allowed as the last character in plain style.
  function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
  }

  // Same as 'string'.codePointAt(pos), but works in older browsers.
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
    testAmbiguousType, quotingType, forceQuotes, inblock) {

    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0))
            && isPlainSafeLast(codePointAt(string, string.length - 1));

    if (singleLineOnly || forceQuotes) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 > lineWidth &&
               string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
        (i - previousLineBreak - 1 > lineWidth &&
         string[previousLineBreak + 1] !== ' '));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    â€¢ No ending newline => unaffected; already using strip "-" chomping.
  //    â€¢ Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function () {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
        }
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
        testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception('impossible error: invalid scalar style');
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip =          string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');

    return indentIndicator + chomp + '\n';
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix
        + (!prevMoreIndented && !moreIndented && line !== ''
          ? '\n' : '')
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;

    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';

    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start <= width
      if (next - start > width) {
        end = (curr > start) ? curr : next; // derive end <= length-2
        result += '\n' + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start <= length-1
      }
      curr = next;
    }

    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = '';
    var char = 0;
    var escapeSeq;

    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];

      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 0x10000) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level, value, false, false) ||
          (typeof value === 'undefined' &&
           writeNode(state, level, null, false, false))) {

        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level + 1, value, true, true, false, true) ||
          (typeof value === 'undefined' &&
           writeNode(state, level + 1, null, true, true, false, true))) {

        if (!compact || _result !== '') {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {

      pairBuffer = '';
      if (_result !== '') pairBuffer += ', ';

      if (state.condenseFlow) pairBuffer += '"';

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';

      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || _result !== '') {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null && state.tag !== '?') ||
                     (state.dump && state.dump.length > 1024);

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &&
          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
          (!type.predicate  || type.predicate(object))) {

        if (explicit) {
          if (type.multi && type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = '?';
        }

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;

    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        if (block && (state.dump.length !== 0)) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === '[object Undefined]') {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        // Need to encode all characters except those allowed by the spec:
        //
        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
        // [36] ns-hex-digit    ::=  ns-dec-digit
        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€
        // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€
        //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€
        //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€
        //
        // Also need to encode '!' because it has special meaning (end of tag prefix).
        //
        tagStr = encodeURI(
          state.tag[0] === '!' ? state.tag.slice(1) : state.tag
        ).replace(/!/g, '%21');

        if (state.tag[0] === '!') {
          tagStr = '!' + tagStr;
        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
          tagStr = '!!' + tagStr.slice(18);
        } else {
          tagStr = '!<' + tagStr + '>';
        }

        state.dump = tagStr + ' ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump$1(input, options) {
    options = options || {};

    var state = new State(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    var value = input;

    if (state.replacer) {
      value = state.replacer.call({ '': value }, '', value);
    }

    if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

    return '';
  }

  var dump_1 = dump$1;

  var dumper = {
  	dump: dump_1
  };

  function renamed(from, to) {
    return function () {
      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
        'Use yaml.' + to + ' instead, which is now safe by default.');
    };
  }


  var Type                = type;
  var Schema              = schema;
  var FAILSAFE_SCHEMA     = failsafe;
  var JSON_SCHEMA         = json;
  var CORE_SCHEMA         = core;
  var DEFAULT_SCHEMA      = _default;
  var load                = loader.load;
  var loadAll             = loader.loadAll;
  var dump                = dumper.dump;
  var YAMLException       = exception;

  // Re-export all types in case user wants to create custom schema
  var types = {
    binary:    binary,
    float:     float,
    map:       map,
    null:      _null,
    pairs:     pairs,
    set:       set,
    timestamp: timestamp,
    bool:      bool,
    int:       int,
    merge:     merge,
    omap:      omap,
    seq:       seq,
    str:       str
  };

  // Removed functions from JS-YAML 3.0.x
  var safeLoad            = renamed('safeLoad', 'load');
  var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
  var safeDump            = renamed('safeDump', 'dump');

  var jsYaml = {
  	Type: Type,
  	Schema: Schema,
  	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  	JSON_SCHEMA: JSON_SCHEMA,
  	CORE_SCHEMA: CORE_SCHEMA,
  	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  	load: load,
  	loadAll: loadAll,
  	dump: dump,
  	YAMLException: YAMLException,
  	types: types,
  	safeLoad: safeLoad,
  	safeLoadAll: safeLoadAll,
  	safeDump: safeDump
  };

  exports.CORE_SCHEMA = CORE_SCHEMA;
  exports.DEFAULT_SCHEMA = DEFAULT_SCHEMA;
  exports.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;
  exports.JSON_SCHEMA = JSON_SCHEMA;
  exports.Schema = Schema;
  exports.Type = Type;
  exports.YAMLException = YAMLException;
  exports.default = jsYaml;
  exports.dump = dump;
  exports.load = load;
  exports.loadAll = loadAll;
  exports.safeDump = safeDump;
  exports.safeLoad = safeLoad;
  exports.safeLoadAll = safeLoadAll;
  exports.types = types;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
'use strict';


var loader = require('./lib/loader');
var dumper = require('./lib/dumper');


function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


module.exports.Type                = require('./lib/type');
module.exports.Schema              = require('./lib/schema');
module.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./lib/schema/json');
module.exports.CORE_SCHEMA         = require('./lib/schema/core');
module.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.dump                = dumper.dump;
module.exports.YAMLException       = require('./lib/exception');

// Re-export all types in case user wants to create custom schema
module.exports.types = {
  binary:    require('./lib/type/binary'),
  float:     require('./lib/type/float'),
  map:       require('./lib/type/map'),
  null:      require('./lib/type/null'),
  pairs:     require('./lib/type/pairs'),
  set:       require('./lib/type/set'),
  timestamp: require('./lib/type/timestamp'),
  bool:      require('./lib/type/bool'),
  int:       require('./lib/type/int'),
  merge:     require('./lib/type/merge'),
  omap:      require('./lib/type/omap'),
  seq:       require('./lib/type/seq'),
  str:       require('./lib/type/str')
};

// Removed functions from JS-YAML 3.0.x
module.exports.safeLoad            = renamed('safeLoad', 'load');
module.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');
module.exports.safeDump            = renamed('safeDump', 'dump');
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_SCHEMA      = require('./schema/default');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || DEFAULT_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnâ€™t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out
//                             c = flow-in   â‡’ ns-plain-safe-in
//                             c = block-key â‡’ ns-plain-safe-out
//                             c = flow-key  â‡’ ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )
//                            | ( /* An ns-char preceding */ â€œ#â€ )
//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ"â€
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | â€œ%â€ | â€œ@â€ | â€œ`â€)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    â€¢ No ending newline => unaffected; already using strip "-" chomping.
//    â€¢ Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€
      // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€
      //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€
      //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

module.exports.dump = dump;
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;
'use strict';


var common = require('./common');


// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, 'â†’') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


module.exports = makeSnippet;
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});
'use strict';

/*eslint-disable no-bitwise*/


var Type = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


module.exports = require('./json');
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


module.exports = require('./core').extend({
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


module.exports = require('./failsafe').extend({
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var makeSnippet         = require('./snippet');
var DEFAULT_SCHEMA      = require('./schema/default');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


module.exports.loadAll = loadAll;
module.exports.load    = load;
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


module.exports = YAMLException;
'use strict';

/*eslint-disable max-len*/

var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  return this.extend(definition);
}


Schema.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof Type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type.multi) {
      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


module.exports = Schema;
(The MIT License)

Copyright (C) 2011-2015 by Vitaly Puzrin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
{
  "name": "js-yaml",
  "version": "4.1.0",
  "description": "YAML 1.2 parser and serializer",
  "keywords": [
    "yaml",
    "parser",
    "serializer",
    "pyyaml"
  ],
  "author": "Vladimir Zapparov <dervus.grim@gmail.com>",
  "contributors": [
    "Aleksey V Zapparov <ixti@member.fsf.org> (http://www.ixti.net/)",
    "Vitaly Puzrin <vitaly@rcdesign.ru> (https://github.com/puzrin)",
    "Martin Grenfell <martin.grenfell@gmail.com> (http://got-ravings.blogspot.com)"
  ],
  "license": "MIT",
  "repository": "nodeca/js-yaml",
  "files": [
    "index.js",
    "lib/",
    "bin/",
    "dist/"
  ],
  "bin": {
    "js-yaml": "bin/js-yaml.js"
  },
  "module": "./dist/js-yaml.mjs",
  "exports": {
    ".": {
      "import": "./dist/js-yaml.mjs",
      "require": "./index.js"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "lint": "eslint .",
    "test": "npm run lint && mocha",
    "coverage": "npm run lint && nyc mocha && nyc report --reporter html",
    "demo": "npm run lint && node support/build_demo.js",
    "gh-demo": "npm run demo && gh-pages -d demo -f",
    "browserify": "rollup -c support/rollup.config.js",
    "prepublishOnly": "npm run gh-demo"
  },
  "unpkg": "dist/js-yaml.min.js",
  "jsdelivr": "dist/js-yaml.min.js",
  "dependencies": {
    "argparse": "^2.0.1"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^17.0.0",
    "@rollup/plugin-node-resolve": "^11.0.0",
    "ansi": "^0.3.1",
    "benchmark": "^2.1.4",
    "codemirror": "^5.13.4",
    "eslint": "^7.0.0",
    "fast-check": "^2.8.0",
    "gh-pages": "^3.1.0",
    "mocha": "^8.2.1",
    "nyc": "^15.1.0",
    "rollup": "^2.34.1",
    "rollup-plugin-node-polyfills": "^0.2.1",
    "rollup-plugin-terser": "^7.0.2",
    "shelljs": "^0.8.4"
  }
}
JS-YAML - YAML 1.2 parser / writer for JavaScript
=================================================

[![CI](https://github.com/nodeca/js-yaml/workflows/CI/badge.svg?branch=master)](https://github.com/nodeca/js-yaml/actions)
[![NPM version](https://img.shields.io/npm/v/js-yaml.svg)](https://www.npmjs.org/package/js-yaml)

__[Online Demo](http://nodeca.github.com/js-yaml/)__


This is an implementation of [YAML](http://yaml.org/), a human-friendly data
serialization language. Started as [PyYAML](http://pyyaml.org/) port, it was
completely rewritten from scratch. Now it's very fast, and supports 1.2 spec.


Installation
------------

### YAML module for node.js

```
npm install js-yaml
```


### CLI executable

If you want to inspect your YAML files from CLI, install js-yaml globally:

```
npm install -g js-yaml
```

#### Usage

```
usage: js-yaml [-h] [-v] [-c] [-t] file

Positional arguments:
  file           File with YAML document(s)

Optional arguments:
  -h, --help     Show this help message and exit.
  -v, --version  Show program's version number and exit.
  -c, --compact  Display errors in compact mode
  -t, --trace    Show stack trace on error
```


API
---

Here we cover the most 'useful' methods. If you need advanced details (creating
your own tags), see [examples](https://github.com/nodeca/js-yaml/tree/master/examples)
for more info.

``` javascript
const yaml = require('js-yaml');
const fs   = require('fs');

// Get document, or throw exception on error
try {
  const doc = yaml.load(fs.readFileSync('/home/ixti/example.yml', 'utf8'));
  console.log(doc);
} catch (e) {
  console.log(e);
}
```


### load (string [ , options ])

Parses `string` as single YAML document. Returns either a
plain object, a string, a number, `null` or `undefined`, or throws `YAMLException` on error. By default, does
not support regexps, functions and undefined.

options:

- `filename` _(default: null)_ - string to be used as a file path in
  error/warning messages.
- `onWarning` _(default: null)_ - function to call on warning messages.
  Loader will call this function with an instance of `YAMLException` for each warning.
- `schema` _(default: `DEFAULT_SCHEMA`)_ - specifies a schema to use.
  - `FAILSAFE_SCHEMA` - only strings, arrays and plain objects:
    http://www.yaml.org/spec/1.2/spec.html#id2802346
  - `JSON_SCHEMA` - all JSON-supported types:
    http://www.yaml.org/spec/1.2/spec.html#id2803231
  - `CORE_SCHEMA` - same as `JSON_SCHEMA`:
    http://www.yaml.org/spec/1.2/spec.html#id2804923
  - `DEFAULT_SCHEMA` - all supported YAML types.
- `json` _(default: false)_ - compatibility with JSON.parse behaviour. If true, then duplicate keys in a mapping will override values rather than throwing an error.

NOTE: This function **does not** understand multi-document sources, it throws
exception on those.

NOTE: JS-YAML **does not** support schema-specific tag resolution restrictions.
So, the JSON schema is not as strictly defined in the YAML specification.
It allows numbers in any notation, use `Null` and `NULL` as `null`, etc.
The core schema also has no such restrictions. It allows binary notation for integers.


### loadAll (string [, iterator] [, options ])

Same as `load()`, but understands multi-document sources. Applies
`iterator` to each document if specified, or returns array of documents.

``` javascript
const yaml = require('js-yaml');

yaml.loadAll(data, function (doc) {
  console.log(doc);
});
```


### dump (object [ , options ])

Serializes `object` as a YAML document. Uses `DEFAULT_SCHEMA`, so it will
throw an exception if you try to dump regexps or functions. However, you can
disable exceptions by setting the `skipInvalid` option to `true`.

options:

- `indent` _(default: 2)_ - indentation width to use (in spaces).
- `noArrayIndent` _(default: false)_ - when true, will not add an indentation level to array elements
- `skipInvalid` _(default: false)_ - do not throw on invalid types (like function
  in the safe schema) and skip pairs and single values with such types.
- `flowLevel` _(default: -1)_ - specifies level of nesting, when to switch from
  block to flow style for collections. -1 means block style everwhere
- `styles` - "tag" => "style" map. Each tag may have own set of styles.
- `schema` _(default: `DEFAULT_SCHEMA`)_ specifies a schema to use.
- `sortKeys` _(default: `false`)_ - if `true`, sort keys when dumping YAML. If a
  function, use the function to sort the keys.
- `lineWidth` _(default: `80`)_ - set max line width. Set `-1` for unlimited width.
- `noRefs` _(default: `false`)_ - if `true`, don't convert duplicate objects into references
- `noCompatMode` _(default: `false`)_ - if `true` don't try to be compatible with older
  yaml versions. Currently: don't quote "yes", "no" and so on, as required for YAML 1.1
- `condenseFlow` _(default: `false`)_ - if `true` flow sequences will be condensed, omitting the space between `a, b`. Eg. `'[a,b]'`, and omitting the space between `key: value` and quoting the key. Eg. `'{"a":b}'` Can be useful when using yaml for pretty URL query params as spaces are %-encoded.
- `quotingType` _(`'` or `"`, default: `'`)_ - strings will be quoted using this quoting style. If you specify single quotes, double quotes will still be used for non-printable characters.
- `forceQuotes` _(default: `false`)_ - if `true`, all non-key strings will be quoted even if they normally don't need to.
- `replacer` - callback `function (key, value)` called recursively on each key/value in source object (see `replacer` docs for `JSON.stringify`).

The following table show availlable styles (e.g. "canonical",
"binary"...) available for each tag (.e.g. !!null, !!int ...). Yaml
output is shown on the right side after `=>` (default setting) or `->`:

``` none
!!null
  "canonical"   -> "~"
  "lowercase"   => "null"
  "uppercase"   -> "NULL"
  "camelcase"   -> "Null"

!!int
  "binary"      -> "0b1", "0b101010", "0b1110001111010"
  "octal"       -> "0o1", "0o52", "0o16172"
  "decimal"     => "1", "42", "7290"
  "hexadecimal" -> "0x1", "0x2A", "0x1C7A"

!!bool
  "lowercase"   => "true", "false"
  "uppercase"   -> "TRUE", "FALSE"
  "camelcase"   -> "True", "False"

!!float
  "lowercase"   => ".nan", '.inf'
  "uppercase"   -> ".NAN", '.INF'
  "camelcase"   -> ".NaN", '.Inf'
```

Example:

``` javascript
dump(object, {
  'styles': {
    '!!null': 'canonical' // dump null as ~
  },
  'sortKeys': true        // sort object keys
});
```

Supported YAML types
--------------------

The list of standard YAML tags and corresponding JavaScript types. See also
[YAML tag discussion](http://pyyaml.org/wiki/YAMLTagDiscussion) and
[YAML types repository](http://yaml.org/type/).

```
!!null ''                   # null
!!bool 'yes'                # bool
!!int '3...'                # number
!!float '3.14...'           # number
!!binary '...base64...'     # buffer
!!timestamp 'YYYY-...'      # date
!!omap [ ... ]              # array of key-value pairs
!!pairs [ ... ]             # array or array pairs
!!set { ... }               # array of objects with given keys and null values
!!str '...'                 # string
!!seq [ ... ]               # array
!!map { ... }               # object
```

**JavaScript-specific tags**

See [js-yaml-js-types](https://github.com/nodeca/js-yaml-js-types) for
extra types.


Caveats
-------

Note, that you use arrays or objects as key in JS-YAML. JS does not allow objects
or arrays as keys, and stringifies (by calling `toString()` method) them at the
moment of adding them.

``` yaml
---
? [ foo, bar ]
: - baz
? { foo: bar }
: - baz
  - baz
```

``` javascript
{ "foo,bar": ["baz"], "[object Object]": ["baz", "baz"] }
```

Also, reading of properties on implicit block mapping keys is not supported yet.
So, the following YAML document cannot be loaded.

``` yaml
&anchor foo:
  foo: bar
  *anchor: duplicate key
  baz: bat
  *anchor: duplicate key
```


js-yaml for enterprise
----------------------

Available as part of the Tidelift Subscription

The maintainers of js-yaml and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-js-yaml?utm_source=npm-js-yaml&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)
#!/usr/bin/env node


'use strict';

/*eslint-disable no-console*/


var fs       = require('fs');
var argparse = require('argparse');
var yaml     = require('..');


////////////////////////////////////////////////////////////////////////////////


var cli = new argparse.ArgumentParser({
  prog:     'js-yaml',
  add_help:  true
});

cli.add_argument('-v', '--version', {
  action: 'version',
  version: require('../package.json').version
});

cli.add_argument('-c', '--compact', {
  help:   'Display errors in compact mode',
  action: 'store_true'
});

// deprecated (not needed after we removed output colors)
// option suppressed, but not completely removed for compatibility
cli.add_argument('-j', '--to-json', {
  help:   argparse.SUPPRESS,
  dest:   'json',
  action: 'store_true'
});

cli.add_argument('-t', '--trace', {
  help:   'Show stack trace on error',
  action: 'store_true'
});

cli.add_argument('file', {
  help:   'File to read, utf-8 encoded without BOM',
  nargs:  '?',
  default: '-'
});


////////////////////////////////////////////////////////////////////////////////


var options = cli.parse_args();


////////////////////////////////////////////////////////////////////////////////

function readFile(filename, encoding, callback) {
  if (options.file === '-') {
    // read from stdin

    var chunks = [];

    process.stdin.on('data', function (chunk) {
      chunks.push(chunk);
    });

    process.stdin.on('end', function () {
      return callback(null, Buffer.concat(chunks).toString(encoding));
    });
  } else {
    fs.readFile(filename, encoding, callback);
  }
}

readFile(options.file, 'utf8', function (error, input) {
  var output, isYaml;

  if (error) {
    if (error.code === 'ENOENT') {
      console.error('File not found: ' + options.file);
      process.exit(2);
    }

    console.error(
      options.trace && error.stack ||
      error.message ||
      String(error));

    process.exit(1);
  }

  try {
    output = JSON.parse(input);
    isYaml = false;
  } catch (err) {
    if (err instanceof SyntaxError) {
      try {
        output = [];
        yaml.loadAll(input, function (doc) { output.push(doc); }, {});
        isYaml = true;

        if (output.length === 0) output = null;
        else if (output.length === 1) output = output[0];

      } catch (e) {
        if (options.trace && err.stack) console.error(e.stack);
        else console.error(e.toString(options.compact));

        process.exit(1);
      }
    } else {
      console.error(
        options.trace && err.stack ||
        err.message ||
        String(err));

      process.exit(1);
    }
  }

  if (isYaml) console.log(JSON.stringify(output, null, '  '));
  else console.log(yaml.dump(output));
});
{
  "name": "test",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    }
  }
}
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).


## [2.0.1] - 2020-08-29
### Fixed
- Fix issue with `process.argv` when used with interpreters (`coffee`, `ts-node`, etc.), #150.


## [2.0.0] - 2020-08-14
### Changed
- Full rewrite. Now port from python 3.9.0 & more precise following.
  See [doc](./doc) for difference and migration info.
- node.js 10+ required
- Removed most of local docs in favour of original ones.


## [1.0.10] - 2018-02-15
### Fixed
- Use .concat instead of + for arrays, #122.


## [1.0.9] - 2016-09-29
### Changed
- Rerelease after 1.0.8 - deps cleanup.


## [1.0.8] - 2016-09-29
### Changed
- Maintenance (deps bump, fix node 6.5+ tests, coverage report).


## [1.0.7] - 2016-03-17
### Changed
- Teach `addArgument` to accept string arg names. #97, @tomxtobin.


## [1.0.6] - 2016-02-06
### Changed
- Maintenance: moved to eslint & updated CS.


## [1.0.5] - 2016-02-05
### Changed
- Removed lodash dependency to significantly reduce install size.
  Thanks to @mourner.


## [1.0.4] - 2016-01-17
### Changed
- Maintenance: lodash update to 4.0.0.


## [1.0.3] - 2015-10-27
### Fixed
- Fix parse `=` in args: `--examplepath="C:\myfolder\env=x64"`. #84, @CatWithApple.


## [1.0.2] - 2015-03-22
### Changed
- Relaxed lodash version dependency.


## [1.0.1] - 2015-02-20
### Changed
- Changed dependencies to be compatible with ancient nodejs.


## [1.0.0] - 2015-02-19
### Changed
- Maintenance release.
- Replaced `underscore` with `lodash`.
- Bumped version to 1.0.0 to better reflect semver meaning.
- HISTORY.md -> CHANGELOG.md


## [0.1.16] - 2013-12-01
### Changed
- Maintenance release. Updated dependencies and docs.


## [0.1.15] - 2013-05-13
### Fixed
- Fixed #55, @trebor89


## [0.1.14] - 2013-05-12
### Fixed
- Fixed #62, @maxtaco


## [0.1.13] - 2013-04-08
### Changed
- Added `.npmignore` to reduce package size


## [0.1.12] - 2013-02-10
### Fixed
- Fixed conflictHandler (#46), @hpaulj


## [0.1.11] - 2013-02-07
### Added
- Added 70+ tests (ported from python), @hpaulj
- Added conflictHandler, @applepicke
- Added fromfilePrefixChar, @hpaulj

### Fixed
- Multiple bugfixes, @hpaulj


## [0.1.10] - 2012-12-30
### Added
- Added [mutual exclusion](http://docs.python.org/dev/library/argparse.html#mutual-exclusion)
  support, thanks to @hpaulj

### Fixed
- Fixed options check for `storeConst` & `appendConst` actions, thanks to @hpaulj


## [0.1.9] - 2012-12-27
### Fixed
- Fixed option dest interferens with other options (issue #23), thanks to @hpaulj
- Fixed default value behavior with `*` positionals, thanks to @hpaulj
- Improve `getDefault()` behavior, thanks to @hpaulj
- Improve negative argument parsing, thanks to @hpaulj


## [0.1.8] - 2012-12-01
### Fixed
- Fixed parser parents (issue #19), thanks to @hpaulj
- Fixed negative argument parse (issue #20), thanks to @hpaulj


## [0.1.7] - 2012-10-14
### Fixed
- Fixed 'choices' argument parse (issue #16)
- Fixed stderr output (issue #15)


## [0.1.6] - 2012-09-09
### Fixed
- Fixed check for conflict of options (thanks to @tomxtobin)


## [0.1.5] - 2012-09-03
### Fixed
- Fix parser #setDefaults method (thanks to @tomxtobin)


## [0.1.4] - 2012-07-30
### Fixed
- Fixed pseudo-argument support (thanks to @CGamesPlay)
- Fixed addHelp default (should be true), if not set (thanks to @benblank)


## [0.1.3] - 2012-06-27
### Fixed
- Fixed formatter api name: Formatter -> HelpFormatter


## [0.1.2] - 2012-05-29
### Fixed
- Removed excess whitespace in help
- Fixed error reporting, when parcer with subcommands
  called with empty arguments

### Added
- Added basic tests


## [0.1.1] - 2012-05-23
### Fixed
- Fixed line wrapping in help formatter
- Added better error reporting on invalid arguments


## [0.1.0] - 2012-05-16
### Added
- First release.


[2.0.1]: https://github.com/nodeca/argparse/compare/2.0.0...2.0.1
[2.0.0]: https://github.com/nodeca/argparse/compare/1.0.10...2.0.0
[1.0.10]: https://github.com/nodeca/argparse/compare/1.0.9...1.0.10
[1.0.9]: https://github.com/nodeca/argparse/compare/1.0.8...1.0.9
[1.0.8]: https://github.com/nodeca/argparse/compare/1.0.7...1.0.8
[1.0.7]: https://github.com/nodeca/argparse/compare/1.0.6...1.0.7
[1.0.6]: https://github.com/nodeca/argparse/compare/1.0.5...1.0.6
[1.0.5]: https://github.com/nodeca/argparse/compare/1.0.4...1.0.5
[1.0.4]: https://github.com/nodeca/argparse/compare/1.0.3...1.0.4
[1.0.3]: https://github.com/nodeca/argparse/compare/1.0.2...1.0.3
[1.0.2]: https://github.com/nodeca/argparse/compare/1.0.1...1.0.2
[1.0.1]: https://github.com/nodeca/argparse/compare/1.0.0...1.0.1
[1.0.0]: https://github.com/nodeca/argparse/compare/0.1.16...1.0.0
[0.1.16]: https://github.com/nodeca/argparse/compare/0.1.15...0.1.16
[0.1.15]: https://github.com/nodeca/argparse/compare/0.1.14...0.1.15
[0.1.14]: https://github.com/nodeca/argparse/compare/0.1.13...0.1.14
[0.1.13]: https://github.com/nodeca/argparse/compare/0.1.12...0.1.13
[0.1.12]: https://github.com/nodeca/argparse/compare/0.1.11...0.1.12
[0.1.11]: https://github.com/nodeca/argparse/compare/0.1.10...0.1.11
[0.1.10]: https://github.com/nodeca/argparse/compare/0.1.9...0.1.10
[0.1.9]: https://github.com/nodeca/argparse/compare/0.1.8...0.1.9
[0.1.8]: https://github.com/nodeca/argparse/compare/0.1.7...0.1.8
[0.1.7]: https://github.com/nodeca/argparse/compare/0.1.6...0.1.7
[0.1.6]: https://github.com/nodeca/argparse/compare/0.1.5...0.1.6
[0.1.5]: https://github.com/nodeca/argparse/compare/0.1.4...0.1.5
[0.1.4]: https://github.com/nodeca/argparse/compare/0.1.3...0.1.4
[0.1.3]: https://github.com/nodeca/argparse/compare/0.1.2...0.1.3
[0.1.2]: https://github.com/nodeca/argparse/compare/0.1.1...0.1.2
[0.1.1]: https://github.com/nodeca/argparse/compare/0.1.0...0.1.1
[0.1.0]: https://github.com/nodeca/argparse/releases/tag/0.1.0
// Limited implementation of python % string operator, supports only %s and %r for now
// (other formats are not used here, but may appear in custom templates)

'use strict'

const { inspect } = require('util')


module.exports = function sub(pattern, ...values) {
    let regex = /%(?:(%)|(-)?(\*)?(?:\((\w+)\))?([A-Za-z]))/g

    let result = pattern.replace(regex, function (_, is_literal, is_left_align, is_padded, name, format) {
        if (is_literal) return '%'

        let padded_count = 0
        if (is_padded) {
            if (values.length === 0) throw new TypeError('not enough arguments for format string')
            padded_count = values.shift()
            if (!Number.isInteger(padded_count)) throw new TypeError('* wants int')
        }

        let str
        if (name !== undefined) {
            let dict = values[0]
            if (typeof dict !== 'object' || dict === null) throw new TypeError('format requires a mapping')
            if (!(name in dict)) throw new TypeError(`no such key: '${name}'`)
            str = dict[name]
        } else {
            if (values.length === 0) throw new TypeError('not enough arguments for format string')
            str = values.shift()
        }

        switch (format) {
            case 's':
                str = String(str)
                break
            case 'r':
                str = inspect(str)
                break
            case 'd':
            case 'i':
                if (typeof str !== 'number') {
                    throw new TypeError(`%${format} format: a number is required, not ${typeof str}`)
                }
                str = String(str.toFixed(0))
                break
            default:
                throw new TypeError(`unsupported format character '${format}'`)
        }

        if (padded_count > 0) {
            return is_left_align ? str.padEnd(padded_count) : str.padStart(padded_count)
        } else {
            return str
        }
    })

    if (values.length) {
        if (values.length === 1 && typeof values[0] === 'object' && values[0] !== null) {
            // mapping
        } else {
            throw new TypeError('not all arguments converted during string formatting')
        }
    }

    return result
}
// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):
// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py

'use strict'

/*
 * Text wrapping and filling.
 */

// Copyright (C) 1999-2001 Gregory P. Ward.
// Copyright (C) 2002, 2003 Python Software Foundation.
// Copyright (C) 2020 argparse.js authors
// Originally written by Greg Ward <gward@python.net>

// Hardcode the recognized whitespace characters to the US-ASCII
// whitespace characters.  The main reason for doing this is that
// some Unicode spaces (like \u00a0) are non-breaking whitespaces.
//
// This less funky little regex just split on recognized spaces. E.g.
//   "Hello there -- you goof-ball, use the -b option!"
// splits into
//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/
const wordsep_simple_re = /([\t\n\x0b\x0c\r ]+)/

class TextWrapper {
    /*
     *  Object for wrapping/filling text.  The public interface consists of
     *  the wrap() and fill() methods; the other methods are just there for
     *  subclasses to override in order to tweak the default behaviour.
     *  If you want to completely replace the main wrapping algorithm,
     *  you'll probably have to override _wrap_chunks().
     *
     *  Several instance attributes control various aspects of wrapping:
     *    width (default: 70)
     *      the maximum width of wrapped lines (unless break_long_words
     *      is false)
     *    initial_indent (default: "")
     *      string that will be prepended to the first line of wrapped
     *      output.  Counts towards the line's width.
     *    subsequent_indent (default: "")
     *      string that will be prepended to all lines save the first
     *      of wrapped output; also counts towards each line's width.
     *    expand_tabs (default: true)
     *      Expand tabs in input text to spaces before further processing.
     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position
     *      in its line.  If false, each tab is treated as a single character.
     *    tabsize (default: 8)
     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless
     *      'expand_tabs' is false.
     *    replace_whitespace (default: true)
     *      Replace all whitespace characters in the input text by spaces
     *      after tab expansion.  Note that if expand_tabs is false and
     *      replace_whitespace is true, every tab will be converted to a
     *      single space!
     *    fix_sentence_endings (default: false)
     *      Ensure that sentence-ending punctuation is always followed
     *      by two spaces.  Off by default because the algorithm is
     *      (unavoidably) imperfect.
     *    break_long_words (default: true)
     *      Break words longer than 'width'.  If false, those words will not
     *      be broken, and some lines might be longer than 'width'.
     *    break_on_hyphens (default: true)
     *      Allow breaking hyphenated words. If true, wrapping will occur
     *      preferably on whitespaces and right after hyphens part of
     *      compound words.
     *    drop_whitespace (default: true)
     *      Drop leading and trailing whitespace from lines.
     *    max_lines (default: None)
     *      Truncate wrapped lines.
     *    placeholder (default: ' [...]')
     *      Append to the last line of truncated text.
     */

    constructor(options = {}) {
        let {
            width = 70,
            initial_indent = '',
            subsequent_indent = '',
            expand_tabs = true,
            replace_whitespace = true,
            fix_sentence_endings = false,
            break_long_words = true,
            drop_whitespace = true,
            break_on_hyphens = true,
            tabsize = 8,
            max_lines = undefined,
            placeholder=' [...]'
        } = options

        this.width = width
        this.initial_indent = initial_indent
        this.subsequent_indent = subsequent_indent
        this.expand_tabs = expand_tabs
        this.replace_whitespace = replace_whitespace
        this.fix_sentence_endings = fix_sentence_endings
        this.break_long_words = break_long_words
        this.drop_whitespace = drop_whitespace
        this.break_on_hyphens = break_on_hyphens
        this.tabsize = tabsize
        this.max_lines = max_lines
        this.placeholder = placeholder
    }


    // -- Private methods -----------------------------------------------
    // (possibly useful for subclasses to override)

    _munge_whitespace(text) {
        /*
         *  _munge_whitespace(text : string) -> string
         *
         *  Munge whitespace in text: expand tabs and convert all other
         *  whitespace characters to spaces.  Eg. " foo\\tbar\\n\\nbaz"
         *  becomes " foo    bar  baz".
         */
        if (this.expand_tabs) {
            text = text.replace(/\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js
        }
        if (this.replace_whitespace) {
            text = text.replace(/[\t\n\x0b\x0c\r]/g, ' ')
        }
        return text
    }

    _split(text) {
        /*
         *  _split(text : string) -> [string]
         *
         *  Split the text to wrap into indivisible chunks.  Chunks are
         *  not quite the same as words; see _wrap_chunks() for full
         *  details.  As an example, the text
         *    Look, goof-ball -- use the -b option!
         *  breaks into the following chunks:
         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',
         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'
         *  if break_on_hyphens is True, or in:
         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',
         *    'use', ' ', 'the', ' ', '-b', ' ', option!'
         *  otherwise.
         */
        let chunks = text.split(wordsep_simple_re)
        chunks = chunks.filter(Boolean)
        return chunks
    }

    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {
        /*
         *  _handle_long_word(chunks : [string],
         *                    cur_line : [string],
         *                    cur_len : int, width : int)
         *
         *  Handle a chunk of text (most likely a word, not whitespace) that
         *  is too long to fit in any line.
         */
        // Figure out when indent is larger than the specified width, and make
        // sure at least one character is stripped off on every pass
        let space_left
        if (width < 1) {
            space_left = 1
        } else {
            space_left = width - cur_len
        }

        // If we're allowed to break long words, then do so: put as much
        // of the next chunk onto the current line as will fit.
        if (this.break_long_words) {
            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))
            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)

        // Otherwise, we have to preserve the long word intact.  Only add
        // it to the current line if there's nothing already there --
        // that minimizes how much we violate the width constraint.
        } else if (!cur_line) {
            cur_line.push(...reversed_chunks.pop())
        }

        // If we're not allowed to break long words, and there's already
        // text on the current line, do nothing.  Next time through the
        // main loop of _wrap_chunks(), we'll wind up here again, but
        // cur_len will be zero, so the next line will be entirely
        // devoted to the long word that we can't handle right now.
    }

    _wrap_chunks(chunks) {
        /*
         *  _wrap_chunks(chunks : [string]) -> [string]
         *
         *  Wrap a sequence of text chunks and return a list of lines of
         *  length 'self.width' or less.  (If 'break_long_words' is false,
         *  some lines may be longer than this.)  Chunks correspond roughly
         *  to words and the whitespace between them: each chunk is
         *  indivisible (modulo 'break_long_words'), but a line break can
         *  come between any two chunks.  Chunks should not have internal
         *  whitespace; ie. a chunk is either all whitespace or a "word".
         *  Whitespace chunks will be removed from the beginning and end of
         *  lines, but apart from that whitespace is preserved.
         */
        let lines = []
        let indent
        if (this.width <= 0) {
            throw Error(`invalid width ${this.width} (must be > 0)`)
        }
        if (this.max_lines !== undefined) {
            if (this.max_lines > 1) {
                indent = this.subsequent_indent
            } else {
                indent = this.initial_indent
            }
            if (indent.length + this.placeholder.trimStart().length > this.width) {
                throw Error('placeholder too large for max width')
            }
        }

        // Arrange in reverse order so items can be efficiently popped
        // from a stack of chucks.
        chunks = chunks.reverse()

        while (chunks.length > 0) {

            // Start the list of chunks that will make up the current line.
            // cur_len is just the length of all the chunks in cur_line.
            let cur_line = []
            let cur_len = 0

            // Figure out which static string will prefix this line.
            let indent
            if (lines) {
                indent = this.subsequent_indent
            } else {
                indent = this.initial_indent
            }

            // Maximum width for this line.
            let width = this.width - indent.length

            // First chunk on line is whitespace -- drop it, unless this
            // is the very beginning of the text (ie. no lines started yet).
            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {
                chunks.pop()
            }

            while (chunks.length > 0) {
                let l = chunks[chunks.length - 1].length

                // Can at least squeeze this chunk onto the current line.
                if (cur_len + l <= width) {
                    cur_line.push(chunks.pop())
                    cur_len += l

                // Nope, this line is full.
                } else {
                    break
                }
            }

            // The current line is full, and the next chunk is too big to
            // fit on *any* line (not just this one).
            if (chunks.length && chunks[chunks.length - 1].length > width) {
                this._handle_long_word(chunks, cur_line, cur_len, width)
                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)
            }

            // If the last chunk on this line is all whitespace, drop it.
            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {
                cur_len -= cur_line[cur_line.length - 1].length
                cur_line.pop()
            }

            if (cur_line) {
                if (this.max_lines === undefined ||
                    lines.length + 1 < this.max_lines ||
                    (chunks.length === 0 ||
                     this.drop_whitespace &&
                     chunks.length === 1 &&
                     !chunks[0].trim()) && cur_len <= width) {
                    // Convert current line back to a string and store it in
                    // list of all lines (return value).
                    lines.push(indent + cur_line.join(''))
                } else {
                    let had_break = false
                    while (cur_line) {
                        if (cur_line[cur_line.length - 1].trim() &&
                            cur_len + this.placeholder.length <= width) {
                            cur_line.push(this.placeholder)
                            lines.push(indent + cur_line.join(''))
                            had_break = true
                            break
                        }
                        cur_len -= cur_line[-1].length
                        cur_line.pop()
                    }
                    if (!had_break) {
                        if (lines) {
                            let prev_line = lines[lines.length - 1].trimEnd()
                            if (prev_line.length + this.placeholder.length <=
                                    this.width) {
                                lines[lines.length - 1] = prev_line + this.placeholder
                                break
                            }
                        }
                        lines.push(indent + this.placeholder.lstrip())
                    }
                    break
                }
            }
        }

        return lines
    }

    _split_chunks(text) {
        text = this._munge_whitespace(text)
        return this._split(text)
    }

    // -- Public interface ----------------------------------------------

    wrap(text) {
        /*
         *  wrap(text : string) -> [string]
         *
         *  Reformat the single paragraph in 'text' so it fits in lines of
         *  no more than 'self.width' columns, and return a list of wrapped
         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),
         *  and all other whitespace characters (including newline) are
         *  converted to space.
         */
        let chunks = this._split_chunks(text)
        // not implemented in js
        //if (this.fix_sentence_endings) {
        //    this._fix_sentence_endings(chunks)
        //}
        return this._wrap_chunks(chunks)
    }

    fill(text) {
        /*
         *  fill(text : string) -> string
         *
         *  Reformat the single paragraph in 'text' to fit in lines of no
         *  more than 'self.width' columns, and return a new string
         *  containing the entire wrapped paragraph.
         */
        return this.wrap(text).join('\n')
    }
}


// -- Convenience interface ---------------------------------------------

function wrap(text, options = {}) {
    /*
     *  Wrap a single paragraph of text, returning a list of wrapped lines.
     *
     *  Reformat the single paragraph in 'text' so it fits in lines of no
     *  more than 'width' columns, and return a list of wrapped lines.  By
     *  default, tabs in 'text' are expanded with string.expandtabs(), and
     *  all other whitespace characters (including newline) are converted to
     *  space.  See TextWrapper class for available keyword args to customize
     *  wrapping behaviour.
     */
    let { width = 70, ...kwargs } = options
    let w = new TextWrapper(Object.assign({ width }, kwargs))
    return w.wrap(text)
}

function fill(text, options = {}) {
    /*
     *  Fill a single paragraph of text, returning a new string.
     *
     *  Reformat the single paragraph in 'text' to fit in lines of no more
     *  than 'width' columns, and return a new string containing the entire
     *  wrapped paragraph.  As with wrap(), tabs are expanded and other
     *  whitespace characters converted to space.  See TextWrapper class for
     *  available keyword args to customize wrapping behaviour.
     */
    let { width = 70, ...kwargs } = options
    let w = new TextWrapper(Object.assign({ width }, kwargs))
    return w.fill(text)
}

// -- Loosely related functionality -------------------------------------

let _whitespace_only_re = /^[ \t]+$/mg
let _leading_whitespace_re = /(^[ \t]*)(?:[^ \t\n])/mg

function dedent(text) {
    /*
     *  Remove any common leading whitespace from every line in `text`.
     *
     *  This can be used to make triple-quoted strings line up with the left
     *  edge of the display, while still presenting them in the source code
     *  in indented form.
     *
     *  Note that tabs and spaces are both treated as whitespace, but they
     *  are not equal: the lines "  hello" and "\\thello" are
     *  considered to have no common leading whitespace.
     *
     *  Entirely blank lines are normalized to a newline character.
     */
    // Look for the longest leading string of spaces and tabs common to
    // all lines.
    let margin = undefined
    text = text.replace(_whitespace_only_re, '')
    let indents = text.match(_leading_whitespace_re) || []
    for (let indent of indents) {
        indent = indent.slice(0, -1)

        if (margin === undefined) {
            margin = indent

        // Current line more deeply indented than previous winner:
        // no change (previous winner is still on top).
        } else if (indent.startsWith(margin)) {
            // pass

        // Current line consistent with and no deeper than previous winner:
        // it's the new winner.
        } else if (margin.startsWith(indent)) {
            margin = indent

        // Find the largest common whitespace between current line and previous
        // winner.
        } else {
            for (let i = 0; i < margin.length && i < indent.length; i++) {
                if (margin[i] !== indent[i]) {
                    margin = margin.slice(0, i)
                    break
                }
            }
        }
    }

    if (margin) {
        text = text.replace(new RegExp('^' + margin, 'mg'), '')
    }
    return text
}

module.exports = { wrap, fill, dedent }
A. HISTORY OF THE SOFTWARE
==========================

Python was created in the early 1990s by Guido van Rossum at Stichting
Mathematisch Centrum (CWI, see http://www.cwi.nl) in the Netherlands
as a successor of a language called ABC.  Guido remains Python's
principal author, although it includes many contributions from others.

In 1995, Guido continued his work on Python at the Corporation for
National Research Initiatives (CNRI, see http://www.cnri.reston.va.us)
in Reston, Virginia where he released several versions of the
software.

In May 2000, Guido and the Python core development team moved to
BeOpen.com to form the BeOpen PythonLabs team.  In October of the same
year, the PythonLabs team moved to Digital Creations, which became
Zope Corporation.  In 2001, the Python Software Foundation (PSF, see
https://www.python.org/psf/) was formed, a non-profit organization
created specifically to own Python-related Intellectual Property.
Zope Corporation was a sponsoring member of the PSF.

All Python releases are Open Source (see http://www.opensource.org for
the Open Source Definition).  Historically, most, but not all, Python
releases have also been GPL-compatible; the table below summarizes
the various releases.

    Release         Derived     Year        Owner       GPL-
                    from                                compatible? (1)

    0.9.0 thru 1.2              1991-1995   CWI         yes
    1.3 thru 1.5.2  1.2         1995-1999   CNRI        yes
    1.6             1.5.2       2000        CNRI        no
    2.0             1.6         2000        BeOpen.com  no
    1.6.1           1.6         2001        CNRI        yes (2)
    2.1             2.0+1.6.1   2001        PSF         no
    2.0.1           2.0+1.6.1   2001        PSF         yes
    2.1.1           2.1+2.0.1   2001        PSF         yes
    2.1.2           2.1.1       2002        PSF         yes
    2.1.3           2.1.2       2002        PSF         yes
    2.2 and above   2.1.1       2001-now    PSF         yes

Footnotes:

(1) GPL-compatible doesn't mean that we're distributing Python under
    the GPL.  All Python licenses, unlike the GPL, let you distribute
    a modified version without making your changes open source.  The
    GPL-compatible licenses make it possible to combine Python with
    other software that is released under the GPL; the others don't.

(2) According to Richard Stallman, 1.6.1 is not GPL-compatible,
    because its license has a choice of law clause.  According to
    CNRI, however, Stallman's lawyer has told CNRI's lawyer that 1.6.1
    is "not incompatible" with the GPL.

Thanks to the many outside volunteers who have worked under Guido's
direction to make these releases possible.


B. TERMS AND CONDITIONS FOR ACCESSING OR OTHERWISE USING PYTHON
===============================================================

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Python Software Foundation;
All Rights Reserved" are retained in Python alone or in any derivative version
prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.


BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0
-------------------------------------------

BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1

1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
Individual or Organization ("Licensee") accessing and otherwise using
this software in source or binary form and its associated
documentation ("the Software").

2. Subject to the terms and conditions of this BeOpen Python License
Agreement, BeOpen hereby grants Licensee a non-exclusive,
royalty-free, world-wide license to reproduce, analyze, test, perform
and/or display publicly, prepare derivative works, distribute, and
otherwise use the Software alone or in any derivative version,
provided, however, that the BeOpen Python License is retained in the
Software, alone or in any derivative version prepared by Licensee.

3. BeOpen is making the Software available to Licensee on an "AS IS"
basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY
DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

5. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

6. This License Agreement shall be governed by and interpreted in all
respects by the law of the State of California, excluding conflict of
law provisions.  Nothing in this License Agreement shall be deemed to
create any relationship of agency, partnership, or joint venture
between BeOpen and Licensee.  This License Agreement does not grant
permission to use BeOpen trademarks or trade names in a trademark
sense to endorse or promote products or services of Licensee, or any
third party.  As an exception, the "BeOpen Python" logos available at
http://www.pythonlabs.com/logos.html may be used according to the
permissions granted on that web page.

7. By copying, installing or otherwise using the software, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.


CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1
---------------------------------------

1. This LICENSE AGREEMENT is between the Corporation for National
Research Initiatives, having an office at 1895 Preston White Drive,
Reston, VA 20191 ("CNRI"), and the Individual or Organization
("Licensee") accessing and otherwise using Python 1.6.1 software in
source or binary form and its associated documentation.

2. Subject to the terms and conditions of this License Agreement, CNRI
hereby grants Licensee a nonexclusive, royalty-free, world-wide
license to reproduce, analyze, test, perform and/or display publicly,
prepare derivative works, distribute, and otherwise use Python 1.6.1
alone or in any derivative version, provided, however, that CNRI's
License Agreement and CNRI's notice of copyright, i.e., "Copyright (c)
1995-2001 Corporation for National Research Initiatives; All Rights
Reserved" are retained in Python 1.6.1 alone or in any derivative
version prepared by Licensee.  Alternately, in lieu of CNRI's License
Agreement, Licensee may substitute the following text (omitting the
quotes): "Python 1.6.1 is made available subject to the terms and
conditions in CNRI's License Agreement.  This Agreement together with
Python 1.6.1 may be located on the Internet using the following
unique, persistent identifier (known as a handle): 1895.22/1013.  This
Agreement may also be obtained from a proxy server on the Internet
using the following URL: http://hdl.handle.net/1895.22/1013".

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python 1.6.1 or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python 1.6.1.

4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1 WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. This License Agreement shall be governed by the federal
intellectual property law of the United States, including without
limitation the federal copyright law, and, to the extent such
U.S. federal law does not apply, by the law of the Commonwealth of
Virginia, excluding Virginia's conflict of law provisions.
Notwithstanding the foregoing, with regard to derivative works based
on Python 1.6.1 that incorporate non-separable material that was
previously distributed under the GNU General Public License (GPL), the
law of the Commonwealth of Virginia shall govern this License
Agreement only as to issues arising under or with respect to
Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in this
License Agreement shall be deemed to create any relationship of
agency, partnership, or joint venture between CNRI and Licensee.  This
License Agreement does not grant permission to use CNRI trademarks or
trade name in a trademark sense to endorse or promote products or
services of Licensee, or any third party.

8. By clicking on the "ACCEPT" button where indicated, or by copying,
installing or otherwise using Python 1.6.1, Licensee agrees to be
bound by the terms and conditions of this License Agreement.

        ACCEPT


CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2
--------------------------------------------------

Copyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,
The Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
{
  "name": "argparse",
  "description": "CLI arguments parser. Native port of python's argparse.",
  "version": "2.0.1",
  "keywords": [
    "cli",
    "parser",
    "argparse",
    "option",
    "args"
  ],
  "main": "argparse.js",
  "files": [
    "argparse.js",
    "lib/"
  ],
  "license": "Python-2.0",
  "repository": "nodeca/argparse",
  "scripts": {
    "lint": "eslint .",
    "test": "npm run lint && nyc mocha",
    "coverage": "npm run test && nyc report --reporter html"
  },
  "devDependencies": {
    "@babel/eslint-parser": "^7.11.0",
    "@babel/plugin-syntax-class-properties": "^7.10.4",
    "eslint": "^7.5.0",
    "mocha": "^8.0.1",
    "nyc": "^15.1.0"
  }
}
argparse
========

[![Build Status](https://secure.travis-ci.org/nodeca/argparse.svg?branch=master)](http://travis-ci.org/nodeca/argparse)
[![NPM version](https://img.shields.io/npm/v/argparse.svg)](https://www.npmjs.org/package/argparse)

CLI arguments parser for node.js, with [sub-commands](https://docs.python.org/3.9/library/argparse.html#sub-commands) support. Port of python's [argparse](http://docs.python.org/dev/library/argparse.html) (version [3.9.0](https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py)).

**Difference with original.**

- JS has no keyword arguments support.
  -  Pass options instead: `new ArgumentParser({ description: 'example', add_help: true })`.
- JS has no python's types `int`, `float`, ...
  - Use string-typed names: `.add_argument('-b', { type: 'int', help: 'help' })`.
- `%r` format specifier uses `require('util').inspect()`.

More details in [doc](./doc).


Example
-------

`test.js` file:

```javascript
#!/usr/bin/env node
'use strict';

const { ArgumentParser } = require('argparse');
const { version } = require('./package.json');

const parser = new ArgumentParser({
  description: 'Argparse example'
});

parser.add_argument('-v', '--version', { action: 'version', version });
parser.add_argument('-f', '--foo', { help: 'foo bar' });
parser.add_argument('-b', '--bar', { help: 'bar foo' });
parser.add_argument('--baz', { help: 'baz bar' });

console.dir(parser.parse_args());
```

Display help:

```
$ ./test.js -h
usage: test.js [-h] [-v] [-f FOO] [-b BAR] [--baz BAZ]

Argparse example

optional arguments:
  -h, --help         show this help message and exit
  -v, --version      show program's version number and exit
  -f FOO, --foo FOO  foo bar
  -b BAR, --bar BAR  bar foo
  --baz BAZ          baz bar
```

Parse arguments:

```
$ ./test.js -f=3 --bar=4 --baz 5
{ foo: '3', bar: '4', baz: '5' }
```


API docs
--------

Since this is a port with minimal divergence, there's no separate documentation.
Use original one instead, with notes about difference.

1. [Original doc](https://docs.python.org/3.9/library/argparse.html).
2. [Original tutorial](https://docs.python.org/3.9/howto/argparse.html).
3. [Difference with python](./doc).


argparse for enterprise
-----------------------

Available as part of the Tidelift Subscription

The maintainers of argparse and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-argparse?utm_source=npm-argparse&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)
// Port of python's argparse module, version 3.9.0:
// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py

'use strict'

// Copyright (C) 2010-2020 Python Software Foundation.
// Copyright (C) 2020 argparse.js authors

/*
 * Command-line parsing library
 *
 * This module is an optparse-inspired command-line parsing library that:
 *
 *     - handles both optional and positional arguments
 *     - produces highly informative usage messages
 *     - supports parsers that dispatch to sub-parsers
 *
 * The following is a simple usage example that sums integers from the
 * command-line and writes the result to a file::
 *
 *     parser = argparse.ArgumentParser(
 *         description='sum the integers at the command line')
 *     parser.add_argument(
 *         'integers', metavar='int', nargs='+', type=int,
 *         help='an integer to be summed')
 *     parser.add_argument(
 *         '--log', default=sys.stdout, type=argparse.FileType('w'),
 *         help='the file where the sum should be written')
 *     args = parser.parse_args()
 *     args.log.write('%s' % sum(args.integers))
 *     args.log.close()
 *
 * The module contains the following public classes:
 *
 *     - ArgumentParser -- The main entry point for command-line parsing. As the
 *         example above shows, the add_argument() method is used to populate
 *         the parser with actions for optional and positional arguments. Then
 *         the parse_args() method is invoked to convert the args at the
 *         command-line into an object with attributes.
 *
 *     - ArgumentError -- The exception raised by ArgumentParser objects when
 *         there are errors with the parser's actions. Errors raised while
 *         parsing the command-line are caught by ArgumentParser and emitted
 *         as command-line messages.
 *
 *     - FileType -- A factory for defining types of files to be created. As the
 *         example above shows, instances of FileType are typically passed as
 *         the type= argument of add_argument() calls.
 *
 *     - Action -- The base class for parser actions. Typically actions are
 *         selected by passing strings like 'store_true' or 'append_const' to
 *         the action= argument of add_argument(). However, for greater
 *         customization of ArgumentParser actions, subclasses of Action may
 *         be defined and passed as the action= argument.
 *
 *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
 *         ArgumentDefaultsHelpFormatter -- Formatter classes which
 *         may be passed as the formatter_class= argument to the
 *         ArgumentParser constructor. HelpFormatter is the default,
 *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
 *         not to change the formatting for help text, and
 *         ArgumentDefaultsHelpFormatter adds information about argument defaults
 *         to the help.
 *
 * All other classes in this module are considered implementation details.
 * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only
 * considered public as object names -- the API of the formatter objects is
 * still considered an implementation detail.)
 */

const SUPPRESS = '==SUPPRESS=='

const OPTIONAL = '?'
const ZERO_OR_MORE = '*'
const ONE_OR_MORE = '+'
const PARSER = 'A...'
const REMAINDER = '...'
const _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'


// ==================================
// Utility functions used for porting
// ==================================
const assert = require('assert')
const util = require('util')
const fs = require('fs')
const sub = require('./lib/sub')
const path = require('path')
const repr = util.inspect

function get_argv() {
    // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)
    return process.argv.slice(1)
}

function get_terminal_size() {
    return {
        columns: +process.env.COLUMNS || process.stdout.columns || 80
    }
}

function hasattr(object, name) {
    return Object.prototype.hasOwnProperty.call(object, name)
}

function getattr(object, name, value) {
    return hasattr(object, name) ? object[name] : value
}

function setattr(object, name, value) {
    object[name] = value
}

function setdefault(object, name, value) {
    if (!hasattr(object, name)) object[name] = value
    return object[name]
}

function delattr(object, name) {
    delete object[name]
}

function range(from, to, step=1) {
    // range(10) is equivalent to range(0, 10)
    if (arguments.length === 1) [ to, from ] = [ from, 0 ]
    if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {
        throw new TypeError('argument cannot be interpreted as an integer')
    }
    if (step === 0) throw new TypeError('range() arg 3 must not be zero')

    let result = []
    if (step > 0) {
        for (let i = from; i < to; i += step) result.push(i)
    } else {
        for (let i = from; i > to; i += step) result.push(i)
    }
    return result
}

function splitlines(str, keepends = false) {
    let result
    if (!keepends) {
        result = str.split(/\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029]/)
    } else {
        result = []
        let parts = str.split(/(\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029])/)
        for (let i = 0; i < parts.length; i += 2) {
            result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''))
        }
    }
    if (!result[result.length - 1]) result.pop()
    return result
}

function _string_lstrip(string, prefix_chars) {
    let idx = 0
    while (idx < string.length && prefix_chars.includes(string[idx])) idx++
    return idx ? string.slice(idx) : string
}

function _string_split(string, sep, maxsplit) {
    let result = string.split(sep)
    if (result.length > maxsplit) {
        result = result.slice(0, maxsplit).concat([ result.slice(maxsplit).join(sep) ])
    }
    return result
}

function _array_equal(array1, array2) {
    if (array1.length !== array2.length) return false
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) return false
    }
    return true
}

function _array_remove(array, item) {
    let idx = array.indexOf(item)
    if (idx === -1) throw new TypeError(sub('%r not in list', item))
    array.splice(idx, 1)
}

// normalize choices to array;
// this isn't required in python because `in` and `map` operators work with anything,
// but in js dealing with multiple types here is too clunky
function _choices_to_array(choices) {
    if (choices === undefined) {
        return []
    } else if (Array.isArray(choices)) {
        return choices
    } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {
        return Array.from(choices)
    } else if (typeof choices === 'object' && choices !== null) {
        return Object.keys(choices)
    } else {
        throw new Error(sub('invalid choices value: %r', choices))
    }
}

// decorator that allows a class to be called without new
function _callable(cls) {
    let result = { // object is needed for inferred class name
        [cls.name]: function (...args) {
            let this_class = new.target === result || !new.target
            return Reflect.construct(cls, args, this_class ? cls : new.target)
        }
    }
    result[cls.name].prototype = cls.prototype
    // fix default tag for toString, e.g. [object Action] instead of [object Object]
    cls.prototype[Symbol.toStringTag] = cls.name
    return result[cls.name]
}

function _alias(object, from, to) {
    try {
        let name = object.constructor.name
        Object.defineProperty(object, from, {
            value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()',
                name, from, name, to)),
            enumerable: false
        })
    } catch {}
}

// decorator that allows snake_case class methods to be called with camelCase and vice versa
function _camelcase_alias(_class) {
    for (let name of Object.getOwnPropertyNames(_class.prototype)) {
        let camelcase = name.replace(/\w_[a-z]/g, s => s[0] + s[2].toUpperCase())
        if (camelcase !== name) _alias(_class.prototype, camelcase, name)
    }
    return _class
}

function _to_legacy_name(key) {
    key = key.replace(/\w_[a-z]/g, s => s[0] + s[2].toUpperCase())
    if (key === 'default') key = 'defaultValue'
    if (key === 'const') key = 'constant'
    return key
}

function _to_new_name(key) {
    if (key === 'defaultValue') key = 'default'
    if (key === 'constant') key = 'const'
    key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase())
    return key
}

// parse options
let no_default = Symbol('no_default_value')
function _parse_opts(args, descriptor) {
    function get_name() {
        let stack = new Error().stack.split('\n')
            .map(x => x.match(/^    at (.*) \(.*\)$/))
            .filter(Boolean)
            .map(m => m[1])
            .map(fn => fn.match(/[^ .]*$/)[0])

        if (stack.length && stack[0] === get_name.name) stack.shift()
        if (stack.length && stack[0] === _parse_opts.name) stack.shift()
        return stack.length ? stack[0] : ''
    }

    args = Array.from(args)
    let kwargs = {}
    let result = []
    let last_opt = args.length && args[args.length - 1]

    if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) &&
        (!last_opt.constructor || last_opt.constructor.name === 'Object')) {
        kwargs = Object.assign({}, args.pop())
    }

    // LEGACY (v1 compatibility): camelcase
    let renames = []
    for (let key of Object.keys(descriptor)) {
        let old_name = _to_legacy_name(key)
        if (old_name !== key && (old_name in kwargs)) {
            if (key in kwargs) {
                // default and defaultValue specified at the same time, happens often in old tests
                //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))
            } else {
                kwargs[key] = kwargs[old_name]
            }
            renames.push([ old_name, key ])
            delete kwargs[old_name]
        }
    }
    if (renames.length) {
        let name = get_name()
        deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',
            name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))
    }
    // end

    let missing_positionals = []
    let positional_count = args.length

    for (let [ key, def ] of Object.entries(descriptor)) {
        if (key[0] === '*') {
            if (key.length > 0 && key[1] === '*') {
                // LEGACY (v1 compatibility): camelcase
                let renames = []
                for (let key of Object.keys(kwargs)) {
                    let new_name = _to_new_name(key)
                    if (new_name !== key && (key in kwargs)) {
                        if (new_name in kwargs) {
                            // default and defaultValue specified at the same time, happens often in old tests
                            //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))
                        } else {
                            kwargs[new_name] = kwargs[key]
                        }
                        renames.push([ key, new_name ])
                        delete kwargs[key]
                    }
                }
                if (renames.length) {
                    let name = get_name()
                    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',
                        name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))
                }
                // end
                result.push(kwargs)
                kwargs = {}
            } else {
                result.push(args)
                args = []
            }
        } else if (key in kwargs && args.length > 0) {
            throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))
        } else if (key in kwargs) {
            result.push(kwargs[key])
            delete kwargs[key]
        } else if (args.length > 0) {
            result.push(args.shift())
        } else if (def !== no_default) {
            result.push(def)
        } else {
            missing_positionals.push(key)
        }
    }

    if (Object.keys(kwargs).length) {
        throw new TypeError(sub('%s() got an unexpected keyword argument %r',
            get_name(), Object.keys(kwargs)[0]))
    }

    if (args.length) {
        let from = Object.entries(descriptor).filter(([ k, v ]) => k[0] !== '*' && v !== no_default).length
        let to = Object.entries(descriptor).filter(([ k ]) => k[0] !== '*').length
        throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given',
            get_name(),
            from === to ? sub('from %s to %s', from, to) : to,
            from === to && to === 1 ? '' : 's',
            positional_count,
            positional_count === 1 ? 'was' : 'were'))
    }

    if (missing_positionals.length) {
        let strs = missing_positionals.map(repr)
        if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1]
        let str_joined = strs.join(strs.length === 2 ? '' : ', ')
        throw new TypeError(sub('%s() missing %i required positional argument%s: %s',
            get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined))
    }

    return result
}

let _deprecations = {}
function deprecate(id, string) {
    _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string)
    _deprecations[id]()
}


// =============================
// Utility functions and classes
// =============================
function _AttributeHolder(cls = Object) {
    /*
     *  Abstract base class that provides __repr__.
     *
     *  The __repr__ method returns a string in the format::
     *      ClassName(attr=name, attr=name, ...)
     *  The attributes are determined either by a class-level attribute,
     *  '_kwarg_names', or by inspecting the instance __dict__.
     */

    return class _AttributeHolder extends cls {
        [util.inspect.custom]() {
            let type_name = this.constructor.name
            let arg_strings = []
            let star_args = {}
            for (let arg of this._get_args()) {
                arg_strings.push(repr(arg))
            }
            for (let [ name, value ] of this._get_kwargs()) {
                if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {
                    arg_strings.push(sub('%s=%r', name, value))
                } else {
                    star_args[name] = value
                }
            }
            if (Object.keys(star_args).length) {
                arg_strings.push(sub('**%s', repr(star_args)))
            }
            return sub('%s(%s)', type_name, arg_strings.join(', '))
        }

        toString() {
            return this[util.inspect.custom]()
        }

        _get_kwargs() {
            return Object.entries(this)
        }

        _get_args() {
            return []
        }
    }
}


function _copy_items(items) {
    if (items === undefined) {
        return []
    }
    return items.slice(0)
}


// ===============
// Formatting Help
// ===============
const HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {
    /*
     *  Formatter for generating usage messages and argument help strings.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    constructor() {
        let [
            prog,
            indent_increment,
            max_help_position,
            width
        ] = _parse_opts(arguments, {
            prog: no_default,
            indent_increment: 2,
            max_help_position: 24,
            width: undefined
        })

        // default setting for width
        if (width === undefined) {
            width = get_terminal_size().columns
            width -= 2
        }

        this._prog = prog
        this._indent_increment = indent_increment
        this._max_help_position = Math.min(max_help_position,
                                      Math.max(width - 20, indent_increment * 2))
        this._width = width

        this._current_indent = 0
        this._level = 0
        this._action_max_length = 0

        this._root_section = this._Section(this, undefined)
        this._current_section = this._root_section

        this._whitespace_matcher = /[ \t\n\r\f\v]+/g // equivalent to python /\s+/ with ASCII flag
        this._long_break_matcher = /\n\n\n+/g
    }

    // ===============================
    // Section and indentation methods
    // ===============================
    _indent() {
        this._current_indent += this._indent_increment
        this._level += 1
    }

    _dedent() {
        this._current_indent -= this._indent_increment
        assert(this._current_indent >= 0, 'Indent decreased below 0.')
        this._level -= 1
    }

    _add_item(func, args) {
        this._current_section.items.push([ func, args ])
    }

    // ========================
    // Message building methods
    // ========================
    start_section(heading) {
        this._indent()
        let section = this._Section(this, this._current_section, heading)
        this._add_item(section.format_help.bind(section), [])
        this._current_section = section
    }

    end_section() {
        this._current_section = this._current_section.parent
        this._dedent()
    }

    add_text(text) {
        if (text !== SUPPRESS && text !== undefined) {
            this._add_item(this._format_text.bind(this), [text])
        }
    }

    add_usage(usage, actions, groups, prefix = undefined) {
        if (usage !== SUPPRESS) {
            let args = [ usage, actions, groups, prefix ]
            this._add_item(this._format_usage.bind(this), args)
        }
    }

    add_argument(action) {
        if (action.help !== SUPPRESS) {

            // find all invocations
            let invocations = [this._format_action_invocation(action)]
            for (let subaction of this._iter_indented_subactions(action)) {
                invocations.push(this._format_action_invocation(subaction))
            }

            // update the maximum item length
            let invocation_length = Math.max(...invocations.map(invocation => invocation.length))
            let action_length = invocation_length + this._current_indent
            this._action_max_length = Math.max(this._action_max_length,
                                               action_length)

            // add the item to the list
            this._add_item(this._format_action.bind(this), [action])
        }
    }

    add_arguments(actions) {
        for (let action of actions) {
            this.add_argument(action)
        }
    }

    // =======================
    // Help-formatting methods
    // =======================
    format_help() {
        let help = this._root_section.format_help()
        if (help) {
            help = help.replace(this._long_break_matcher, '\n\n')
            help = help.replace(/^\n+|\n+$/g, '') + '\n'
        }
        return help
    }

    _join_parts(part_strings) {
        return part_strings.filter(part => part && part !== SUPPRESS).join('')
    }

    _format_usage(usage, actions, groups, prefix) {
        if (prefix === undefined) {
            prefix = 'usage: '
        }

        // if usage is specified, use that
        if (usage !== undefined) {
            usage = sub(usage, { prog: this._prog })

        // if no optionals or positionals are available, usage is just prog
        } else if (usage === undefined && !actions.length) {
            usage = sub('%(prog)s', { prog: this._prog })

        // if optionals and positionals are available, calculate usage
        } else if (usage === undefined) {
            let prog = sub('%(prog)s', { prog: this._prog })

            // split optionals from positionals
            let optionals = []
            let positionals = []
            for (let action of actions) {
                if (action.option_strings.length) {
                    optionals.push(action)
                } else {
                    positionals.push(action)
                }
            }

            // build full usage string
            let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups)
            usage = [ prog, action_usage ].map(String).join(' ')

            // wrap the usage parts if it's too long
            let text_width = this._width - this._current_indent
            if (prefix.length + usage.length > text_width) {

                // break usage into wrappable parts
                let part_regexp = /\(.*?\)+(?=\s|$)|\[.*?\]+(?=\s|$)|\S+/g
                let opt_usage = this._format_actions_usage(optionals, groups)
                let pos_usage = this._format_actions_usage(positionals, groups)
                let opt_parts = opt_usage.match(part_regexp) || []
                let pos_parts = pos_usage.match(part_regexp) || []
                assert(opt_parts.join(' ') === opt_usage)
                assert(pos_parts.join(' ') === pos_usage)

                // helper for wrapping lines
                let get_lines = (parts, indent, prefix = undefined) => {
                    let lines = []
                    let line = []
                    let line_len
                    if (prefix !== undefined) {
                        line_len = prefix.length - 1
                    } else {
                        line_len = indent.length - 1
                    }
                    for (let part of parts) {
                        if (line_len + 1 + part.length > text_width && line) {
                            lines.push(indent + line.join(' '))
                            line = []
                            line_len = indent.length - 1
                        }
                        line.push(part)
                        line_len += part.length + 1
                    }
                    if (line.length) {
                        lines.push(indent + line.join(' '))
                    }
                    if (prefix !== undefined) {
                        lines[0] = lines[0].slice(indent.length)
                    }
                    return lines
                }

                let lines

                // if prog is short, follow it with optionals or positionals
                if (prefix.length + prog.length <= 0.75 * text_width) {
                    let indent = ' '.repeat(prefix.length + prog.length + 1)
                    if (opt_parts.length) {
                        lines = get_lines([prog].concat(opt_parts), indent, prefix)
                        lines = lines.concat(get_lines(pos_parts, indent))
                    } else if (pos_parts.length) {
                        lines = get_lines([prog].concat(pos_parts), indent, prefix)
                    } else {
                        lines = [prog]
                    }

                // if prog is long, put it on its own line
                } else {
                    let indent = ' '.repeat(prefix.length)
                    let parts = [].concat(opt_parts).concat(pos_parts)
                    lines = get_lines(parts, indent)
                    if (lines.length > 1) {
                        lines = []
                        lines = lines.concat(get_lines(opt_parts, indent))
                        lines = lines.concat(get_lines(pos_parts, indent))
                    }
                    lines = [prog].concat(lines)
                }

                // join lines into usage
                usage = lines.join('\n')
            }
        }

        // prefix with 'usage:'
        return sub('%s%s\n\n', prefix, usage)
    }

    _format_actions_usage(actions, groups) {
        // find group indices and identify actions in groups
        let group_actions = new Set()
        let inserts = {}
        for (let group of groups) {
            let start = actions.indexOf(group._group_actions[0])
            if (start === -1) {
                continue
            } else {
                let end = start + group._group_actions.length
                if (_array_equal(actions.slice(start, end), group._group_actions)) {
                    for (let action of group._group_actions) {
                        group_actions.add(action)
                    }
                    if (!group.required) {
                        if (start in inserts) {
                            inserts[start] += ' ['
                        } else {
                            inserts[start] = '['
                        }
                        if (end in inserts) {
                            inserts[end] += ']'
                        } else {
                            inserts[end] = ']'
                        }
                    } else {
                        if (start in inserts) {
                            inserts[start] += ' ('
                        } else {
                            inserts[start] = '('
                        }
                        if (end in inserts) {
                            inserts[end] += ')'
                        } else {
                            inserts[end] = ')'
                        }
                    }
                    for (let i of range(start + 1, end)) {
                        inserts[i] = '|'
                    }
                }
            }
        }

        // collect all actions format strings
        let parts = []
        for (let [ i, action ] of Object.entries(actions)) {

            // suppressed arguments are marked with None
            // remove | separators for suppressed arguments
            if (action.help === SUPPRESS) {
                parts.push(undefined)
                if (inserts[+i] === '|') {
                    delete inserts[+i]
                } else if (inserts[+i + 1] === '|') {
                    delete inserts[+i + 1]
                }

            // produce all arg strings
            } else if (!action.option_strings.length) {
                let default_value = this._get_default_metavar_for_positional(action)
                let part = this._format_args(action, default_value)

                // if it's in a group, strip the outer []
                if (group_actions.has(action)) {
                    if (part[0] === '[' && part[part.length - 1] === ']') {
                        part = part.slice(1, -1)
                    }
                }

                // add the action string to the list
                parts.push(part)

            // produce the first way to invoke the option in brackets
            } else {
                let option_string = action.option_strings[0]
                let part

                // if the Optional doesn't take a value, format is:
                //    -s or --long
                if (action.nargs === 0) {
                    part = action.format_usage()

                // if the Optional takes a value, format is:
                //    -s ARGS or --long ARGS
                } else {
                    let default_value = this._get_default_metavar_for_optional(action)
                    let args_string = this._format_args(action, default_value)
                    part = sub('%s %s', option_string, args_string)
                }

                // make it look optional if it's not required or in a group
                if (!action.required && !group_actions.has(action)) {
                    part = sub('[%s]', part)
                }

                // add the action string to the list
                parts.push(part)
            }
        }

        // insert things at the necessary indices
        for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {
            parts.splice(+i, 0, inserts[+i])
        }

        // join all the action items with spaces
        let text = parts.filter(Boolean).join(' ')

        // clean up separators for mutually exclusive groups
        text = text.replace(/([\[(]) /g, '$1')
        text = text.replace(/ ([\])])/g, '$1')
        text = text.replace(/[\[(] *[\])]/g, '')
        text = text.replace(/\(([^|]*)\)/g, '$1', text)
        text = text.trim()

        // return the text
        return text
    }

    _format_text(text) {
        if (text.includes('%(prog)')) {
            text = sub(text, { prog: this._prog })
        }
        let text_width = Math.max(this._width - this._current_indent, 11)
        let indent = ' '.repeat(this._current_indent)
        return this._fill_text(text, text_width, indent) + '\n\n'
    }

    _format_action(action) {
        // determine the required width and the entry label
        let help_position = Math.min(this._action_max_length + 2,
                                     this._max_help_position)
        let help_width = Math.max(this._width - help_position, 11)
        let action_width = help_position - this._current_indent - 2
        let action_header = this._format_action_invocation(action)
        let indent_first

        // no help; start on same line and add a final newline
        if (!action.help) {
            let tup = [ this._current_indent, '', action_header ]
            action_header = sub('%*s%s\n', ...tup)

        // short action name; start on the same line and pad two spaces
        } else if (action_header.length <= action_width) {
            let tup = [ this._current_indent, '', action_width, action_header ]
            action_header = sub('%*s%-*s  ', ...tup)
            indent_first = 0

        // long action name; start on the next line
        } else {
            let tup = [ this._current_indent, '', action_header ]
            action_header = sub('%*s%s\n', ...tup)
            indent_first = help_position
        }

        // collect the pieces of the action help
        let parts = [action_header]

        // if there was help for the action, add lines of help text
        if (action.help) {
            let help_text = this._expand_help(action)
            let help_lines = this._split_lines(help_text, help_width)
            parts.push(sub('%*s%s\n', indent_first, '', help_lines[0]))
            for (let line of help_lines.slice(1)) {
                parts.push(sub('%*s%s\n', help_position, '', line))
            }

        // or add a newline if the description doesn't end with one
        } else if (!action_header.endsWith('\n')) {
            parts.push('\n')
        }

        // if there are any sub-actions, add their help as well
        for (let subaction of this._iter_indented_subactions(action)) {
            parts.push(this._format_action(subaction))
        }

        // return a single string
        return this._join_parts(parts)
    }

    _format_action_invocation(action) {
        if (!action.option_strings.length) {
            let default_value = this._get_default_metavar_for_positional(action)
            let metavar = this._metavar_formatter(action, default_value)(1)[0]
            return metavar

        } else {
            let parts = []

            // if the Optional doesn't take a value, format is:
            //    -s, --long
            if (action.nargs === 0) {
                parts = parts.concat(action.option_strings)

            // if the Optional takes a value, format is:
            //    -s ARGS, --long ARGS
            } else {
                let default_value = this._get_default_metavar_for_optional(action)
                let args_string = this._format_args(action, default_value)
                for (let option_string of action.option_strings) {
                    parts.push(sub('%s %s', option_string, args_string))
                }
            }

            return parts.join(', ')
        }
    }

    _metavar_formatter(action, default_metavar) {
        let result
        if (action.metavar !== undefined) {
            result = action.metavar
        } else if (action.choices !== undefined) {
            let choice_strs = _choices_to_array(action.choices).map(String)
            result = sub('{%s}', choice_strs.join(','))
        } else {
            result = default_metavar
        }

        function format(tuple_size) {
            if (Array.isArray(result)) {
                return result
            } else {
                return Array(tuple_size).fill(result)
            }
        }
        return format
    }

    _format_args(action, default_metavar) {
        let get_metavar = this._metavar_formatter(action, default_metavar)
        let result
        if (action.nargs === undefined) {
            result = sub('%s', ...get_metavar(1))
        } else if (action.nargs === OPTIONAL) {
            result = sub('[%s]', ...get_metavar(1))
        } else if (action.nargs === ZERO_OR_MORE) {
            let metavar = get_metavar(1)
            if (metavar.length === 2) {
                result = sub('[%s [%s ...]]', ...metavar)
            } else {
                result = sub('[%s ...]', ...metavar)
            }
        } else if (action.nargs === ONE_OR_MORE) {
            result = sub('%s [%s ...]', ...get_metavar(2))
        } else if (action.nargs === REMAINDER) {
            result = '...'
        } else if (action.nargs === PARSER) {
            result = sub('%s ...', ...get_metavar(1))
        } else if (action.nargs === SUPPRESS) {
            result = ''
        } else {
            let formats
            try {
                formats = range(action.nargs).map(() => '%s')
            } catch (err) {
                throw new TypeError('invalid nargs value')
            }
            result = sub(formats.join(' '), ...get_metavar(action.nargs))
        }
        return result
    }

    _expand_help(action) {
        let params = Object.assign({ prog: this._prog }, action)
        for (let name of Object.keys(params)) {
            if (params[name] === SUPPRESS) {
                delete params[name]
            }
        }
        for (let name of Object.keys(params)) {
            if (params[name] && params[name].name) {
                params[name] = params[name].name
            }
        }
        if (params.choices !== undefined) {
            let choices_str = _choices_to_array(params.choices).map(String).join(', ')
            params.choices = choices_str
        }
        // LEGACY (v1 compatibility): camelcase
        for (let key of Object.keys(params)) {
            let old_name = _to_legacy_name(key)
            if (old_name !== key) {
                params[old_name] = params[key]
            }
        }
        // end
        return sub(this._get_help_string(action), params)
    }

    * _iter_indented_subactions(action) {
        if (typeof action._get_subactions === 'function') {
            this._indent()
            yield* action._get_subactions()
            this._dedent()
        }
    }

    _split_lines(text, width) {
        text = text.replace(this._whitespace_matcher, ' ').trim()
        // The textwrap module is used only for formatting help.
        // Delay its import for speeding up the common usage of argparse.
        let textwrap = require('./lib/textwrap')
        return textwrap.wrap(text, { width })
    }

    _fill_text(text, width, indent) {
        text = text.replace(this._whitespace_matcher, ' ').trim()
        let textwrap = require('./lib/textwrap')
        return textwrap.fill(text, { width,
                                     initial_indent: indent,
                                     subsequent_indent: indent })
    }

    _get_help_string(action) {
        return action.help
    }

    _get_default_metavar_for_optional(action) {
        return action.dest.toUpperCase()
    }

    _get_default_metavar_for_positional(action) {
        return action.dest
    }
}))

HelpFormatter.prototype._Section = _callable(class _Section {

    constructor(formatter, parent, heading = undefined) {
        this.formatter = formatter
        this.parent = parent
        this.heading = heading
        this.items = []
    }

    format_help() {
        // format the indented section
        if (this.parent !== undefined) {
            this.formatter._indent()
        }
        let item_help = this.formatter._join_parts(this.items.map(([ func, args ]) => func.apply(null, args)))
        if (this.parent !== undefined) {
            this.formatter._dedent()
        }

        // return nothing if the section was empty
        if (!item_help) {
            return ''
        }

        // add the heading if the section was non-empty
        let heading
        if (this.heading !== SUPPRESS && this.heading !== undefined) {
            let current_indent = this.formatter._current_indent
            heading = sub('%*s%s:\n', current_indent, '', this.heading)
        } else {
            heading = ''
        }

        // join the section-initial newline, the heading and the help
        return this.formatter._join_parts(['\n', heading, item_help, '\n'])
    }
})


const RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which retains any formatting in descriptions.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _fill_text(text, width, indent) {
        return splitlines(text, true).map(line => indent + line).join('')
    }
}))


const RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {
    /*
     *  Help message formatter which retains formatting of all help text.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _split_lines(text/*, width*/) {
        return splitlines(text)
    }
}))


const ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which adds default values to argument help.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _get_help_string(action) {
        let help = action.help
        // LEGACY (v1 compatibility): additional check for defaultValue needed
        if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {
            if (action.default !== SUPPRESS) {
                let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
                if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {
                    help += ' (default: %(default)s)'
                }
            }
        }
        return help
    }
}))


const MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which uses the argument 'type' as the default
     *  metavar value (instead of the argument 'dest')
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _get_default_metavar_for_optional(action) {
        return typeof action.type === 'function' ? action.type.name : action.type
    }

    _get_default_metavar_for_positional(action) {
        return typeof action.type === 'function' ? action.type.name : action.type
    }
}))


// =====================
// Options and Arguments
// =====================
function _get_action_name(argument) {
    if (argument === undefined) {
        return undefined
    } else if (argument.option_strings.length) {
        return argument.option_strings.join('/')
    } else if (![ undefined, SUPPRESS ].includes(argument.metavar)) {
        return argument.metavar
    } else if (![ undefined, SUPPRESS ].includes(argument.dest)) {
        return argument.dest
    } else {
        return undefined
    }
}


const ArgumentError = _callable(class ArgumentError extends Error {
    /*
     *  An error from creating or using an argument (optional or positional).
     *
     *  The string value of this exception is the message, augmented with
     *  information about the argument that caused it.
     */

    constructor(argument, message) {
        super()
        this.name = 'ArgumentError'
        this._argument_name = _get_action_name(argument)
        this._message = message
        this.message = this.str()
    }

    str() {
        let format
        if (this._argument_name === undefined) {
            format = '%(message)s'
        } else {
            format = 'argument %(argument_name)s: %(message)s'
        }
        return sub(format, { message: this._message,
                             argument_name: this._argument_name })
    }
})


const ArgumentTypeError = _callable(class ArgumentTypeError extends Error {
    /*
     * An error from trying to convert a command line string to a type.
     */

    constructor(message) {
        super(message)
        this.name = 'ArgumentTypeError'
    }
})


// ==============
// Action classes
// ==============
const Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {
    /*
     *  Information about how to convert command line strings to Python objects.
     *
     *  Action objects are used by an ArgumentParser to represent the information
     *  needed to parse a single argument from one or more strings from the
     *  command line. The keyword arguments to the Action constructor are also
     *  all attributes of Action instances.
     *
     *  Keyword Arguments:
     *
     *      - option_strings -- A list of command-line option strings which
     *          should be associated with this action.
     *
     *      - dest -- The name of the attribute to hold the created object(s)
     *
     *      - nargs -- The number of command-line arguments that should be
     *          consumed. By default, one argument will be consumed and a single
     *          value will be produced.  Other values include:
     *              - N (an integer) consumes N arguments (and produces a list)
     *              - '?' consumes zero or one arguments
     *              - '*' consumes zero or more arguments (and produces a list)
     *              - '+' consumes one or more arguments (and produces a list)
     *          Note that the difference between the default and nargs=1 is that
     *          with the default, a single value will be produced, while with
     *          nargs=1, a list containing a single value will be produced.
     *
     *      - const -- The value to be produced if the option is specified and the
     *          option uses an action that takes no values.
     *
     *      - default -- The value to be produced if the option is not specified.
     *
     *      - type -- A callable that accepts a single string argument, and
     *          returns the converted value.  The standard Python types str, int,
     *          float, and complex are useful examples of such callables.  If None,
     *          str is used.
     *
     *      - choices -- A container of values that should be allowed. If not None,
     *          after a command-line argument has been converted to the appropriate
     *          type, an exception will be raised if it is not a member of this
     *          collection.
     *
     *      - required -- True if the action must always be specified at the
     *          command line. This is only meaningful for optional command-line
     *          arguments.
     *
     *      - help -- The help string describing the argument.
     *
     *      - metavar -- The name to be used for the option's argument with the
     *          help string. If None, the 'dest' value will be used as the name.
     */

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        // when this class is called as a function, redirect it to .call() method of itself
        super('return arguments.callee.call.apply(arguments.callee, arguments)')

        this.option_strings = option_strings
        this.dest = dest
        this.nargs = nargs
        this.const = const_value
        this.default = default_value
        this.type = type
        this.choices = choices
        this.required = required
        this.help = help
        this.metavar = metavar
    }

    _get_kwargs() {
        let names = [
            'option_strings',
            'dest',
            'nargs',
            'const',
            'default',
            'type',
            'choices',
            'help',
            'metavar'
        ]
        return names.map(name => [ name, getattr(this, name) ])
    }

    format_usage() {
        return this.option_strings[0]
    }

    call(/*parser, namespace, values, option_string = undefined*/) {
        throw new Error('.call() not defined')
    }
}))


const BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        let _option_strings = []
        for (let option_string of option_strings) {
            _option_strings.push(option_string)

            if (option_string.startsWith('--')) {
                option_string = '--no-' + option_string.slice(2)
                _option_strings.push(option_string)
            }
        }

        if (help !== undefined && default_value !== undefined) {
            help += ` (default: ${default_value})`
        }

        super({
            option_strings: _option_strings,
            dest,
            nargs: 0,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values, option_string = undefined) {
        if (this.option_strings.includes(option_string)) {
            setattr(namespace, this.dest, !option_string.startsWith('--no-'))
        }
    }

    format_usage() {
        return this.option_strings.join(' | ')
    }
}))


const _StoreAction = _callable(class _StoreAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        if (nargs === 0) {
            throw new TypeError('nargs for store actions must be != 0; if you ' +
                        'have nothing to store, actions such as store ' +
                        'true or store const may be more appropriate')
        }
        if (const_value !== undefined && nargs !== OPTIONAL) {
            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))
        }
        super({
            option_strings,
            dest,
            nargs,
            const: const_value,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        setattr(namespace, this.dest, values)
    }
})


const _StoreConstAction = _callable(class _StoreConstAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            const_value,
            default_value,
            required,
            help
            //, metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            const: no_default,
            default: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            const: const_value,
            default: default_value,
            required,
            help
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        setattr(namespace, this.dest, this.const)
    }
})


const _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: false,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            const: true,
            default: default_value,
            required,
            help
        })
    }
})


const _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: true,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            const: false,
            default: default_value,
            required,
            help
        })
    }
})


const _AppendAction = _callable(class _AppendAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        if (nargs === 0) {
            throw new TypeError('nargs for append actions must be != 0; if arg ' +
                        'strings are not supplying the value to append, ' +
                        'the append const action may be more appropriate')
        }
        if (const_value !== undefined && nargs !== OPTIONAL) {
            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))
        }
        super({
            option_strings,
            dest,
            nargs,
            const: const_value,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items.push(values)
        setattr(namespace, this.dest, items)
    }
})


const _AppendConstAction = _callable(class _AppendConstAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            const_value,
            default_value,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            const: no_default,
            default: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            const: const_value,
            default: default_value,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items.push(this.const)
        setattr(namespace, this.dest, items)
    }
})


const _CountAction = _callable(class _CountAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: undefined,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            default: default_value,
            required,
            help
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        let count = getattr(namespace, this.dest, undefined)
        if (count === undefined) {
            count = 0
        }
        setattr(namespace, this.dest, count + 1)
    }
})


const _HelpAction = _callable(class _HelpAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: SUPPRESS,
            default: SUPPRESS,
            help: undefined
        })

        super({
            option_strings,
            dest,
            default: default_value,
            nargs: 0,
            help
        })
    }

    call(parser/*, namespace, values, option_string = undefined*/) {
        parser.print_help()
        parser.exit()
    }
})


const _VersionAction = _callable(class _VersionAction extends Action {

    constructor() {
        let [
            option_strings,
            version,
            dest,
            default_value,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            version: undefined,
            dest: SUPPRESS,
            default: SUPPRESS,
            help: "show program's version number and exit"
        })

        super({
            option_strings,
            dest,
            default: default_value,
            nargs: 0,
            help
        })
        this.version = version
    }

    call(parser/*, namespace, values, option_string = undefined*/) {
        let version = this.version
        if (version === undefined) {
            version = parser.version
        }
        let formatter = parser._get_formatter()
        formatter.add_text(version)
        parser._print_message(formatter.format_help(), process.stdout)
        parser.exit()
    }
})


const _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {

    constructor() {
        let [
            option_strings,
            prog,
            parser_class,
            dest,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            prog: no_default,
            parser_class: no_default,
            dest: SUPPRESS,
            required: false,
            help: undefined,
            metavar: undefined
        })

        let name_parser_map = {}

        super({
            option_strings,
            dest,
            nargs: PARSER,
            choices: name_parser_map,
            required,
            help,
            metavar
        })

        this._prog_prefix = prog
        this._parser_class = parser_class
        this._name_parser_map = name_parser_map
        this._choices_actions = []
    }

    add_parser() {
        let [
            name,
            kwargs
        ] = _parse_opts(arguments, {
            name: no_default,
            '**kwargs': no_default
        })

        // set prog from the existing prefix
        if (kwargs.prog === undefined) {
            kwargs.prog = sub('%s %s', this._prog_prefix, name)
        }

        let aliases = getattr(kwargs, 'aliases', [])
        delete kwargs.aliases

        // create a pseudo-action to hold the choice help
        if ('help' in kwargs) {
            let help = kwargs.help
            delete kwargs.help
            let choice_action = this._ChoicesPseudoAction(name, aliases, help)
            this._choices_actions.push(choice_action)
        }

        // create the parser and add it to the map
        let parser = new this._parser_class(kwargs)
        this._name_parser_map[name] = parser

        // make parser available under aliases also
        for (let alias of aliases) {
            this._name_parser_map[alias] = parser
        }

        return parser
    }

    _get_subactions() {
        return this._choices_actions
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        let parser_name = values[0]
        let arg_strings = values.slice(1)

        // set the parser name if requested
        if (this.dest !== SUPPRESS) {
            setattr(namespace, this.dest, parser_name)
        }

        // select the parser
        if (hasattr(this._name_parser_map, parser_name)) {
            parser = this._name_parser_map[parser_name]
        } else {
            let args = {parser_name,
                        choices: this._name_parser_map.join(', ')}
            let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args)
            throw new ArgumentError(this, msg)
        }

        // parse all the remaining options into the namespace
        // store any unrecognized options on the object, so that the top
        // level parser can decide what to do with them

        // In case this subparser defines new defaults, we parse them
        // in a new namespace object and then update the original
        // namespace for the relevant parts.
        let subnamespace
        [ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)
        for (let [ key, value ] of Object.entries(subnamespace)) {
            setattr(namespace, key, value)
        }

        if (arg_strings.length) {
            setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])
            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)
        }
    }
}))


_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {
    constructor(name, aliases, help) {
        let metavar = name, dest = name
        if (aliases.length) {
            metavar += sub(' (%s)', aliases.join(', '))
        }
        super({ option_strings: [], dest, help, metavar })
    }
})


const _ExtendAction = _callable(class _ExtendAction extends _AppendAction {
    call(parser, namespace, values/*, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items = items.concat(values)
        setattr(namespace, this.dest, items)
    }
})


// ==============
// Type classes
// ==============
const FileType = _callable(class FileType extends Function {
    /*
     *  Factory for creating file object types
     *
     *  Instances of FileType are typically passed as type= arguments to the
     *  ArgumentParser add_argument() method.
     *
     *  Keyword Arguments:
     *      - mode -- A string indicating how the file is to be opened. Accepts the
     *          same values as the builtin open() function.
     *      - bufsize -- The file's desired buffer size. Accepts the same values as
     *          the builtin open() function.
     *      - encoding -- The file's encoding. Accepts the same values as the
     *          builtin open() function.
     *      - errors -- A string indicating how encoding and decoding errors are to
     *          be handled. Accepts the same value as the builtin open() function.
     */

    constructor() {
        let [
            flags,
            encoding,
            mode,
            autoClose,
            emitClose,
            start,
            end,
            highWaterMark,
            fs
        ] = _parse_opts(arguments, {
            flags: 'r',
            encoding: undefined,
            mode: undefined, // 0o666
            autoClose: undefined, // true
            emitClose: undefined, // false
            start: undefined, // 0
            end: undefined, // Infinity
            highWaterMark: undefined, // 64 * 1024
            fs: undefined
        })

        // when this class is called as a function, redirect it to .call() method of itself
        super('return arguments.callee.call.apply(arguments.callee, arguments)')

        Object.defineProperty(this, 'name', {
            get() {
                return sub('FileType(%r)', flags)
            }
        })
        this._flags = flags
        this._options = {}
        if (encoding !== undefined) this._options.encoding = encoding
        if (mode !== undefined) this._options.mode = mode
        if (autoClose !== undefined) this._options.autoClose = autoClose
        if (emitClose !== undefined) this._options.emitClose = emitClose
        if (start !== undefined) this._options.start = start
        if (end !== undefined) this._options.end = end
        if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark
        if (fs !== undefined) this._options.fs = fs
    }

    call(string) {
        // the special argument "-" means sys.std{in,out}
        if (string === '-') {
            if (this._flags.includes('r')) {
                return process.stdin
            } else if (this._flags.includes('w')) {
                return process.stdout
            } else {
                let msg = sub('argument "-" with mode %r', this._flags)
                throw new TypeError(msg)
            }
        }

        // all other arguments are used as file names
        let fd
        try {
            fd = fs.openSync(string, this._flags, this._options.mode)
        } catch (e) {
            let args = { filename: string, error: e.message }
            let message = "can't open '%(filename)s': %(error)s"
            throw new ArgumentTypeError(sub(message, args))
        }

        let options = Object.assign({ fd, flags: this._flags }, this._options)
        if (this._flags.includes('r')) {
            return fs.createReadStream(undefined, options)
        } else if (this._flags.includes('w')) {
            return fs.createWriteStream(undefined, options)
        } else {
            let msg = sub('argument "%s" with mode %r', string, this._flags)
            throw new TypeError(msg)
        }
    }

    [util.inspect.custom]() {
        let args = [ this._flags ]
        let kwargs = Object.entries(this._options).map(([ k, v ]) => {
            if (k === 'mode') v = { value: v, [util.inspect.custom]() { return '0o' + this.value.toString(8) } }
            return [ k, v ]
        })
        let args_str = []
                .concat(args.filter(arg => arg !== -1).map(repr))
                .concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined)
                    .map(([kw, arg]) => sub('%s=%r', kw, arg)))
                .join(', ')
        return sub('%s(%s)', this.constructor.name, args_str)
    }

    toString() {
        return this[util.inspect.custom]()
    }
})

// ===========================
// Optional and Positional Parsing
// ===========================
const Namespace = _callable(class Namespace extends _AttributeHolder() {
    /*
     *  Simple object for storing attributes.
     *
     *  Implements equality by attribute names and values, and provides a simple
     *  string representation.
     */

    constructor(options = {}) {
        super()
        Object.assign(this, options)
    }
})

// unset string tag to mimic plain object
Namespace.prototype[Symbol.toStringTag] = undefined


const _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {

    constructor() {
        let [
            description,
            prefix_chars,
            argument_default,
            conflict_handler
        ] = _parse_opts(arguments, {
            description: no_default,
            prefix_chars: no_default,
            argument_default: no_default,
            conflict_handler: no_default
        })

        this.description = description
        this.argument_default = argument_default
        this.prefix_chars = prefix_chars
        this.conflict_handler = conflict_handler

        // set up registries
        this._registries = {}

        // register actions
        this.register('action', undefined, _StoreAction)
        this.register('action', 'store', _StoreAction)
        this.register('action', 'store_const', _StoreConstAction)
        this.register('action', 'store_true', _StoreTrueAction)
        this.register('action', 'store_false', _StoreFalseAction)
        this.register('action', 'append', _AppendAction)
        this.register('action', 'append_const', _AppendConstAction)
        this.register('action', 'count', _CountAction)
        this.register('action', 'help', _HelpAction)
        this.register('action', 'version', _VersionAction)
        this.register('action', 'parsers', _SubParsersAction)
        this.register('action', 'extend', _ExtendAction)
        // LEGACY (v1 compatibility): camelcase variants
        ;[ 'storeConst', 'storeTrue', 'storeFalse', 'appendConst' ].forEach(old_name => {
            let new_name = _to_new_name(old_name)
            this.register('action', old_name, util.deprecate(this._registry_get('action', new_name),
                sub('{action: "%s"} is renamed to {action: "%s"}', old_name, new_name)))
        })
        // end

        // raise an exception if the conflict handler is invalid
        this._get_handler()

        // action storage
        this._actions = []
        this._option_string_actions = {}

        // groups
        this._action_groups = []
        this._mutually_exclusive_groups = []

        // defaults storage
        this._defaults = {}

        // determines whether an "option" looks like a negative number
        this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/

        // whether or not there are any optionals that look like negative
        // numbers -- uses a list so it can be shared and edited
        this._has_negative_number_optionals = []
    }

    // ====================
    // Registration methods
    // ====================
    register(registry_name, value, object) {
        let registry = setdefault(this._registries, registry_name, {})
        registry[value] = object
    }

    _registry_get(registry_name, value, default_value = undefined) {
        return getattr(this._registries[registry_name], value, default_value)
    }

    // ==================================
    // Namespace default accessor methods
    // ==================================
    set_defaults(kwargs) {
        Object.assign(this._defaults, kwargs)

        // if these defaults match any existing arguments, replace
        // the previous default on the object with the new one
        for (let action of this._actions) {
            if (action.dest in kwargs) {
                action.default = kwargs[action.dest]
            }
        }
    }

    get_default(dest) {
        for (let action of this._actions) {
            if (action.dest === dest && action.default !== undefined) {
                return action.default
            }
        }
        return this._defaults[dest]
    }


    // =======================
    // Adding argument actions
    // =======================
    add_argument() {
        /*
         *  add_argument(dest, ..., name=value, ...)
         *  add_argument(option_string, option_string, ..., name=value, ...)
         */
        let [
            args,
            kwargs
        ] = _parse_opts(arguments, {
            '*args': no_default,
            '**kwargs': no_default
        })
        // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })
        if (args.length === 1 && Array.isArray(args[0])) {
            args = args[0]
            deprecate('argument-array',
                sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {
                    args: args.map(repr).join(', ')
                }))
        }
        // end

        // if no positional args are supplied or only one is supplied and
        // it doesn't look like an option string, parse a positional
        // argument
        let chars = this.prefix_chars
        if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {
            if (args.length && 'dest' in kwargs) {
                throw new TypeError('dest supplied twice for positional argument')
            }
            kwargs = this._get_positional_kwargs(...args, kwargs)

        // otherwise, we're adding an optional argument
        } else {
            kwargs = this._get_optional_kwargs(...args, kwargs)
        }

        // if no default was supplied, use the parser-level default
        if (!('default' in kwargs)) {
            let dest = kwargs.dest
            if (dest in this._defaults) {
                kwargs.default = this._defaults[dest]
            } else if (this.argument_default !== undefined) {
                kwargs.default = this.argument_default
            }
        }

        // create the action object, and add it to the parser
        let action_class = this._pop_action_class(kwargs)
        if (typeof action_class !== 'function') {
            throw new TypeError(sub('unknown action "%s"', action_class))
        }
        // eslint-disable-next-line new-cap
        let action = new action_class(kwargs)

        // raise an error if the action type is not callable
        let type_func = this._registry_get('type', action.type, action.type)
        if (typeof type_func !== 'function') {
            throw new TypeError(sub('%r is not callable', type_func))
        }

        if (type_func === FileType) {
            throw new TypeError(sub('%r is a FileType class object, instance of it' +
                                    ' must be passed', type_func))
        }

        // raise an error if the metavar does not match the type
        if ('_get_formatter' in this) {
            try {
                this._get_formatter()._format_args(action, undefined)
            } catch (err) {
                // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same
                if (err instanceof TypeError && err.message !== 'invalid nargs value') {
                    throw new TypeError('length of metavar tuple does not match nargs')
                } else {
                    throw err
                }
            }
        }

        return this._add_action(action)
    }

    add_argument_group() {
        let group = _ArgumentGroup(this, ...arguments)
        this._action_groups.push(group)
        return group
    }

    add_mutually_exclusive_group() {
        // eslint-disable-next-line no-use-before-define
        let group = _MutuallyExclusiveGroup(this, ...arguments)
        this._mutually_exclusive_groups.push(group)
        return group
    }

    _add_action(action) {
        // resolve any conflicts
        this._check_conflict(action)

        // add to actions list
        this._actions.push(action)
        action.container = this

        // index the action by any option strings it has
        for (let option_string of action.option_strings) {
            this._option_string_actions[option_string] = action
        }

        // set the flag if any option strings look like negative numbers
        for (let option_string of action.option_strings) {
            if (this._negative_number_matcher.test(option_string)) {
                if (!this._has_negative_number_optionals.length) {
                    this._has_negative_number_optionals.push(true)
                }
            }
        }

        // return the created action
        return action
    }

    _remove_action(action) {
        _array_remove(this._actions, action)
    }

    _add_container_actions(container) {
        // collect groups by titles
        let title_group_map = {}
        for (let group of this._action_groups) {
            if (group.title in title_group_map) {
                let msg = 'cannot merge actions - two groups are named %r'
                throw new TypeError(sub(msg, group.title))
            }
            title_group_map[group.title] = group
        }

        // map each action to its group
        let group_map = new Map()
        for (let group of container._action_groups) {

            // if a group with the title exists, use that, otherwise
            // create a new group matching the container's group
            if (!(group.title in title_group_map)) {
                title_group_map[group.title] = this.add_argument_group({
                    title: group.title,
                    description: group.description,
                    conflict_handler: group.conflict_handler
                })
            }

            // map the actions to their new group
            for (let action of group._group_actions) {
                group_map.set(action, title_group_map[group.title])
            }
        }

        // add container's mutually exclusive groups
        // NOTE: if add_mutually_exclusive_group ever gains title= and
        // description= then this code will need to be expanded as above
        for (let group of container._mutually_exclusive_groups) {
            let mutex_group = this.add_mutually_exclusive_group({
                required: group.required
            })

            // map the actions to their new mutex group
            for (let action of group._group_actions) {
                group_map.set(action, mutex_group)
            }
        }

        // add all actions to this container or their group
        for (let action of container._actions) {
            group_map.get(action)._add_action(action)
        }
    }

    _get_positional_kwargs() {
        let [
            dest,
            kwargs
        ] = _parse_opts(arguments, {
            dest: no_default,
            '**kwargs': no_default
        })

        // make sure required is not specified
        if ('required' in kwargs) {
            let msg = "'required' is an invalid argument for positionals"
            throw new TypeError(msg)
        }

        // mark positional arguments as required if at least one is
        // always required
        if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {
            kwargs.required = true
        }
        if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {
            kwargs.required = true
        }

        // return the keyword arguments with no option strings
        return Object.assign(kwargs, { dest, option_strings: [] })
    }

    _get_optional_kwargs() {
        let [
            args,
            kwargs
        ] = _parse_opts(arguments, {
            '*args': no_default,
            '**kwargs': no_default
        })

        // determine short and long option strings
        let option_strings = []
        let long_option_strings = []
        let option_string
        for (option_string of args) {
            // error on strings that don't start with an appropriate prefix
            if (!this.prefix_chars.includes(option_string[0])) {
                let args = {option: option_string,
                            prefix_chars: this.prefix_chars}
                let msg = 'invalid option string %(option)r: ' +
                          'must start with a character %(prefix_chars)r'
                throw new TypeError(sub(msg, args))
            }

            // strings starting with two prefix characters are long options
            option_strings.push(option_string)
            if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {
                long_option_strings.push(option_string)
            }
        }

        // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
        let dest = kwargs.dest
        delete kwargs.dest
        if (dest === undefined) {
            let dest_option_string
            if (long_option_strings.length) {
                dest_option_string = long_option_strings[0]
            } else {
                dest_option_string = option_strings[0]
            }
            dest = _string_lstrip(dest_option_string, this.prefix_chars)
            if (!dest) {
                let msg = 'dest= is required for options like %r'
                throw new TypeError(sub(msg, option_string))
            }
            dest = dest.replace(/-/g, '_')
        }

        // return the updated keyword arguments
        return Object.assign(kwargs, { dest, option_strings })
    }

    _pop_action_class(kwargs, default_value = undefined) {
        let action = getattr(kwargs, 'action', default_value)
        delete kwargs.action
        return this._registry_get('action', action, action)
    }

    _get_handler() {
        // determine function from conflict handler string
        let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler)
        if (typeof this[handler_func_name] === 'function') {
            return this[handler_func_name]
        } else {
            let msg = 'invalid conflict_resolution value: %r'
            throw new TypeError(sub(msg, this.conflict_handler))
        }
    }

    _check_conflict(action) {

        // find all options that conflict with this option
        let confl_optionals = []
        for (let option_string of action.option_strings) {
            if (hasattr(this._option_string_actions, option_string)) {
                let confl_optional = this._option_string_actions[option_string]
                confl_optionals.push([ option_string, confl_optional ])
            }
        }

        // resolve any conflicts
        if (confl_optionals.length) {
            let conflict_handler = this._get_handler()
            conflict_handler.call(this, action, confl_optionals)
        }
    }

    _handle_conflict_error(action, conflicting_actions) {
        let message = conflicting_actions.length === 1 ?
            'conflicting option string: %s' :
            'conflicting option strings: %s'
        let conflict_string = conflicting_actions.map(([ option_string/*, action*/ ]) => option_string).join(', ')
        throw new ArgumentError(action, sub(message, conflict_string))
    }

    _handle_conflict_resolve(action, conflicting_actions) {

        // remove all conflicting options
        for (let [ option_string, action ] of conflicting_actions) {

            // remove the conflicting option
            _array_remove(action.option_strings, option_string)
            delete this._option_string_actions[option_string]

            // if the option now has no option string, remove it from the
            // container holding it
            if (!action.option_strings.length) {
                action.container._remove_action(action)
            }
        }
    }
}))


const _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {

    constructor() {
        let [
            container,
            title,
            description,
            kwargs
        ] = _parse_opts(arguments, {
            container: no_default,
            title: undefined,
            description: undefined,
            '**kwargs': no_default
        })

        // add any missing keyword arguments by checking the container
        setdefault(kwargs, 'conflict_handler', container.conflict_handler)
        setdefault(kwargs, 'prefix_chars', container.prefix_chars)
        setdefault(kwargs, 'argument_default', container.argument_default)
        super(Object.assign({ description }, kwargs))

        // group attributes
        this.title = title
        this._group_actions = []

        // share most attributes with the container
        this._registries = container._registries
        this._actions = container._actions
        this._option_string_actions = container._option_string_actions
        this._defaults = container._defaults
        this._has_negative_number_optionals =
            container._has_negative_number_optionals
        this._mutually_exclusive_groups = container._mutually_exclusive_groups
    }

    _add_action(action) {
        action = super._add_action(action)
        this._group_actions.push(action)
        return action
    }

    _remove_action(action) {
        super._remove_action(action)
        _array_remove(this._group_actions, action)
    }
})


const _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {

    constructor() {
        let [
            container,
            required
        ] = _parse_opts(arguments, {
            container: no_default,
            required: false
        })

        super(container)
        this.required = required
        this._container = container
    }

    _add_action(action) {
        if (action.required) {
            let msg = 'mutually exclusive arguments must be optional'
            throw new TypeError(msg)
        }
        action = this._container._add_action(action)
        this._group_actions.push(action)
        return action
    }

    _remove_action(action) {
        this._container._remove_action(action)
        _array_remove(this._group_actions, action)
    }
})


const ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {
    /*
     *  Object for parsing command line strings into Python objects.
     *
     *  Keyword Arguments:
     *      - prog -- The name of the program (default: sys.argv[0])
     *      - usage -- A usage message (default: auto-generated from arguments)
     *      - description -- A description of what the program does
     *      - epilog -- Text following the argument descriptions
     *      - parents -- Parsers whose arguments should be copied into this one
     *      - formatter_class -- HelpFormatter class for printing help messages
     *      - prefix_chars -- Characters that prefix optional arguments
     *      - fromfile_prefix_chars -- Characters that prefix files containing
     *          additional arguments
     *      - argument_default -- The default value for all arguments
     *      - conflict_handler -- String indicating how to handle conflicts
     *      - add_help -- Add a -h/-help option
     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously
     *      - exit_on_error -- Determines whether or not ArgumentParser exits with
     *          error info when an error occurs
     */

    constructor() {
        let [
            prog,
            usage,
            description,
            epilog,
            parents,
            formatter_class,
            prefix_chars,
            fromfile_prefix_chars,
            argument_default,
            conflict_handler,
            add_help,
            allow_abbrev,
            exit_on_error,
            debug, // LEGACY (v1 compatibility), debug mode
            version // LEGACY (v1 compatibility), version
        ] = _parse_opts(arguments, {
            prog: undefined,
            usage: undefined,
            description: undefined,
            epilog: undefined,
            parents: [],
            formatter_class: HelpFormatter,
            prefix_chars: '-',
            fromfile_prefix_chars: undefined,
            argument_default: undefined,
            conflict_handler: 'error',
            add_help: true,
            allow_abbrev: true,
            exit_on_error: true,
            debug: undefined, // LEGACY (v1 compatibility), debug mode
            version: undefined // LEGACY (v1 compatibility), version
        })

        // LEGACY (v1 compatibility)
        if (debug !== undefined) {
            deprecate('debug',
                'The "debug" argument to ArgumentParser is deprecated. Please ' +
                'override ArgumentParser.exit function instead.'
            )
        }

        if (version !== undefined) {
            deprecate('version',
                'The "version" argument to ArgumentParser is deprecated. Please use ' +
                "add_argument(..., { action: 'version', version: 'N', ... }) instead."
            )
        }
        // end

        super({
            description,
            prefix_chars,
            argument_default,
            conflict_handler
        })

        // default setting for prog
        if (prog === undefined) {
            prog = path.basename(get_argv()[0] || '')
        }

        this.prog = prog
        this.usage = usage
        this.epilog = epilog
        this.formatter_class = formatter_class
        this.fromfile_prefix_chars = fromfile_prefix_chars
        this.add_help = add_help
        this.allow_abbrev = allow_abbrev
        this.exit_on_error = exit_on_error
        // LEGACY (v1 compatibility), debug mode
        this.debug = debug
        // end

        this._positionals = this.add_argument_group('positional arguments')
        this._optionals = this.add_argument_group('optional arguments')
        this._subparsers = undefined

        // register types
        function identity(string) {
            return string
        }
        this.register('type', undefined, identity)
        this.register('type', null, identity)
        this.register('type', 'auto', identity)
        this.register('type', 'int', function (x) {
            let result = Number(x)
            if (!Number.isInteger(result)) {
                throw new TypeError(sub('could not convert string to int: %r', x))
            }
            return result
        })
        this.register('type', 'float', function (x) {
            let result = Number(x)
            if (isNaN(result)) {
                throw new TypeError(sub('could not convert string to float: %r', x))
            }
            return result
        })
        this.register('type', 'str', String)
        // LEGACY (v1 compatibility): custom types
        this.register('type', 'string',
            util.deprecate(String, 'use {type:"str"} or {type:String} instead of {type:"string"}'))
        // end

        // add help argument if necessary
        // (using explicit default to override global argument_default)
        let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0]
        if (this.add_help) {
            this.add_argument(
                default_prefix + 'h',
                default_prefix.repeat(2) + 'help',
                {
                    action: 'help',
                    default: SUPPRESS,
                    help: 'show this help message and exit'
                }
            )
        }
        // LEGACY (v1 compatibility), version
        if (version) {
            this.add_argument(
                default_prefix + 'v',
                default_prefix.repeat(2) + 'version',
                {
                    action: 'version',
                    default: SUPPRESS,
                    version: this.version,
                    help: "show program's version number and exit"
                }
            )
        }
        // end

        // add parent arguments and defaults
        for (let parent of parents) {
            this._add_container_actions(parent)
            Object.assign(this._defaults, parent._defaults)
        }
    }

    // =======================
    // Pretty __repr__ methods
    // =======================
    _get_kwargs() {
        let names = [
            'prog',
            'usage',
            'description',
            'formatter_class',
            'conflict_handler',
            'add_help'
        ]
        return names.map(name => [ name, getattr(this, name) ])
    }

    // ==================================
    // Optional/Positional adding methods
    // ==================================
    add_subparsers() {
        let [
            kwargs
        ] = _parse_opts(arguments, {
            '**kwargs': no_default
        })

        if (this._subparsers !== undefined) {
            this.error('cannot have multiple subparser arguments')
        }

        // add the parser class to the arguments if it's not present
        setdefault(kwargs, 'parser_class', this.constructor)

        if ('title' in kwargs || 'description' in kwargs) {
            let title = getattr(kwargs, 'title', 'subcommands')
            let description = getattr(kwargs, 'description', undefined)
            delete kwargs.title
            delete kwargs.description
            this._subparsers = this.add_argument_group(title, description)
        } else {
            this._subparsers = this._positionals
        }

        // prog defaults to the usage message of this parser, skipping
        // optional arguments and with no "usage:" prefix
        if (kwargs.prog === undefined) {
            let formatter = this._get_formatter()
            let positionals = this._get_positional_actions()
            let groups = this._mutually_exclusive_groups
            formatter.add_usage(this.usage, positionals, groups, '')
            kwargs.prog = formatter.format_help().trim()
        }

        // create the parsers action and add it to the positionals list
        let parsers_class = this._pop_action_class(kwargs, 'parsers')
        // eslint-disable-next-line new-cap
        let action = new parsers_class(Object.assign({ option_strings: [] }, kwargs))
        this._subparsers._add_action(action)

        // return the created parsers action
        return action
    }

    _add_action(action) {
        if (action.option_strings.length) {
            this._optionals._add_action(action)
        } else {
            this._positionals._add_action(action)
        }
        return action
    }

    _get_optional_actions() {
        return this._actions.filter(action => action.option_strings.length)
    }

    _get_positional_actions() {
        return this._actions.filter(action => !action.option_strings.length)
    }

    // =====================================
    // Command line argument parsing methods
    // =====================================
    parse_args(args = undefined, namespace = undefined) {
        let argv
        [ args, argv ] = this.parse_known_args(args, namespace)
        if (argv && argv.length > 0) {
            let msg = 'unrecognized arguments: %s'
            this.error(sub(msg, argv.join(' ')))
        }
        return args
    }

    parse_known_args(args = undefined, namespace = undefined) {
        if (args === undefined) {
            args = get_argv().slice(1)
        }

        // default Namespace built from parser defaults
        if (namespace === undefined) {
            namespace = new Namespace()
        }

        // add any action defaults that aren't present
        for (let action of this._actions) {
            if (action.dest !== SUPPRESS) {
                if (!hasattr(namespace, action.dest)) {
                    if (action.default !== SUPPRESS) {
                        setattr(namespace, action.dest, action.default)
                    }
                }
            }
        }

        // add any parser defaults that aren't present
        for (let dest of Object.keys(this._defaults)) {
            if (!hasattr(namespace, dest)) {
                setattr(namespace, dest, this._defaults[dest])
            }
        }

        // parse the arguments and exit if there are any errors
        if (this.exit_on_error) {
            try {
                [ namespace, args ] = this._parse_known_args(args, namespace)
            } catch (err) {
                if (err instanceof ArgumentError) {
                    this.error(err.message)
                } else {
                    throw err
                }
            }
        } else {
            [ namespace, args ] = this._parse_known_args(args, namespace)
        }

        if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {
            args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)
        }

        return [ namespace, args ]
    }

    _parse_known_args(arg_strings, namespace) {
        // replace arg strings that are file references
        if (this.fromfile_prefix_chars !== undefined) {
            arg_strings = this._read_args_from_files(arg_strings)
        }

        // map all mutually exclusive arguments to the other arguments
        // they can't occur with
        let action_conflicts = new Map()
        for (let mutex_group of this._mutually_exclusive_groups) {
            let group_actions = mutex_group._group_actions
            for (let [ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {
                let conflicts = action_conflicts.get(mutex_action) || []
                conflicts = conflicts.concat(group_actions.slice(0, +i))
                conflicts = conflicts.concat(group_actions.slice(+i + 1))
                action_conflicts.set(mutex_action, conflicts)
            }
        }

        // find all option indices, and determine the arg_string_pattern
        // which has an 'O' if there is an option at an index,
        // an 'A' if there is an argument, or a '-' if there is a '--'
        let option_string_indices = {}
        let arg_string_pattern_parts = []
        let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()
        for (let [ i, arg_string ] of arg_strings_iter) {

            // all args after -- are non-options
            if (arg_string === '--') {
                arg_string_pattern_parts.push('-')
                for ([ i, arg_string ] of arg_strings_iter) {
                    arg_string_pattern_parts.push('A')
                }

            // otherwise, add the arg to the arg strings
            // and note the index if it was an option
            } else {
                let option_tuple = this._parse_optional(arg_string)
                let pattern
                if (option_tuple === undefined) {
                    pattern = 'A'
                } else {
                    option_string_indices[i] = option_tuple
                    pattern = 'O'
                }
                arg_string_pattern_parts.push(pattern)
            }
        }

        // join the pieces together to form the pattern
        let arg_strings_pattern = arg_string_pattern_parts.join('')

        // converts arg strings to the appropriate and then takes the action
        let seen_actions = new Set()
        let seen_non_default_actions = new Set()
        let extras

        let take_action = (action, argument_strings, option_string = undefined) => {
            seen_actions.add(action)
            let argument_values = this._get_values(action, argument_strings)

            // error if this argument is not allowed with other previously
            // seen arguments, assuming that actions that use the default
            // value don't really count as "present"
            if (argument_values !== action.default) {
                seen_non_default_actions.add(action)
                for (let conflict_action of action_conflicts.get(action) || []) {
                    if (seen_non_default_actions.has(conflict_action)) {
                        let msg = 'not allowed with argument %s'
                        let action_name = _get_action_name(conflict_action)
                        throw new ArgumentError(action, sub(msg, action_name))
                    }
                }
            }

            // take the action if we didn't receive a SUPPRESS value
            // (e.g. from a default)
            if (argument_values !== SUPPRESS) {
                action(this, namespace, argument_values, option_string)
            }
        }

        // function to convert arg_strings into an optional action
        let consume_optional = start_index => {

            // get the optional identified at this index
            let option_tuple = option_string_indices[start_index]
            let [ action, option_string, explicit_arg ] = option_tuple

            // identify additional optionals in the same arg string
            // (e.g. -xyz is the same as -x -y -z if no args are required)
            let action_tuples = []
            let stop
            for (;;) {

                // if we found no optional action, skip it
                if (action === undefined) {
                    extras.push(arg_strings[start_index])
                    return start_index + 1
                }

                // if there is an explicit argument, try to match the
                // optional's string arguments to only this
                if (explicit_arg !== undefined) {
                    let arg_count = this._match_argument(action, 'A')

                    // if the action is a single-dash option and takes no
                    // arguments, try to parse more single-dash options out
                    // of the tail of the option string
                    let chars = this.prefix_chars
                    if (arg_count === 0 && !chars.includes(option_string[1])) {
                        action_tuples.push([ action, [], option_string ])
                        let char = option_string[0]
                        option_string = char + explicit_arg[0]
                        let new_explicit_arg = explicit_arg.slice(1) || undefined
                        let optionals_map = this._option_string_actions
                        if (hasattr(optionals_map, option_string)) {
                            action = optionals_map[option_string]
                            explicit_arg = new_explicit_arg
                        } else {
                            let msg = 'ignored explicit argument %r'
                            throw new ArgumentError(action, sub(msg, explicit_arg))
                        }

                    // if the action expect exactly one argument, we've
                    // successfully matched the option; exit the loop
                    } else if (arg_count === 1) {
                        stop = start_index + 1
                        let args = [ explicit_arg ]
                        action_tuples.push([ action, args, option_string ])
                        break

                    // error if a double-dash option did not use the
                    // explicit argument
                    } else {
                        let msg = 'ignored explicit argument %r'
                        throw new ArgumentError(action, sub(msg, explicit_arg))
                    }

                // if there is no explicit argument, try to match the
                // optional's string arguments with the following strings
                // if successful, exit the loop
                } else {
                    let start = start_index + 1
                    let selected_patterns = arg_strings_pattern.slice(start)
                    let arg_count = this._match_argument(action, selected_patterns)
                    stop = start + arg_count
                    let args = arg_strings.slice(start, stop)
                    action_tuples.push([ action, args, option_string ])
                    break
                }
            }

            // add the Optional to the list and return the index at which
            // the Optional's string args stopped
            assert(action_tuples.length)
            for (let [ action, args, option_string ] of action_tuples) {
                take_action(action, args, option_string)
            }
            return stop
        }

        // the list of Positionals left to be parsed; this is modified
        // by consume_positionals()
        let positionals = this._get_positional_actions()

        // function to convert arg_strings into positional actions
        let consume_positionals = start_index => {
            // match as many Positionals as possible
            let selected_pattern = arg_strings_pattern.slice(start_index)
            let arg_counts = this._match_arguments_partial(positionals, selected_pattern)

            // slice off the appropriate arg strings for each Positional
            // and add the Positional and its args to the list
            for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {
                let action = positionals[i]
                let arg_count = arg_counts[i]
                let args = arg_strings.slice(start_index, start_index + arg_count)
                start_index += arg_count
                take_action(action, args)
            }

            // slice off the Positionals that we just parsed and return the
            // index at which the Positionals' string args stopped
            positionals = positionals.slice(arg_counts.length)
            return start_index
        }

        // consume Positionals and Optionals alternately, until we have
        // passed the last option string
        extras = []
        let start_index = 0
        let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number))
        while (start_index <= max_option_string_index) {

            // consume any Positionals preceding the next option
            let next_option_string_index = Math.min(
                // eslint-disable-next-line no-loop-func
                ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index)
            )
            if (start_index !== next_option_string_index) {
                let positionals_end_index = consume_positionals(start_index)

                // only try to parse the next optional if we didn't consume
                // the option string during the positionals parsing
                if (positionals_end_index > start_index) {
                    start_index = positionals_end_index
                    continue
                } else {
                    start_index = positionals_end_index
                }
            }

            // if we consumed all the positionals we could and we're not
            // at the index of an option string, there were extra arguments
            if (!(start_index in option_string_indices)) {
                let strings = arg_strings.slice(start_index, next_option_string_index)
                extras = extras.concat(strings)
                start_index = next_option_string_index
            }

            // consume the next optional and any arguments for it
            start_index = consume_optional(start_index)
        }

        // consume any positionals following the last Optional
        let stop_index = consume_positionals(start_index)

        // if we didn't consume all the argument strings, there were extras
        extras = extras.concat(arg_strings.slice(stop_index))

        // make sure all required actions were present and also convert
        // action defaults which were not given as arguments
        let required_actions = []
        for (let action of this._actions) {
            if (!seen_actions.has(action)) {
                if (action.required) {
                    required_actions.push(_get_action_name(action))
                } else {
                    // Convert action default now instead of doing it before
                    // parsing arguments to avoid calling convert functions
                    // twice (which may fail) if the argument was given, but
                    // only if it was defined already in the namespace
                    if (action.default !== undefined &&
                        typeof action.default === 'string' &&
                        hasattr(namespace, action.dest) &&
                        action.default === getattr(namespace, action.dest)) {
                        setattr(namespace, action.dest,
                                this._get_value(action, action.default))
                    }
                }
            }
        }

        if (required_actions.length) {
            this.error(sub('the following arguments are required: %s',
                       required_actions.join(', ')))
        }

        // make sure all required groups had one option present
        for (let group of this._mutually_exclusive_groups) {
            if (group.required) {
                let no_actions_used = true
                for (let action of group._group_actions) {
                    if (seen_non_default_actions.has(action)) {
                        no_actions_used = false
                        break
                    }
                }

                // if no actions were used, report the error
                if (no_actions_used) {
                    let names = group._group_actions
                        .filter(action => action.help !== SUPPRESS)
                        .map(action => _get_action_name(action))
                    let msg = 'one of the arguments %s is required'
                    this.error(sub(msg, names.join(' ')))
                }
            }
        }

        // return the updated namespace and the extra arguments
        return [ namespace, extras ]
    }

    _read_args_from_files(arg_strings) {
        // expand arguments referencing files
        let new_arg_strings = []
        for (let arg_string of arg_strings) {

            // for regular arguments, just add them back into the list
            if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {
                new_arg_strings.push(arg_string)

            // replace arguments referencing files with the file content
            } else {
                try {
                    let args_file = fs.readFileSync(arg_string.slice(1), 'utf8')
                    let arg_strings = []
                    for (let arg_line of splitlines(args_file)) {
                        for (let arg of this.convert_arg_line_to_args(arg_line)) {
                            arg_strings.push(arg)
                        }
                    }
                    arg_strings = this._read_args_from_files(arg_strings)
                    new_arg_strings = new_arg_strings.concat(arg_strings)
                } catch (err) {
                    this.error(err.message)
                }
            }
        }

        // return the modified argument list
        return new_arg_strings
    }

    convert_arg_line_to_args(arg_line) {
        return [arg_line]
    }

    _match_argument(action, arg_strings_pattern) {
        // match the pattern for this action to the arg strings
        let nargs_pattern = this._get_nargs_pattern(action)
        let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern))

        // raise an exception if we weren't able to find a match
        if (match === null) {
            let nargs_errors = {
                undefined: 'expected one argument',
                [OPTIONAL]: 'expected at most one argument',
                [ONE_OR_MORE]: 'expected at least one argument'
            }
            let msg = nargs_errors[action.nargs]
            if (msg === undefined) {
                msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs)
            }
            throw new ArgumentError(action, msg)
        }

        // return the number of arguments matched
        return match[1].length
    }

    _match_arguments_partial(actions, arg_strings_pattern) {
        // progressively shorten the actions list by slicing off the
        // final actions until we find a match
        let result = []
        for (let i of range(actions.length, 0, -1)) {
            let actions_slice = actions.slice(0, i)
            let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('')
            let match = arg_strings_pattern.match(new RegExp('^' + pattern))
            if (match !== null) {
                result = result.concat(match.slice(1).map(string => string.length))
                break
            }
        }

        // return the list of arg string counts
        return result
    }

    _parse_optional(arg_string) {
        // if it's an empty string, it was meant to be a positional
        if (!arg_string) {
            return undefined
        }

        // if it doesn't start with a prefix, it was meant to be positional
        if (!this.prefix_chars.includes(arg_string[0])) {
            return undefined
        }

        // if the option string is present in the parser, return the action
        if (arg_string in this._option_string_actions) {
            let action = this._option_string_actions[arg_string]
            return [ action, arg_string, undefined ]
        }

        // if it's just a single character, it was meant to be positional
        if (arg_string.length === 1) {
            return undefined
        }

        // if the option string before the "=" is present, return the action
        if (arg_string.includes('=')) {
            let [ option_string, explicit_arg ] = _string_split(arg_string, '=', 1)
            if (option_string in this._option_string_actions) {
                let action = this._option_string_actions[option_string]
                return [ action, option_string, explicit_arg ]
            }
        }

        // search through all possible prefixes of the option string
        // and all actions in the parser for possible interpretations
        let option_tuples = this._get_option_tuples(arg_string)

        // if multiple actions match, the option string was ambiguous
        if (option_tuples.length > 1) {
            let options = option_tuples.map(([ /*action*/, option_string/*, explicit_arg*/ ]) => option_string).join(', ')
            let args = {option: arg_string, matches: options}
            let msg = 'ambiguous option: %(option)s could match %(matches)s'
            this.error(sub(msg, args))

        // if exactly one action matched, this segmentation is good,
        // so return the parsed action
        } else if (option_tuples.length === 1) {
            let [ option_tuple ] = option_tuples
            return option_tuple
        }

        // if it was not found as an option, but it looks like a negative
        // number, it was meant to be positional
        // unless there are negative-number-like options
        if (this._negative_number_matcher.test(arg_string)) {
            if (!this._has_negative_number_optionals.length) {
                return undefined
            }
        }

        // if it contains a space, it was meant to be a positional
        if (arg_string.includes(' ')) {
            return undefined
        }

        // it was meant to be an optional but there is no such option
        // in this parser (though it might be a valid option in a subparser)
        return [ undefined, arg_string, undefined ]
    }

    _get_option_tuples(option_string) {
        let result = []

        // option strings starting with two prefix characters are only
        // split at the '='
        let chars = this.prefix_chars
        if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {
            if (this.allow_abbrev) {
                let option_prefix, explicit_arg
                if (option_string.includes('=')) {
                    [ option_prefix, explicit_arg ] = _string_split(option_string, '=', 1)
                } else {
                    option_prefix = option_string
                    explicit_arg = undefined
                }
                for (let option_string of Object.keys(this._option_string_actions)) {
                    if (option_string.startsWith(option_prefix)) {
                        let action = this._option_string_actions[option_string]
                        let tup = [ action, option_string, explicit_arg ]
                        result.push(tup)
                    }
                }
            }

        // single character options can be concatenated with their arguments
        // but multiple character options always have to have their argument
        // separate
        } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {
            let option_prefix = option_string
            let explicit_arg = undefined
            let short_option_prefix = option_string.slice(0, 2)
            let short_explicit_arg = option_string.slice(2)

            for (let option_string of Object.keys(this._option_string_actions)) {
                if (option_string === short_option_prefix) {
                    let action = this._option_string_actions[option_string]
                    let tup = [ action, option_string, short_explicit_arg ]
                    result.push(tup)
                } else if (option_string.startsWith(option_prefix)) {
                    let action = this._option_string_actions[option_string]
                    let tup = [ action, option_string, explicit_arg ]
                    result.push(tup)
                }
            }

        // shouldn't ever get here
        } else {
            this.error(sub('unexpected option string: %s', option_string))
        }

        // return the collected option tuples
        return result
    }

    _get_nargs_pattern(action) {
        // in all examples below, we have to allow for '--' args
        // which are represented as '-' in the pattern
        let nargs = action.nargs
        let nargs_pattern

        // the default (None) is assumed to be a single argument
        if (nargs === undefined) {
            nargs_pattern = '(-*A-*)'

        // allow zero or one arguments
        } else if (nargs === OPTIONAL) {
            nargs_pattern = '(-*A?-*)'

        // allow zero or more arguments
        } else if (nargs === ZERO_OR_MORE) {
            nargs_pattern = '(-*[A-]*)'

        // allow one or more arguments
        } else if (nargs === ONE_OR_MORE) {
            nargs_pattern = '(-*A[A-]*)'

        // allow any number of options or arguments
        } else if (nargs === REMAINDER) {
            nargs_pattern = '([-AO]*)'

        // allow one argument followed by any number of options or arguments
        } else if (nargs === PARSER) {
            nargs_pattern = '(-*A[-AO]*)'

        // suppress action, like nargs=0
        } else if (nargs === SUPPRESS) {
            nargs_pattern = '(-*-*)'

        // all others should be integers
        } else {
            nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'))
        }

        // if this is an optional action, -- is not allowed
        if (action.option_strings.length) {
            nargs_pattern = nargs_pattern.replace(/-\*/g, '')
            nargs_pattern = nargs_pattern.replace(/-/g, '')
        }

        // return the pattern
        return nargs_pattern
    }

    // ========================
    // Alt command line argument parsing, allowing free intermix
    // ========================

    parse_intermixed_args(args = undefined, namespace = undefined) {
        let argv
        [ args, argv ] = this.parse_known_intermixed_args(args, namespace)
        if (argv.length) {
            let msg = 'unrecognized arguments: %s'
            this.error(sub(msg, argv.join(' ')))
        }
        return args
    }

    parse_known_intermixed_args(args = undefined, namespace = undefined) {
        // returns a namespace and list of extras
        //
        // positional can be freely intermixed with optionals.  optionals are
        // first parsed with all positional arguments deactivated.  The 'extras'
        // are then parsed.  If the parser definition is incompatible with the
        // intermixed assumptions (e.g. use of REMAINDER, subparsers) a
        // TypeError is raised.
        //
        // positionals are 'deactivated' by setting nargs and default to
        // SUPPRESS.  This blocks the addition of that positional to the
        // namespace

        let extras
        let positionals = this._get_positional_actions()
        let a = positionals.filter(action => [ PARSER, REMAINDER ].includes(action.nargs))
        if (a.length) {
            throw new TypeError(sub('parse_intermixed_args: positional arg' +
                                    ' with nargs=%s', a[0].nargs))
        }

        for (let group of this._mutually_exclusive_groups) {
            for (let action of group._group_actions) {
                if (positionals.includes(action)) {
                    throw new TypeError('parse_intermixed_args: positional in' +
                                        ' mutuallyExclusiveGroup')
                }
            }
        }

        let save_usage
        try {
            save_usage = this.usage
            let remaining_args
            try {
                if (this.usage === undefined) {
                    // capture the full usage for use in error messages
                    this.usage = this.format_usage().slice(7)
                }
                for (let action of positionals) {
                    // deactivate positionals
                    action.save_nargs = action.nargs
                    // action.nargs = 0
                    action.nargs = SUPPRESS
                    action.save_default = action.default
                    action.default = SUPPRESS
                }
                [ namespace, remaining_args ] = this.parse_known_args(args,
                                                                      namespace)
                for (let action of positionals) {
                    // remove the empty positional values from namespace
                    let attr = getattr(namespace, action.dest)
                    if (Array.isArray(attr) && attr.length === 0) {
                        // eslint-disable-next-line no-console
                        console.warn(sub('Do not expect %s in %s', action.dest, namespace))
                        delattr(namespace, action.dest)
                    }
                }
            } finally {
                // restore nargs and usage before exiting
                for (let action of positionals) {
                    action.nargs = action.save_nargs
                    action.default = action.save_default
                }
            }
            let optionals = this._get_optional_actions()
            try {
                // parse positionals.  optionals aren't normally required, but
                // they could be, so make sure they aren't.
                for (let action of optionals) {
                    action.save_required = action.required
                    action.required = false
                }
                for (let group of this._mutually_exclusive_groups) {
                    group.save_required = group.required
                    group.required = false
                }
                [ namespace, extras ] = this.parse_known_args(remaining_args,
                                                              namespace)
            } finally {
                // restore parser values before exiting
                for (let action of optionals) {
                    action.required = action.save_required
                }
                for (let group of this._mutually_exclusive_groups) {
                    group.required = group.save_required
                }
            }
        } finally {
            this.usage = save_usage
        }
        return [ namespace, extras ]
    }

    // ========================
    // Value conversion methods
    // ========================
    _get_values(action, arg_strings) {
        // for everything but PARSER, REMAINDER args, strip out first '--'
        if (![PARSER, REMAINDER].includes(action.nargs)) {
            try {
                _array_remove(arg_strings, '--')
            } catch (err) {}
        }

        let value
        // optional argument produces a default when not present
        if (!arg_strings.length && action.nargs === OPTIONAL) {
            if (action.option_strings.length) {
                value = action.const
            } else {
                value = action.default
            }
            if (typeof value === 'string') {
                value = this._get_value(action, value)
                this._check_value(action, value)
            }

        // when nargs='*' on a positional, if there were no command-line
        // args, use the default if it is anything other than None
        } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE &&
              !action.option_strings.length) {
            if (action.default !== undefined) {
                value = action.default
            } else {
                value = arg_strings
            }
            this._check_value(action, value)

        // single argument or optional argument produces a single value
        } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {
            let arg_string = arg_strings[0]
            value = this._get_value(action, arg_string)
            this._check_value(action, value)

        // REMAINDER arguments convert all values, checking none
        } else if (action.nargs === REMAINDER) {
            value = arg_strings.map(v => this._get_value(action, v))

        // PARSER arguments convert all values, but check only the first
        } else if (action.nargs === PARSER) {
            value = arg_strings.map(v => this._get_value(action, v))
            this._check_value(action, value[0])

        // SUPPRESS argument does not put anything in the namespace
        } else if (action.nargs === SUPPRESS) {
            value = SUPPRESS

        // all other types of nargs produce a list
        } else {
            value = arg_strings.map(v => this._get_value(action, v))
            for (let v of value) {
                this._check_value(action, v)
            }
        }

        // return the converted value
        return value
    }

    _get_value(action, arg_string) {
        let type_func = this._registry_get('type', action.type, action.type)
        if (typeof type_func !== 'function') {
            let msg = '%r is not callable'
            throw new ArgumentError(action, sub(msg, type_func))
        }

        // convert the value to the appropriate type
        let result
        try {
            try {
                result = type_func(arg_string)
            } catch (err) {
                // Dear TC39, why would you ever consider making es6 classes not callable?
                // We had one universal interface, [[Call]], which worked for anything
                // (with familiar this-instanceof guard for classes). Now we have two.
                if (err instanceof TypeError &&
                    /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {
                    // eslint-disable-next-line new-cap
                    result = new type_func(arg_string)
                } else {
                    throw err
                }
            }

        } catch (err) {
            // ArgumentTypeErrors indicate errors
            if (err instanceof ArgumentTypeError) {
                //let name = getattr(action.type, 'name', repr(action.type))
                let msg = err.message
                throw new ArgumentError(action, msg)

            // TypeErrors or ValueErrors also indicate errors
            } else if (err instanceof TypeError) {
                let name = getattr(action.type, 'name', repr(action.type))
                let args = {type: name, value: arg_string}
                let msg = 'invalid %(type)s value: %(value)r'
                throw new ArgumentError(action, sub(msg, args))
            } else {
                throw err
            }
        }

        // return the converted value
        return result
    }

    _check_value(action, value) {
        // converted value must be one of the choices (if specified)
        if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {
            let args = {value,
                        choices: _choices_to_array(action.choices).map(repr).join(', ')}
            let msg = 'invalid choice: %(value)r (choose from %(choices)s)'
            throw new ArgumentError(action, sub(msg, args))
        }
    }

    // =======================
    // Help-formatting methods
    // =======================
    format_usage() {
        let formatter = this._get_formatter()
        formatter.add_usage(this.usage, this._actions,
                            this._mutually_exclusive_groups)
        return formatter.format_help()
    }

    format_help() {
        let formatter = this._get_formatter()

        // usage
        formatter.add_usage(this.usage, this._actions,
                            this._mutually_exclusive_groups)

        // description
        formatter.add_text(this.description)

        // positionals, optionals and user-defined groups
        for (let action_group of this._action_groups) {
            formatter.start_section(action_group.title)
            formatter.add_text(action_group.description)
            formatter.add_arguments(action_group._group_actions)
            formatter.end_section()
        }

        // epilog
        formatter.add_text(this.epilog)

        // determine help from format above
        return formatter.format_help()
    }

    _get_formatter() {
        // eslint-disable-next-line new-cap
        return new this.formatter_class({ prog: this.prog })
    }

    // =====================
    // Help-printing methods
    // =====================
    print_usage(file = undefined) {
        if (file === undefined) file = process.stdout
        this._print_message(this.format_usage(), file)
    }

    print_help(file = undefined) {
        if (file === undefined) file = process.stdout
        this._print_message(this.format_help(), file)
    }

    _print_message(message, file = undefined) {
        if (message) {
            if (file === undefined) file = process.stderr
            file.write(message)
        }
    }

    // ===============
    // Exiting methods
    // ===============
    exit(status = 0, message = undefined) {
        if (message) {
            this._print_message(message, process.stderr)
        }
        process.exit(status)
    }

    error(message) {
        /*
         *  error(message: string)
         *
         *  Prints a usage message incorporating the message to stderr and
         *  exits.
         *
         *  If you override this in a subclass, it should not return -- it
         *  should either exit or raise an exception.
         */

        // LEGACY (v1 compatibility), debug mode
        if (this.debug === true) throw new Error(message)
        // end
        this.print_usage(process.stderr)
        let args = {prog: this.prog, message: message}
        this.exit(2, sub('%(prog)s: error: %(message)s\n', args))
    }
}))


module.exports = {
    ArgumentParser,
    ArgumentError,
    ArgumentTypeError,
    BooleanOptionalAction,
    FileType,
    HelpFormatter,
    ArgumentDefaultsHelpFormatter,
    RawDescriptionHelpFormatter,
    RawTextHelpFormatter,
    MetavarTypeHelpFormatter,
    Namespace,
    Action,
    ONE_OR_MORE,
    OPTIONAL,
    PARSER,
    REMAINDER,
    SUPPRESS,
    ZERO_OR_MORE
}

// LEGACY (v1 compatibility), Const alias
Object.defineProperty(module.exports, 'Const', {
    get() {
        let result = {}
        Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) => {
            Object.defineProperty(result, n, {
                get() {
                    deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n))
                    return v
                }
            })
        })
        Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) => {
            Object.defineProperty(result, n, {
                get() {
                    deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n))
                    return v
                }
            })
        })
        return result
    },
    enumerable: false
})
// end
#!/bin/bash
set -euo pipefail

echo "ğŸ›  Bootstrapping Plan B checklist system..."

# 0. Requirements check
REQUIRED_CMDS=("node" "npm" "git")
for cmd in "${REQUIRED_CMDS[@]}"; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "âŒ Required command '$cmd' is not installed. Please install it and re-run."
    exit 1
  fi
done

# Ensure local Node modules folder exists
mkdir -p node_modules

# 1. Install js-yaml if not present
if ! node -e "require('js-yaml')" &>/dev/null; then
  echo "ğŸ“¦ Installing 'js-yaml' locally..."
  npm install js-yaml --save-dev > /dev/null
else
  echo "âœ… js-yaml is already installed"
fi

# 2. Create structure
mkdir -p docs scripts bin .github/workflows .github/actions/tick-checklist

# 3. YAML source of truth
cat > plan-b2.yaml <<EOF
patches:
  P1: secrets-verify committed and green in CI
  P2: Fly cold-start guard merged
  P3: entrypoint.sh idempotent migrations
  P4: demo wallet pre-fund
  P5: rollback observability
  P6: pm2 log rotation + tmux tweaks
  P7: pnpm-store path pinned
  P8: CI gate hard-fail / timeout
drills:
  - Green-flag drill completed
  - Live-fire rollback rehearsal completed
done:
  - secrets-verify passes on Fly & Vercel
EOF

# 4. Checklist generator
cat > bin/gen-checklist.js <<'EOF'
#!/usr/bin/env node
const fs = require('fs');
const yaml = require('js-yaml');
const src = yaml.load(fs.readFileSync('plan-b2.yaml', 'utf8'));
let md = '# Plan Bâ—.2 â€” progress tracker\n\n';
for (const [section, body] of Object.entries({
  Patches: src.patches,
  Drills:  src.drills,
  'Definition of Done': src.done
})) {
  md += `## ${section}\n`;
  if (Array.isArray(body)) {
    body.forEach(i => md += `- [ ] ${i}\n`);
  } else {
    Object.entries(body).forEach(([k,v]) => md += `- [ ] ${k} ${v}\n`);
  }
  md += '\n';
}
fs.writeFileSync('docs/plan-b2.checklist.md', md);
EOF
chmod +x bin/gen-checklist.js
node bin/gen-checklist.js

# 5. Checklist linter
cat > bin/lint-checklist.js <<'EOF'
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const FILE = path.join(__dirname, '..', 'docs', 'plan-b2.checklist.md');
const raw = fs.readFileSync(FILE, 'utf8').split('\n');
const boxRx = /^- \[([ x])] (.+)$/;
const items = [];
let badLine = null;
raw.forEach((line, idx) => {
  const m = line.match(boxRx);
  if (m) {
    const text = m[2].trim();
    items.push({ text, idx: idx + 1 });
  } else if (line.startsWith('- [')) {
    badLine = idx + 1;
  }
});
if (badLine) { console.error(`Malformed checkbox at line ${badLine}`); process.exit(1); }
const dups = items.filter((v, i, arr) => arr.findIndex(w => w.text === v.text) !== i);
if (dups.length) { console.error('Duplicate checklist items:', dups.map(d => d.text)); process.exit(2); }
const patchIds = items.map(i => i.text.match(/^(P\d+)/)).filter(Boolean).map(m => m[1]);
if (patchIds.length) {
  const sorted = [...patchIds].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
  if (patchIds.join() !== sorted.join()) {
    console.error('Patch items out of order:', patchIds.join(', '));
    process.exit(3);
  }
}
console.log('Checklist lint âœ”');
EOF
chmod +x bin/lint-checklist.js

# 6. GitHub Action: tick-checklist
cat > .github/actions/tick-checklist/action.yml <<EOF
name: Tick Checklist Item
description: Mark a Markdown checklist item as done with audit trail.
runs:
  using: 'node16'
  main: 'index.js'
inputs:
  item:
    description: 'Exact text or unique substring of the checklist line'
    required: true
  path:
    description: 'Relative path to checklist file'
    default: 'docs/plan-b2.checklist.md'
EOF

cat > .github/actions/tick-checklist/index.js <<'EOF'
const core = require('@actions/core');
const fs   = require('fs');
const path = require('path');

(async () => {
  try {
    const item = core.getInput('item', { required: true });
    const file = core.getInput('path');
    const FILE = path.join(process.cwd(), file);
    let txt = fs.readFileSync(FILE, 'utf8');
    const now = new Date().toISOString().slice(0,16).replace('T',' ');
    const esc = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const rx  = new RegExp(`^- \\[ \\] .*${esc}.*$`, 'm');
    if (!rx.test(txt)) throw new Error(`Item not found: ${item}`);
    txt = txt.replace(rx, m =>
      m.replace('- [ ]', '- [x]')
        .concat(` <!-- done-by @${process.env.GITHUB_ACTOR || 'local'} at ${now} -->`)
    );
    fs.writeFileSync(FILE, txt);
    console.log(`âœ” ticked: ${item}`);
  } catch (e) {
    core.setFailed(e.message);
  }
})();
EOF

# 7. Commit
git add .
git commit -m "feat(plan-b): scaffold checklist system, generator, linter, local action"

echo ""
echo "âœ… Bootstrapped successfully!"
echo "ğŸ“Œ Next: review and push with:"
echo "   git push origin main"

#!/usr/bin/env bash
set -euo pipefail
CMD=${1:-start}; TMP=/tmp/plan_b_stopwatch
[[ "$CMD" == start ]] && { date -u +%s > "$TMP"; echo "Stopwatch started."; exit; }
[[ "$CMD" == check ]] || { echo "Usage: $0 {start|check}"; exit 1; }
[[ -f "$TMP" ]] || { echo "::error::Stopwatch not started."; exit 1; }
START=$(cat "$TMP"); NOW=$(date -u +%s); DUR=$((NOW-START)); echo "Elapsed ${DUR}s"
(( DUR > 7200 )) && { echo "::error::>2 h buffer blown"; exit 1; }
#!/usr/bin/env bash
set -euo pipefail

START=$(date -u +%s)
echo "ğŸ Starting green-flag smoke suite at $(date -u)"

run_or_fail() {
  DESC="$1"
  CMD="$2"
  echo "::group::Running: $DESC"
  echo "+ $CMD"
  bash -c "$CMD" || { echo "âŒ FAILED: $DESC"; exit 1; }
  echo "âœ… PASSED: $DESC"
  echo "::endgroup::"
}

# Example smoke test invocations â€” replace as needed
run_or_fail "Ping demo API" "curl -fs https://demo.vercel.app/api/ping"
run_or_fail "Fly healthcheck" "curl -fs https://operator.fly.dev/healthz"

# Optional if smoke:* scripts exist
[[ -f package.json ]] && jq -e '.scripts[\"smoke:fork\"]' package.json &>/dev/null && run_or_fail "smoke:fork" "pnpm run smoke:fork" || echo "ğŸŸ¡ Skipping smoke:fork (not defined)"
[[ -f package.json ]] && jq -e '.scripts[\"smoke:amoy\"]' package.json &>/dev/null && run_or_fail "smoke:amoy" "pnpm run smoke:amoy" || echo "ğŸŸ¡ Skipping smoke:amoy (not defined)"

END=$(date -u +%s)
DUR=$((END - START))
echo "ğŸ•’ Duration: ${DUR}s"
echo "$DUR" > /tmp/stopwatch

# ProfitFlip â€” One-Pane-of-Glass CI & Automation Strategy

ProfitFlip is a CI-first project built around three uncompromising principles:

1. **Progress is observable inside the repo â€” not in third-party tools.**
2. **Scripts are durable, auditable, and built for reuse.**
3. **The README you are reading is the single source of truth.**

---

## ğŸ“Š Project Task Log

âœ… = completeâ€ƒğŸ”„ = in progressâ€ƒğŸ›‘ = skipped

| Status | Task |
|--------|------|
| âœ… | Scaffolded Plan B checklist system |
| âœ… | CI job ticks checklist items using `tick-checklist` |
| âœ… | `run-green-flag.sh` enforces buffer and logs failures |
| âœ… | `bash-vault/` created with script + metadata scaffold |
| ğŸ”„ | Finish vault generator (`new-script.sh`) |
| ğŸ”„ | Populate vault with first real script |
| ğŸ”„ | Auto-generate `bash-vault/index.md` with sync-index.js |
| âœ… | Patched failing `demo.vercel.app` smoke test |
| ğŸ›‘ | Dropped GitHub Projects in favor of README tracking |

---

## ğŸ§  Strategy

We do not use GitHub Issues, Projects, or external tools to track tasks.  
This `README.md` and the CI-verified checklist are the **only sources of truth**.

---

## ğŸ§© Key Files

| File | Description |
|------|-------------|
| `plan-b2.yaml` | Backlog source of truth |
| `docs/plan-b2.checklist.md` | CI-driven task checklist |
| `scripts/run-green-flag.sh` | Smoke test + buffer fail logic |
| `bash-vault/` | Reusable script storage with metadata |
| `Makefile` | Task runner: `make new`, `make sync`, `make checklist` |

---

## ğŸš€ Quickstart

```bash
git clone https://github.com/metagrati/ProfitFlip.git
pnpm install
./bootstrap-plan-b2.sh
make checklist        # regenerate .checklist.md
make smoke            # run CI drills
make new NAME=fix-env.sh
make sync             # update vault index
{
  "nodes": [
    {
      "id": "/home/profitflip/test/scripts",
      "label": "scripts",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/repo-kg.json",
      "label": "repo-kg.json",
      "type": "file",
      "sizeBytes": 8572,
      "lastModified": "2025-04-23T16:13:04.678Z",
      "lineCount": 316
    },
    {
      "id": "/home/profitflip/test/post-bootstrap-ops.sh",
      "label": "post-bootstrap-ops.sh",
      "type": "file",
      "sizeBytes": 1737,
      "lastModified": "2025-04-23T14:28:25.138Z",
      "lineCount": 67
    },
    {
      "id": "/home/profitflip/test/plan-b2.yaml",
      "label": "plan-b2.yaml",
      "type": "file",
      "sizeBytes": 418,
      "lastModified": "2025-04-23T14:28:44.537Z",
      "lineCount": 15
    },
    {
      "id": "/home/profitflip/test/package.json",
      "label": "package.json",
      "type": "file",
      "sizeBytes": 55,
      "lastModified": "2025-04-23T14:05:34.726Z",
      "lineCount": 6
    },
    {
      "id": "/home/profitflip/test/package-lock.json",
      "label": "package-lock.json",
      "type": "file",
      "sizeBytes": 895,
      "lastModified": "2025-04-23T14:05:34.738Z",
      "lineCount": 33
    },
    {
      "id": "/home/profitflip/test/myfile.txt",
      "label": "myfile.txt",
      "type": "file",
      "sizeBytes": 23,
      "lastModified": "2025-04-23T15:54:15.797Z",
      "lineCount": 2
    },
    {
      "id": "/home/profitflip/test/kg-repo.bash",
      "label": "kg-repo.bash",
      "type": "file",
      "sizeBytes": 69,
      "lastModified": "2025-04-23T15:45:24.064Z",
      "lineCount": 4
    },
    {
      "id": "/home/profitflip/test/docs",
      "label": "docs",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/bootstrap-plan-b2.sh.old",
      "label": "bootstrap-plan-b2.sh.old",
      "type": "file",
      "sizeBytes": 3795,
      "lastModified": "2025-04-23T13:45:24.161Z",
      "lineCount": 103
    },
    {
      "id": "/home/profitflip/test/bootstrap-plan-b2.sh",
      "label": "bootstrap-plan-b2.sh",
      "type": "file",
      "sizeBytes": 4738,
      "lastModified": "2025-04-23T14:05:23.063Z",
      "lineCount": 158
    },
    {
      "id": "/home/profitflip/test/bin",
      "label": "bin",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/bash-vault",
      "label": "bash-vault",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/README.md",
      "label": "README.md",
      "type": "file",
      "sizeBytes": 1814,
      "lastModified": "2025-04-23T15:40:52.787Z",
      "lineCount": 58
    },
    {
      "id": "/home/profitflip/test/Makefile",
      "label": "Makefile",
      "type": "file",
      "sizeBytes": 256,
      "lastModified": "2025-04-23T15:30:25.695Z",
      "lineCount": 12
    },
    {
      "id": "/home/profitflip/test/scripts/stopwatch.sh",
      "label": "scripts/stopwatch.sh",
      "type": "file",
      "sizeBytes": 456,
      "lastModified": "2025-04-23T13:46:13.104Z",
      "lineCount": 9
    },
    {
      "id": "/home/profitflip/test/scripts/run-green-flag.sh",
      "label": "scripts/run-green-flag.sh",
      "type": "file",
      "sizeBytes": 1020,
      "lastModified": "2025-04-23T15:30:21.819Z",
      "lineCount": 30
    },
    {
      "id": "/home/profitflip/test/docs/plan-b2.checklist.md",
      "label": "docs/plan-b2.checklist.md",
      "type": "file",
      "sizeBytes": 507,
      "lastModified": "2025-04-23T14:28:44.641Z",
      "lineCount": 20
    },
    {
      "id": "/home/profitflip/test/bin/lint-checklist.js",
      "label": "bin/lint-checklist.js",
      "type": "file",
      "sizeBytes": 1150,
      "lastModified": "2025-04-23T14:28:44.653Z",
      "lineCount": 30,
      "complexity": {}
    },
    {
      "id": "/home/profitflip/test/bin/gen-checklist.js",
      "label": "bin/gen-checklist.js",
      "type": "file",
      "sizeBytes": 582,
      "lastModified": "2025-04-23T14:28:44.537Z",
      "lineCount": 20,
      "complexity": {}
    },
    {
      "id": "/home/profitflip/test/bash-vault/sync-index.js",
      "label": "bash-vault/sync-index.js",
      "type": "file",
      "sizeBytes": 830,
      "lastModified": "2025-04-23T15:30:25.695Z",
      "lineCount": 32,
      "complexity": {}
    },
    {
      "id": "/home/profitflip/test/bash-vault/scripts",
      "label": "bash-vault/scripts",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/bash-vault/new-script.sh",
      "label": "bash-vault/new-script.sh",
      "type": "file",
      "sizeBytes": 508,
      "lastModified": "2025-04-23T16:09:16.213Z",
      "lineCount": 26
    },
    {
      "id": "/home/profitflip/test/bash-vault/metadata",
      "label": "bash-vault/metadata",
      "type": "directory"
    },
    {
      "id": "/home/profitflip/test/bash-vault/index.md",
      "label": "bash-vault/index.md",
      "type": "file",
      "sizeBytes": 0,
      "lastModified": "2025-04-23T15:30:25.695Z",
      "lineCount": 1
    },
    {
      "id": "/home/profitflip/test/bash-vault/scripts/initialize-vault.sh",
      "label": "bash-vault/scripts/initialize-vault.sh",
      "type": "file",
      "sizeBytes": 777,
      "lastModified": "2025-04-23T16:09:16.221Z",
      "lineCount": 35
    },
    {
      "id": "module:fs",
      "label": "fs",
      "type": "externalModule"
    },
    {
      "id": "module:path",
      "label": "path",
      "type": "externalModule"
    },
    {
      "id": "module:js-yaml",
      "label": "js-yaml",
      "type": "externalModule"
    },
    {
      "id": "build:package.json",
      "label": "package.json deps",
      "type": "buildConfig",
      "dependencies": [
        {
          "name": "js-yaml",
          "version": "^4.1.0",
          "dev": true
        }
      ]
    }
  ],
  "edges": [
    {
      "source": "/home/profitflip/test/scripts",
      "target": "/home/profitflip/test/scripts/stopwatch.sh",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/scripts",
      "target": "/home/profitflip/test/scripts/run-green-flag.sh",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/docs",
      "target": "/home/profitflip/test/docs/plan-b2.checklist.md",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bin",
      "target": "/home/profitflip/test/bin/lint-checklist.js",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bin",
      "target": "/home/profitflip/test/bin/gen-checklist.js",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault",
      "target": "/home/profitflip/test/bash-vault/sync-index.js",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault",
      "target": "/home/profitflip/test/bash-vault/scripts",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault",
      "target": "/home/profitflip/test/bash-vault/new-script.sh",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault",
      "target": "/home/profitflip/test/bash-vault/metadata",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault",
      "target": "/home/profitflip/test/bash-vault/index.md",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bash-vault/scripts",
      "target": "/home/profitflip/test/bash-vault/scripts/initialize-vault.sh",
      "relationship": "contains"
    },
    {
      "source": "/home/profitflip/test/bin/lint-checklist.js",
      "target": "module:fs",
      "relationship": "imports"
    },
    {
      "source": "/home/profitflip/test/bin/lint-checklist.js",
      "target": "module:path",
      "relationship": "imports"
    },
    {
      "source": "/home/profitflip/test/bin/gen-checklist.js",
      "target": "module:fs",
      "relationship": "imports"
    },
    {
      "source": "/home/profitflip/test/bin/gen-checklist.js",
      "target": "module:js-yaml",
      "relationship": "imports"
    },
    {
      "source": "/home/profitflip/test/bash-vault/sync-index.js",
      "target": "module:fs",
      "relationship": "imports"
    },
    {
      "source": "/home/profitflip/test/bash-vault/sync-index.js",
      "target": "module:path",
      "relationship": "imports"
    },
    {
      "source": "build:package.json",
      "target": "module:js-yaml",
      "relationship": "depends_on"
    }
  ]
}{
  "name": "test",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "devDependencies": {
        "js-yaml": "^4.1.0"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    }
  }
}
vault:
	@echo "Vault commands:"
	@echo "  make new NAME=foo.sh    - Create script + metadata + sync index"
	@echo "  make sync               - Rebuild index from metadata"

new:
	bash bash-vault/new-script.sh $(NAME)

sync:
	node bash-vault/sync-index.js

#!/usr/bin/env bash
# post-bootstrap-ops.sh â€” enhances ProfitFlip after Plan BÂ² scaffolding
# Usage: bash post-bootstrap-ops.sh

set -euo pipefail

# Assertions
assert_file_exists() {
  [[ -f "$1" ]] || { echo "âŒ Missing required file: $1"; exit 1; }
}

assert_contains() {
  grep -q "$2" "$1" || { echo "âŒ File $1 does not contain expected text: $2"; exit 1; }
}

echo "ğŸ” Checking repo state..."

# Validate required base files
assert_file_exists plan-b2.yaml
assert_file_exists docs/plan-b2.checklist.md
assert_file_exists .github/workflows/ci-status.yml

# Step 1: Trigger race-test manually (instruct user, not automated)
echo "ğŸ“Œ ACTION REQUIRED: Please go to GitHub â†’ Actions â†’ run `race-test.yml`"
echo "  Then ensure both checklist items (P2, P3) are ticked, and no conflicts occurred."
echo ""

# Step 2: Add Makefile
echo "ğŸ“„ Creating Makefile..."

cat > Makefile <<'EOF'
checklist:
	node bin/gen-checklist.js > docs/plan-b2.checklist.md

lint:
	node bin/lint-checklist.js

smoke:
	bash scripts/run-green-flag.sh

tick:
	node .github/actions/tick-checklist/index.js --item="Green-flag drill"

bootstrap:
	./bootstrap-plan-b2.sh
EOF

assert_contains Makefile "checklist:"
assert_contains Makefile "lint:"

# Step 3: Expand README
echo "ğŸ“ Updating README.md..."

cat > README.md <<'EOF'
# ProfitFlip â€“ Checklist-driven Contingency Automation

ProfitFlip turns a YAML backlog (`plan-b2.yaml`) into a GitHub-hosted Markdown checklist, then uses a custom GitHub Action to tick items off after successful smoke tests.

## Quick start

```bash
git clone https://github.com/metagrati/ProfitFlip.git
pnpm install
./bootstrap-plan-b2.sh
make checklist  # or: node bin/gen-checklist.js > docs/plan-b2.checklist.md

git pull
git push
node ../kg-generator/index.js -d . -o repo-kg.json
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const FILE = path.join(__dirname, '..', 'docs', 'plan-b2.checklist.md');
const raw = fs.readFileSync(FILE, 'utf8').split('\n');
const boxRx = /^- \[([ x])] (.+)$/;
const items = [];
let badLine = null;
raw.forEach((line, idx) => {
  const m = line.match(boxRx);
  if (m) {
    const text = m[2].trim();
    items.push({ text, idx: idx + 1 });
  } else if (line.startsWith('- [')) {
    badLine = idx + 1;
  }
});
if (badLine) { console.error(`Malformed checkbox at line ${badLine}`); process.exit(1); }
const dups = items.filter((v, i, arr) => arr.findIndex(w => w.text === v.text) !== i);
if (dups.length) { console.error('Duplicate checklist items:', dups.map(d => d.text)); process.exit(2); }
const patchIds = items.map(i => i.text.match(/^(P\d+)/)).filter(Boolean).map(m => m[1]);
if (patchIds.length) {
  const sorted = [...patchIds].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
  if (patchIds.join() !== sorted.join()) {
    console.error('Patch items out of order:', patchIds.join(', '));
    process.exit(3);
  }
}
console.log('Checklist lint âœ”');
#!/usr/bin/env node
const fs = require('fs');
const yaml = require('js-yaml');
const src = yaml.load(fs.readFileSync('plan-b2.yaml', 'utf8'));
let md = '# Plan Bâ—.2 â€” progress tracker\n\n';
for (const [section, body] of Object.entries({
  Patches: src.patches,
  Drills:  src.drills,
  'Definition of Done': src.done
})) {
  md += `## ${section}\n`;
  if (Array.isArray(body)) {
    body.forEach(i => md += `- [ ] ${i}\n`);
  } else {
    Object.entries(body).forEach(([k,v]) => md += `- [ ] ${k} ${v}\n`);
  }
  md += '\n';
}
fs.writeFileSync('docs/plan-b2.checklist.md', md);
